import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateMethod,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _3 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o2) {
            return Object.prototype.toString.call(o2).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o2, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_3.util.type(o2)) {
              case "Object":
                id = _3.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o2) {
                  if (o2.hasOwnProperty(key)) {
                    clone[key] = deepClone(o2[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _3.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o2.forEach(function(v3, i) {
                  clone[i] = deepClone(v3, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o2;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no4 = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no4)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _3.util.clone(_3.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _3.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token2 in grammar) {
              if (grammar.hasOwnProperty(token2)) {
                if (token2 == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token2)) {
                  ret[token2] = grammar[token2];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _3.languages.DFS(_3.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o2, callback, type, visited) {
            visited = visited || {};
            var objId = _3.util.objId;
            for (var i in o2) {
              if (o2.hasOwnProperty(i)) {
                callback.call(o2, i, o2[i], type || i);
                var property = o2[i];
                var propertyType = _3.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _3.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _3.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _3.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _3.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _3.util.getLanguage(element);
          var grammar = _3.languages[language];
          _3.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _3.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _3.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _3.hooks.run("after-highlight", env);
            _3.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _3.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _3.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _3.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_3.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_3.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_3.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _3.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _3.tokenize(env.code, env.grammar);
          _3.hooks.run("after-tokenize", env);
          return Token.stringify(_3.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token2 in rest) {
              grammar[token2] = rest[token2];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _3.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _3.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _3;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o2, language) {
        if (typeof o2 == "string") {
          return o2;
        }
        if (Array.isArray(o2)) {
          var s2 = "";
          o2.forEach(function(e2) {
            s2 += stringify(e2, language);
          });
          return s2;
        }
        var env = {
          type: o2.type,
          content: stringify(o2.content, language),
          tag: "span",
          classes: ["token", o2.type],
          attributes: {},
          language
        };
        var aliases = o2.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _3.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token2 in grammar) {
          if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
            continue;
          }
          var patterns = grammar[token2];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j3 = 0; j3 < patterns.length; ++j3) {
            if (rematch && rematch.cause == token2 + "," + j3) {
              return;
            }
            var patternObj = patterns[j3];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to4 = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k3 = currentNode; k3 !== tokenList.tail && (p < to4 || typeof k3.value === "string"); k3 = k3.next) {
                  removeCount++;
                  p += k3.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token2, inside ? _3.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token2 + "," + j3,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _3;
        }
        if (!_3.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_3.highlight(code, _3.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _3;
      }
      var script = _3.util.currentScript();
      if (script) {
        _3.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _3.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_3.manual) {
          _3.highlightAll();
        }
      }
      if (!_3.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _3;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options2) {
      return options2.clone !== false && options2.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options2) : value;
    }
    function defaultArrayMerge(target, source, options2) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options2);
      });
    }
    function getMergeFunction(key, options2) {
      if (!options2.customMerge) {
        return deepmerge;
      }
      var customMerge = options2.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_3) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options2) {
      var destination = {};
      if (options2.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options2);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options2.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options2)(target[key], source[key], options2);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options2);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options2) {
      options2 = options2 || {};
      options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
      options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
      options2.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options2);
      } else if (sourceIsArray) {
        return options2.arrayMerge(target, source, options2);
      } else {
        return mergeObject(target, source, options2);
      }
    }
    deepmerge.all = function deepmergeAll(array, options2) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options2);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/@react-email/body/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps = (a, b3) => __defProps(a, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Body = React.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return (0, import_jsx_runtime.jsx)(
      "body",
      __spreadProps(__spreadValues({}, props), {
        style: {
          background: style == null ? void 0 : style.background,
          backgroundColor: style == null ? void 0 : style.backgroundColor
        },
        ref,
        children: (0, import_jsx_runtime.jsx)(
          "table",
          {
            border: 0,
            width: "100%",
            cellPadding: "0",
            cellSpacing: "0",
            role: "presentation",
            align: "center",
            children: (0, import_jsx_runtime.jsx)("tbody", { children: (0, import_jsx_runtime.jsx)("tr", { children: (0, import_jsx_runtime.jsx)("td", { style, children }) }) })
          }
        )
      })
    );
  }
);
Body.displayName = "Body";

// node_modules/@react-email/button/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp2(a, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b3) => __defProps2(a, __getOwnPropDescs2(b3));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function convertToPx(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = /^([\d.]+)(px|em|rem|%)$/.exec(value);
  if (matches && matches.length === 3) {
    const numValue = Number.parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  }
  return 0;
}
function parsePaddingValue(value) {
  if (typeof value === "number")
    return {
      paddingTop: value,
      paddingBottom: value,
      paddingLeft: value,
      paddingRight: value
    };
  if (typeof value === "string") {
    const values = value.toString().trim().split(/\s+/);
    if (values.length === 1) {
      return {
        paddingTop: values[0],
        paddingBottom: values[0],
        paddingLeft: values[0],
        paddingRight: values[0]
      };
    }
    if (values.length === 2) {
      return {
        paddingTop: values[0],
        paddingRight: values[1],
        paddingBottom: values[0],
        paddingLeft: values[1]
      };
    }
    if (values.length === 3) {
      return {
        paddingTop: values[0],
        paddingRight: values[1],
        paddingBottom: values[2],
        paddingLeft: values[1]
      };
    }
    if (values.length === 4) {
      return {
        paddingTop: values[0],
        paddingRight: values[1],
        paddingBottom: values[2],
        paddingLeft: values[3]
      };
    }
  }
  return {
    paddingTop: void 0,
    paddingBottom: void 0,
    paddingLeft: void 0,
    paddingRight: void 0
  };
}
function parsePadding(properties) {
  let paddingTop;
  let paddingRight;
  let paddingBottom;
  let paddingLeft;
  for (const [key, value] of Object.entries(properties)) {
    if (key === "padding") {
      ({ paddingTop, paddingBottom, paddingLeft, paddingRight } = parsePaddingValue(value));
    } else if (key === "paddingTop") {
      paddingTop = value;
    } else if (key === "paddingRight") {
      paddingRight = value;
    } else if (key === "paddingBottom") {
      paddingBottom = value;
    } else if (key === "paddingLeft") {
      paddingLeft = value;
    }
  }
  return {
    paddingTop: paddingTop ? convertToPx(paddingTop) : void 0,
    paddingRight: paddingRight ? convertToPx(paddingRight) : void 0,
    paddingBottom: paddingBottom ? convertToPx(paddingBottom) : void 0,
    paddingLeft: paddingLeft ? convertToPx(paddingLeft) : void 0
  };
}
var pxToPt = (px) => typeof px === "number" && !Number.isNaN(Number(px)) ? px * 3 / 4 : void 0;
var maxFontWidth = 5;
function computeFontWidthAndSpaceCount(expectedWidth) {
  if (expectedWidth === 0) return [0, 0];
  let smallestSpaceCount = 0;
  const computeRequiredFontWidth = () => {
    if (smallestSpaceCount > 0) {
      return expectedWidth / smallestSpaceCount / 2;
    }
    return Number.POSITIVE_INFINITY;
  };
  while (computeRequiredFontWidth() > maxFontWidth) {
    smallestSpaceCount++;
  }
  return [computeRequiredFontWidth(), smallestSpaceCount];
}
var Button = React2.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style, target = "_blank" } = _b, props = __objRest2(_b, ["children", "style", "target"]);
    const { paddingTop, paddingRight, paddingBottom, paddingLeft } = parsePadding(style != null ? style : {});
    const y2 = (paddingTop != null ? paddingTop : 0) + (paddingBottom != null ? paddingBottom : 0);
    const textRaise = pxToPt(y2);
    const [plFontWidth, plSpaceCount] = computeFontWidthAndSpaceCount(
      paddingLeft != null ? paddingLeft : 0
    );
    const [prFontWidth, prSpaceCount] = computeFontWidthAndSpaceCount(
      paddingRight != null ? paddingRight : 0
    );
    return (0, import_jsx_runtime2.jsxs)(
      "a",
      __spreadProps2(__spreadValues2({}, props), {
        ref,
        style: __spreadProps2(__spreadValues2({
          lineHeight: "100%",
          textDecoration: "none",
          display: "inline-block",
          maxWidth: "100%",
          msoPaddingAlt: "0px"
        }, style), {
          paddingTop,
          paddingRight,
          paddingBottom,
          paddingLeft
        }),
        target,
        children: [
          (0, import_jsx_runtime2.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                // The `&#8202;` is as close to `1px` of an empty character as we can get, then, we use the `mso-font-width`
                // to scale it according to what padding the developer wants. `mso-font-width` also does not allow for percentages
                // >= 500% so we need to add extra spaces accordingly.
                //
                // See https://github.com/resend/react-email/issues/1512 for why we do not use letter-spacing instead.
                __html: `<!--[if mso]><i style="mso-font-width:${plFontWidth * 100}%;mso-text-raise:${textRaise}" hidden>${"&#8202;".repeat(
                  plSpaceCount
                )}</i><![endif]-->`
              }
            }
          ),
          (0, import_jsx_runtime2.jsx)(
            "span",
            {
              style: {
                maxWidth: "100%",
                display: "inline-block",
                lineHeight: "120%",
                msoPaddingAlt: "0px",
                msoTextRaise: pxToPt(paddingBottom)
              },
              children
            }
          ),
          (0, import_jsx_runtime2.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                __html: `<!--[if mso]><i style="mso-font-width:${prFontWidth * 100}%" hidden>${"&#8202;".repeat(
                  prSpaceCount
                )}&#8203;</i><![endif]-->`
              }
            }
          )
        ]
      })
    );
  }
);
Button.displayName = "Button";

// node_modules/@react-email/code-block/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var PrismImport = __toESM(require_prism(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var __defProp3 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp3.call(b3, prop))
      __defNormalProp3(a, prop, b3[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b3)) {
      if (__propIsEnum3.call(b3, prop))
        __defNormalProp3(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b3) => __defProps3(a, __getOwnPropDescs3(b3));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var _a;
var Prism = (_a = PrismImport.default) != null ? _a : PrismImport;
Prism.languages.markup = {
  comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true },
  prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true },
  doctype: {
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
      },
      string: { pattern: /"[^"]*"|'[^']*'/, greedy: true },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/
    }
  },
  cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/,
        inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            { pattern: /^=/, alias: "attr-equals" },
            { pattern: /^(\s*)["']|["']$/, lookbehind: true }
          ]
        }
      },
      punctuation: /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: { namespace: /^[^\s>\/:]+:/ }
      }
    }
  },
  entity: [
    { pattern: /&[\da-z]{1,8};/i, alias: "named-entity" },
    /&#x?[\da-f]{1,8};/i
  ]
}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e2) {
  "entity" === e2.type && (e2.attributes.title = e2.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  value: function(e2, t8) {
    var n2 = {}, n2 = (n2["language-" + t8] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[t8]
    }, n2.cdata = /^<!\[CDATA\[|\]\]>$/i, {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: n2
      }
    }), t8 = (n2["language-" + t8] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[t8]
    }, {});
    t8[e2] = {
      pattern: RegExp(
        /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
          /__/g,
          function() {
            return e2;
          }
        ),
        "i"
      ),
      lookbehind: true,
      greedy: true,
      inside: n2
    }, Prism.languages.insertBefore("markup", "cdata", t8);
  }
}), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  value: function(e2, t8) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + e2 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [t8, "language-" + t8],
              inside: Prism.languages[t8]
            },
            punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/]
          }
        }
      }
    });
  }
}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e2) {
  var t8 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, t8 = (e2.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp(
        "@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t8.source + ")*?" + /(?:;|(?=\s*\{))/.source
      ),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        keyword: {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
      }
    },
    url: {
      pattern: RegExp(
        "\\burl\\((?:" + t8.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
        "i"
      ),
      greedy: true,
      inside: {
        function: /^url/i,
        punctuation: /^\(|\)$/,
        string: { pattern: RegExp("^" + t8.source + "$"), alias: "url" }
      }
    },
    selector: {
      pattern: RegExp(
        `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t8.source + ")*(?=\\s*\\{)"
      ),
      lookbehind: true
    },
    string: { pattern: t8, greedy: true },
    property: {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    important: /!important\b/i,
    function: {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    punctuation: /[(){};:,]/
  }, e2.languages.css.atrule.inside.rest = e2.languages.css, e2.languages.markup);
  t8 && (t8.tag.addInlined("style", "css"), t8.tag.addAttribute("style", "css"));
}(Prism), Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: { punctuation: /[.\\]/ }
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/
}, function(e2) {
  var t8 = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, n2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a = "(?:[^\\\\-]|" + n2.source + ")", a = RegExp(a + "-" + a), r2 = {
    pattern: /(<|')[^<>']+(?=[>']$)/,
    lookbehind: true,
    alias: "variable"
  };
  e2.languages.regex = {
    "char-class": {
      pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
      lookbehind: true,
      inside: {
        "char-class-negation": {
          pattern: /(^\[)\^/,
          lookbehind: true,
          alias: "operator"
        },
        "char-class-punctuation": {
          pattern: /^\[|\]$/,
          alias: "punctuation"
        },
        range: {
          pattern: a,
          inside: {
            escape: n2,
            "range-punctuation": { pattern: /-/, alias: "operator" }
          }
        },
        "special-escape": t8,
        "char-set": {
          pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
          alias: "class-name"
        },
        escape: n2
      }
    },
    "special-escape": t8,
    "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" },
    backreference: [
      { pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" },
      {
        pattern: /\\k<[^<>']+>/,
        alias: "keyword",
        inside: { "group-name": r2 }
      }
    ],
    anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" },
    escape: n2,
    group: [
      {
        pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
        alias: "punctuation",
        inside: { "group-name": r2 }
      },
      { pattern: /\)/, alias: "punctuation" }
    ],
    quantifier: {
      pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
      alias: "number"
    },
    alternation: { pattern: /\|/, alias: "keyword" }
  };
}(Prism), Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  keyword: [
    { pattern: /((?:^|\})\s*)catch\b/, lookbehind: true },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
}), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  parameter: [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
}), Prism.languages.insertBefore("javascript", "string", {
  hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": { pattern: /^`|`$/, alias: "string" },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      string: /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
}), Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
}), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
  /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
  "javascript"
)), Prism.languages.js = Prism.languages.javascript, Prism.languages.abap = {
  comment: /^\*.*/m,
  string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  "string-template": {
    pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
    lookbehind: true,
    alias: "string"
  },
  "eol-comment": { pattern: /(^|\s)".*/m, lookbehind: true, alias: "comment" },
  keyword: {
    pattern: /(\s|\.|^)(?:\*-INPUT|\?TO|ABAP-SOURCE|ABBREVIATED|ABS|ABSTRACT|ACCEPT|ACCEPTING|ACCESSPOLICY|ACCORDING|ACOS|ACTIVATION|ACTUAL|ADD|ADD-CORRESPONDING|ADJACENT|AFTER|ALIAS|ALIASES|ALIGN|ALL|ALLOCATE|ALPHA|ANALYSIS|ANALYZER|AND|ANY|APPEND|APPENDAGE|APPENDING|APPLICATION|ARCHIVE|AREA|ARITHMETIC|AS|ASCENDING|ASIN|ASPECT|ASSERT|ASSIGN|ASSIGNED|ASSIGNING|ASSOCIATION|ASYNCHRONOUS|AT|ATAN|ATTRIBUTES|AUTHORITY|AUTHORITY-CHECK|AVG|BACK|BACKGROUND|BACKUP|BACKWARD|BADI|BASE|BEFORE|BEGIN|BETWEEN|BIG|BINARY|BINDING|BIT|BIT-AND|BIT-NOT|BIT-OR|BIT-XOR|BLACK|BLANK|BLANKS|BLOB|BLOCK|BLOCKS|BLUE|BOUND|BOUNDARIES|BOUNDS|BOXED|BREAK-POINT|BT|BUFFER|BY|BYPASSING|BYTE|BYTE-CA|BYTE-CN|BYTE-CO|BYTE-CS|BYTE-NA|BYTE-NS|BYTE-ORDER|C|CA|CALL|CALLING|CASE|CAST|CASTING|CATCH|CEIL|CENTER|CENTERED|CHAIN|CHAIN-INPUT|CHAIN-REQUEST|CHANGE|CHANGING|CHANNELS|CHAR-TO-HEX|CHARACTER|CHARLEN|CHECK|CHECKBOX|CIRCULAR|CI_|CLASS|CLASS-CODING|CLASS-DATA|CLASS-EVENTS|CLASS-METHODS|CLASS-POOL|CLEANUP|CLEAR|CLIENT|CLOB|CLOCK|CLOSE|CN|CNT|CO|COALESCE|CODE|CODING|COLLECT|COLOR|COLUMN|COLUMNS|COL_BACKGROUND|COL_GROUP|COL_HEADING|COL_KEY|COL_NEGATIVE|COL_NORMAL|COL_POSITIVE|COL_TOTAL|COMMENT|COMMENTS|COMMIT|COMMON|COMMUNICATION|COMPARING|COMPONENT|COMPONENTS|COMPRESSION|COMPUTE|CONCAT|CONCATENATE|COND|CONDENSE|CONDITION|CONNECT|CONNECTION|CONSTANTS|CONTEXT|CONTEXTS|CONTINUE|CONTROL|CONTROLS|CONV|CONVERSION|CONVERT|COPIES|COPY|CORRESPONDING|COS|COSH|COUNT|COUNTRY|COVER|CP|CPI|CREATE|CREATING|CRITICAL|CS|CURRENCY|CURRENCY_CONVERSION|CURRENT|CURSOR|CURSOR-SELECTION|CUSTOMER|CUSTOMER-FUNCTION|DANGEROUS|DATA|DATABASE|DATAINFO|DATASET|DATE|DAYLIGHT|DBMAXLEN|DD\/MM\/YY|DD\/MM\/YYYY|DDMMYY|DEALLOCATE|DECIMALS|DECIMAL_SHIFT|DECLARATIONS|DEEP|DEFAULT|DEFERRED|DEFINE|DEFINING|DEFINITION|DELETE|DELETING|DEMAND|DEPARTMENT|DESCENDING|DESCRIBE|DESTINATION|DETAIL|DIALOG|DIRECTORY|DISCONNECT|DISPLAY|DISPLAY-MODE|DISTANCE|DISTINCT|DIV|DIVIDE|DIVIDE-CORRESPONDING|DIVISION|DO|DUMMY|DUPLICATE|DUPLICATES|DURATION|DURING|DYNAMIC|DYNPRO|E|EACH|EDIT|EDITOR-CALL|ELSE|ELSEIF|EMPTY|ENABLED|ENABLING|ENCODING|END|END-ENHANCEMENT-SECTION|END-LINES|END-OF-DEFINITION|END-OF-FILE|END-OF-PAGE|END-OF-SELECTION|ENDAT|ENDCASE|ENDCATCH|ENDCHAIN|ENDCLASS|ENDDO|ENDENHANCEMENT|ENDEXEC|ENDFOR|ENDFORM|ENDFUNCTION|ENDIAN|ENDIF|ENDING|ENDINTERFACE|ENDLOOP|ENDMETHOD|ENDMODULE|ENDON|ENDPROVIDE|ENDSELECT|ENDTRY|ENDWHILE|ENGINEERING|ENHANCEMENT|ENHANCEMENT-POINT|ENHANCEMENT-SECTION|ENHANCEMENTS|ENTRIES|ENTRY|ENVIRONMENT|EQ|EQUAL|EQUIV|ERRORMESSAGE|ERRORS|ESCAPE|ESCAPING|EVENT|EVENTS|EXACT|EXCEPT|EXCEPTION|EXCEPTION-TABLE|EXCEPTIONS|EXCLUDE|EXCLUDING|EXEC|EXECUTE|EXISTS|EXIT|EXIT-COMMAND|EXP|EXPAND|EXPANDING|EXPIRATION|EXPLICIT|EXPONENT|EXPORT|EXPORTING|EXTEND|EXTENDED|EXTENSION|EXTRACT|FAIL|FETCH|FIELD|FIELD-GROUPS|FIELD-SYMBOL|FIELD-SYMBOLS|FIELDS|FILE|FILTER|FILTER-TABLE|FILTERS|FINAL|FIND|FIRST|FIRST-LINE|FIXED-POINT|FKEQ|FKGE|FLOOR|FLUSH|FONT|FOR|FORM|FORMAT|FORWARD|FOUND|FRAC|FRAME|FRAMES|FREE|FRIENDS|FROM|FUNCTION|FUNCTION-POOL|FUNCTIONALITY|FURTHER|GAPS|GE|GENERATE|GET|GIVING|GKEQ|GKGE|GLOBAL|GRANT|GREATER|GREEN|GROUP|GROUPS|GT|HANDLE|HANDLER|HARMLESS|HASHED|HAVING|HDB|HEAD-LINES|HEADER|HEADERS|HEADING|HELP-ID|HELP-REQUEST|HIDE|HIGH|HINT|HOLD|HOTSPOT|I|ICON|ID|IDENTIFICATION|IDENTIFIER|IDS|IF|IGNORE|IGNORING|IMMEDIATELY|IMPLEMENTATION|IMPLEMENTATIONS|IMPLEMENTED|IMPLICIT|IMPORT|IMPORTING|IN|INACTIVE|INCL|INCLUDE|INCLUDES|INCLUDING|INCREMENT|INDEX|INDEX-LINE|INFOTYPES|INHERITING|INIT|INITIAL|INITIALIZATION|INNER|INOUT|INPUT|INSERT|INSTANCES|INTENSIFIED|INTERFACE|INTERFACE-POOL|INTERFACES|INTERNAL|INTERVALS|INTO|INVERSE|INVERTED-DATE|IS|ISO|ITERATOR|ITNO|JOB|JOIN|KEEP|KEEPING|KERNEL|KEY|KEYS|KEYWORDS|KIND|LANGUAGE|LAST|LATE|LAYOUT|LE|LEADING|LEAVE|LEFT|LEFT-JUSTIFIED|LEFTPLUS|LEFTSPACE|LEGACY|LENGTH|LESS|LET|LEVEL|LEVELS|LIKE|LINE|LINE-COUNT|LINE-SELECTION|LINE-SIZE|LINEFEED|LINES|LIST|LIST-PROCESSING|LISTBOX|LITTLE|LLANG|LOAD|LOAD-OF-PROGRAM|LOB|LOCAL|LOCALE|LOCATOR|LOG|LOG-POINT|LOG10|LOGFILE|LOGICAL|LONG|LOOP|LOW|LOWER|LPAD|LPI|LT|M|MAIL|MAIN|MAJOR-ID|MAPPING|MARGIN|MARK|MASK|MATCH|MATCHCODE|MAX|MAXIMUM|MEDIUM|MEMBERS|MEMORY|MESH|MESSAGE|MESSAGE-ID|MESSAGES|MESSAGING|METHOD|METHODS|MIN|MINIMUM|MINOR-ID|MM\/DD\/YY|MM\/DD\/YYYY|MMDDYY|MOD|MODE|MODIF|MODIFIER|MODIFY|MODULE|MOVE|MOVE-CORRESPONDING|MULTIPLY|MULTIPLY-CORRESPONDING|NA|NAME|NAMETAB|NATIVE|NB|NE|NESTED|NESTING|NEW|NEW-LINE|NEW-PAGE|NEW-SECTION|NEXT|NO|NO-DISPLAY|NO-EXTENSION|NO-GAP|NO-GAPS|NO-GROUPING|NO-HEADING|NO-SCROLLING|NO-SIGN|NO-TITLE|NO-TOPOFPAGE|NO-ZERO|NODE|NODES|NON-UNICODE|NON-UNIQUE|NOT|NP|NS|NULL|NUMBER|NUMOFCHAR|O|OBJECT|OBJECTS|OBLIGATORY|OCCURRENCE|OCCURRENCES|OCCURS|OF|OFF|OFFSET|OLE|ON|ONLY|OPEN|OPTION|OPTIONAL|OPTIONS|OR|ORDER|OTHER|OTHERS|OUT|OUTER|OUTPUT|OUTPUT-LENGTH|OVERFLOW|OVERLAY|PACK|PACKAGE|PAD|PADDING|PAGE|PAGES|PARAMETER|PARAMETER-TABLE|PARAMETERS|PART|PARTIALLY|PATTERN|PERCENTAGE|PERFORM|PERFORMING|PERSON|PF|PF-STATUS|PINK|PLACES|POOL|POSITION|POS_HIGH|POS_LOW|PRAGMAS|PRECOMPILED|PREFERRED|PRESERVING|PRIMARY|PRINT|PRINT-CONTROL|PRIORITY|PRIVATE|PROCEDURE|PROCESS|PROGRAM|PROPERTY|PROTECTED|PROVIDE|PUBLIC|PUSHBUTTON|PUT|QUEUE-ONLY|QUICKINFO|RADIOBUTTON|RAISE|RAISING|RANGE|RANGES|RAW|READ|READ-ONLY|READER|RECEIVE|RECEIVED|RECEIVER|RECEIVING|RED|REDEFINITION|REDUCE|REDUCED|REF|REFERENCE|REFRESH|REGEX|REJECT|REMOTE|RENAMING|REPLACE|REPLACEMENT|REPLACING|REPORT|REQUEST|REQUESTED|RESERVE|RESET|RESOLUTION|RESPECTING|RESPONSIBLE|RESULT|RESULTS|RESUMABLE|RESUME|RETRY|RETURN|RETURNCODE|RETURNING|RIGHT|RIGHT-JUSTIFIED|RIGHTPLUS|RIGHTSPACE|RISK|RMC_COMMUNICATION_FAILURE|RMC_INVALID_STATUS|RMC_SYSTEM_FAILURE|ROLE|ROLLBACK|ROUND|ROWS|RTTI|RUN|SAP|SAP-SPOOL|SAVING|SCALE_PRESERVING|SCALE_PRESERVING_SCIENTIFIC|SCAN|SCIENTIFIC|SCIENTIFIC_WITH_LEADING_ZERO|SCREEN|SCROLL|SCROLL-BOUNDARY|SCROLLING|SEARCH|SECONDARY|SECONDS|SECTION|SELECT|SELECT-OPTIONS|SELECTION|SELECTION-SCREEN|SELECTION-SET|SELECTION-SETS|SELECTION-TABLE|SELECTIONS|SELECTOR|SEND|SEPARATE|SEPARATED|SET|SHARED|SHIFT|SHORT|SHORTDUMP-ID|SIGN|SIGN_AS_POSTFIX|SIMPLE|SIN|SINGLE|SINH|SIZE|SKIP|SKIPPING|SMART|SOME|SORT|SORTABLE|SORTED|SOURCE|SPACE|SPECIFIED|SPLIT|SPOOL|SPOTS|SQL|SQLSCRIPT|SQRT|STABLE|STAMP|STANDARD|START-OF-SELECTION|STARTING|STATE|STATEMENT|STATEMENTS|STATIC|STATICS|STATUSINFO|STEP-LOOP|STOP|STRLEN|STRUCTURE|STRUCTURES|STYLE|SUBKEY|SUBMATCHES|SUBMIT|SUBROUTINE|SUBSCREEN|SUBSTRING|SUBTRACT|SUBTRACT-CORRESPONDING|SUFFIX|SUM|SUMMARY|SUMMING|SUPPLIED|SUPPLY|SUPPRESS|SWITCH|SWITCHSTATES|SYMBOL|SYNCPOINTS|SYNTAX|SYNTAX-CHECK|SYNTAX-TRACE|SYSTEM-CALL|SYSTEM-EXCEPTIONS|SYSTEM-EXIT|TAB|TABBED|TABLE|TABLES|TABLEVIEW|TABSTRIP|TAN|TANH|TARGET|TASK|TASKS|TEST|TESTING|TEXT|TEXTPOOL|THEN|THROW|TIME|TIMES|TIMESTAMP|TIMEZONE|TITLE|TITLE-LINES|TITLEBAR|TO|TOKENIZATION|TOKENS|TOP-LINES|TOP-OF-PAGE|TRACE-FILE|TRACE-TABLE|TRAILING|TRANSACTION|TRANSFER|TRANSFORMATION|TRANSLATE|TRANSPORTING|TRMAC|TRUNC|TRUNCATE|TRUNCATION|TRY|TYPE|TYPE-POOL|TYPE-POOLS|TYPES|ULINE|UNASSIGN|UNDER|UNICODE|UNION|UNIQUE|UNIT|UNIT_CONVERSION|UNIX|UNPACK|UNTIL|UNWIND|UP|UPDATE|UPPER|USER|USER-COMMAND|USING|UTF-8|VALID|VALUE|VALUE-REQUEST|VALUES|VARY|VARYING|VERIFICATION-MESSAGE|VERSION|VIA|VIEW|VISIBLE|WAIT|WARNING|WHEN|WHENEVER|WHERE|WHILE|WIDTH|WINDOW|WINDOWS|WITH|WITH-HEADING|WITH-TITLE|WITHOUT|WORD|WORK|WRITE|WRITER|X|XML|XOR|XSD|XSTRLEN|YELLOW|YES|YYMMDD|Z|ZERO|ZONE)(?![\w-])/i,
    lookbehind: true
  },
  number: /\b\d+\b/,
  operator: {
    pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
    lookbehind: true
  },
  "string-operator": {
    pattern: /(\s)&&?(?=\s)/,
    lookbehind: true,
    alias: "keyword"
  },
  "token-operator": [
    {
      pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
      lookbehind: true,
      alias: "punctuation"
    },
    { pattern: /[|{}]/, alias: "punctuation" }
  ],
  punctuation: /[,.:()]/
}, function() {
  var e2 = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
  Prism.languages.abnf = {
    comment: /;.*/,
    string: {
      pattern: /(?:%[is])?"[^"\n\r]*"/,
      greedy: true,
      inside: { punctuation: /^%[is]/ }
    },
    range: {
      pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
      alias: "number"
    },
    terminal: {
      pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
      alias: "number"
    },
    repetition: {
      pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
      lookbehind: true,
      alias: "operator"
    },
    definition: {
      pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
      lookbehind: true,
      alias: "keyword",
      inside: { punctuation: /<|>/ }
    },
    "core-rule": {
      pattern: RegExp("(?:(^|[^<\\w-])" + e2 + "|<" + e2 + ">)(?![\\w-])", "i"),
      lookbehind: true,
      alias: ["rule", "constant"],
      inside: { punctuation: /<|>/ }
    },
    rule: {
      pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
      lookbehind: true,
      inside: { punctuation: /<|>/ }
    },
    operator: /=\/?|\//,
    punctuation: /[()\[\]]/
  };
}(), Prism.languages.actionscript = Prism.languages.extend("javascript", {
  keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
  operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
}), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", {
  xml: {
    pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
    lookbehind: true,
    inside: Prism.languages.markup
  }
}), Prism.languages.ada = {
  comment: /--.*/,
  string: /"(?:""|[^"\r\f\n])*"/,
  number: [
    {
      pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
    },
    { pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i }
  ],
  attribute: { pattern: /\b'\w+/, alias: "attr-name" },
  keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|or|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
  boolean: /\b(?:false|true)\b/i,
  operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
  punctuation: /\.\.?|[,;():]/,
  char: /'.'/,
  variable: /\b[a-z](?:\w)*\b/i
}, Prism.languages.agda = {
  comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true },
  punctuation: /[(){}⦃⦄.;@]/,
  "class-name": { pattern: /((?:data|record) +)\S+/, lookbehind: true },
  function: { pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m, lookbehind: true },
  operator: { pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/, lookbehind: true },
  keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
}, Prism.languages.al = {
  comment: /\/\/.*|\/\*[\s\S]*?\*\//,
  string: {
    pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
    greedy: true
  },
  function: {
    pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
    lookbehind: true
  },
  keyword: [
    /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
    /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
  ],
  number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
  boolean: /\b(?:false|true)\b/i,
  variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
  "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
  operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
  punctuation: /[()\[\]{}:.;,]/
}, Prism.languages.antlr4 = {
  comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
  string: { pattern: /'(?:\\.|[^\\'\r\n])*'/, greedy: true },
  "character-class": {
    pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
    greedy: true,
    alias: "regex",
    inside: {
      range: {
        pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
        lookbehind: true,
        alias: "punctuation"
      },
      escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
      punctuation: /[\[\]]/
    }
  },
  action: {
    pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
    greedy: true,
    inside: {
      content: { pattern: /(\{)[\s\S]+(?=\})/, lookbehind: true },
      punctuation: /[{}]/
    }
  },
  command: {
    pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
    lookbehind: true,
    inside: { function: /\b\w+(?=\s*(?:[,(]|$))/, punctuation: /[,()]/ }
  },
  annotation: { pattern: /@\w+(?:::\w+)*/, alias: "keyword" },
  label: { pattern: /#[ \t]*\w+/, alias: "punctuation" },
  keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
  definition: [
    { pattern: /\b[a-z]\w*(?=\s*:)/, alias: ["rule", "class-name"] },
    { pattern: /\b[A-Z]\w*(?=\s*:)/, alias: ["token", "constant"] }
  ],
  constant: /\b[A-Z][A-Z_]*\b/,
  operator: /\.\.|->|[|~]|[*+?]\??/,
  punctuation: /[;:()=]/
}, Prism.languages.g4 = Prism.languages.antlr4, Prism.languages.apacheconf = {
  comment: /#.*/,
  "directive-inline": {
    pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
    lookbehind: true,
    alias: "property"
  },
  "directive-block": {
    pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
    inside: {
      "directive-block": {
        pattern: /^<\/?\w+/,
        inside: { punctuation: /^<\/?/ },
        alias: "tag"
      },
      "directive-block-parameter": {
        pattern: /.*[^>]/,
        inside: {
          punctuation: /:/,
          string: {
            pattern: /("|').*\1/,
            inside: { variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/ }
          }
        },
        alias: "attr-value"
      },
      punctuation: />/
    },
    alias: "tag"
  },
  "directive-flags": { pattern: /\[(?:[\w=],?)+\]/, alias: "keyword" },
  string: {
    pattern: /("|').*\1/,
    inside: { variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/ }
  },
  variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
  regex: /\^?.*\$|\^.*\$?/
}, Prism.languages.sql = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  variable: [
    { pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true },
    /@[\w.$]+/
  ],
  string: {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: { punctuation: /^`|`$/ }
  },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/
}, function(e2) {
  var t8 = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i, n2 = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
    /<keyword>/g,
    function() {
      return t8.source;
    }
  );
  function a(e22) {
    return RegExp(
      e22.replace(/<CLASS-NAME>/g, function() {
        return n2;
      }),
      "i"
    );
  }
  var r2 = { keyword: t8, punctuation: /[()\[\]{};,:.<>]/ };
  e2.languages.apex = {
    comment: e2.languages.clike.comment,
    string: e2.languages.clike.string,
    sql: {
      pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
      lookbehind: true,
      greedy: true,
      alias: "language-sql",
      inside: e2.languages.sql
    },
    annotation: { pattern: /@\w+\b/, alias: "punctuation" },
    "class-name": [
      {
        pattern: a(
          /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
        ),
        lookbehind: true,
        inside: r2
      },
      {
        pattern: a(/(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source),
        lookbehind: true,
        inside: r2
      },
      { pattern: a(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source), inside: r2 }
    ],
    trigger: {
      pattern: /(\btrigger\s+)\w+\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    keyword: t8,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    boolean: /\b(?:false|true)\b/i,
    number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
    operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
    punctuation: /[()\[\]{};,.]/
  };
}(Prism), Prism.languages.apl = {
  comment: /(?:⍝|#[! ]).*$/m,
  string: { pattern: /'(?:[^'\r\n]|'')*'/, greedy: true },
  number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
  statement: /:[A-Z][a-z][A-Za-z]*\b/,
  "system-function": { pattern: /⎕[A-Z]+/i, alias: "function" },
  constant: /[⍬⌾#⎕⍞]/,
  function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
  "monadic-operator": { pattern: /[\\\/⌿⍀¨⍨⌶&∥]/, alias: "operator" },
  "dyadic-operator": { pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/, alias: "operator" },
  assignment: { pattern: /←/, alias: "keyword" },
  punctuation: /[\[;\]()◇⋄]/,
  dfn: { pattern: /[{}⍺⍵⍶⍹∇⍫:]/, alias: "builtin" }
}, Prism.languages.applescript = {
  comment: [
    /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
    /--.+/,
    /#.+/
  ],
  string: /"(?:\\.|[^"\\\r\n])*"/,
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
  operator: [
    /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
    /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
  ],
  keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
  "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
  punctuation: /[{}():,¬«»《》]/
}, Prism.languages.aql = {
  comment: /\/\/.*|\/\*[\s\S]*?\*\//,
  property: {
    pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  string: { pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/, greedy: true },
  identifier: { pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/, greedy: true },
  variable: /@@?\w+/,
  keyword: [
    { pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i, lookbehind: true },
    /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
    { pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i, lookbehind: true },
    { pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/, lookbehind: true },
    { pattern: /\bOPTIONS(?=\s*\{)/i }
  ],
  function: /\b(?!\d)\w+(?=\s*\()/,
  boolean: /\b(?:false|true)\b/i,
  range: { pattern: /\.\./, alias: "operator" },
  number: [
    /\b0b[01]+/i,
    /\b0x[0-9a-f]+/i,
    /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
  ],
  operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
  punctuation: /::|[?.:,;()[\]{}]/
}, Prism.languages.c = Prism.languages.extend("clike", {
  comment: {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
}), Prism.languages.insertBefore("c", "string", {
  char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true }
}), Prism.languages.insertBefore("c", "string", {
  macro: {
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      string: [
        { pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true },
        Prism.languages.c.string
      ],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        { pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      directive: {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c }
    }
  }
}), Prism.languages.insertBefore("c", "function", {
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
}), delete Prism.languages.c.boolean, function(e2) {
  var t8 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n2 = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
    /<keyword>/g,
    function() {
      return t8.source;
    }
  );
  e2.languages.cpp = e2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(
          /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
            /<keyword>/g,
            function() {
              return t8.source;
            }
          )
        ),
        lookbehind: true
      },
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    keyword: t8,
    number: {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/
  }), e2.languages.insertBefore("cpp", "string", {
    module: {
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
          /<mod-name>/g,
          function() {
            return n2;
          }
        ) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  }), e2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        function: /^\w+/,
        generic: {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: e2.languages.cpp
        }
      }
    }
  }), e2.languages.insertBefore("cpp", "operator", {
    "double-colon": { pattern: /::/, alias: "punctuation" }
  }), e2.languages.insertBefore("cpp", "class-name", {
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: e2.languages.extend("cpp", {})
    }
  }), e2.languages.insertBefore(
    "inside",
    "double-colon",
    { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i },
    e2.languages.cpp["base-clause"]
  );
}(Prism), Prism.languages.arduino = Prism.languages.extend("cpp", {
  keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
  constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
  builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
}), Prism.languages.ino = Prism.languages.arduino, Prism.languages.arff = {
  comment: /%.*/,
  string: { pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  keyword: /@(?:attribute|data|end|relation)\b/i,
  number: /\b\d+(?:\.\d+)?\b/,
  punctuation: /[{},]/
}, Prism.languages.armasm = {
  comment: { pattern: /;.*/, greedy: true },
  string: {
    pattern: /"(?:[^"\r\n]|"")*"/,
    greedy: true,
    inside: {
      variable: { pattern: /((?:^|[^$])(?:\${2})*)\$\w+/, lookbehind: true }
    }
  },
  char: { pattern: /'(?:[^'\r\n]{0,4}|'')'/, greedy: true },
  "version-symbol": { pattern: /\|[\w@]+\|/, greedy: true, alias: "property" },
  boolean: /\b(?:FALSE|TRUE)\b/,
  directive: {
    pattern: /\b(?:ALIAS|ALIGN|AREA|ARM|ASSERT|ATTR|CN|CODE|CODE16|CODE32|COMMON|CP|DATA|DCB|DCD|DCDO|DCDU|DCFD|DCFDU|DCI|DCQ|DCQU|DCW|DCWU|DN|ELIF|ELSE|END|ENDFUNC|ENDIF|ENDP|ENTRY|EQU|EXPORT|EXPORTAS|EXTERN|FIELD|FILL|FN|FUNCTION|GBLA|GBLL|GBLS|GET|GLOBAL|IF|IMPORT|INCBIN|INCLUDE|INFO|KEEP|LCLA|LCLL|LCLS|LTORG|MACRO|MAP|MEND|MEXIT|NOFP|OPT|PRESERVE8|PROC|QN|READONLY|RELOC|REQUIRE|REQUIRE8|RLIST|ROUT|SETA|SETL|SETS|SN|SPACE|SUBT|THUMB|THUMBX|TTL|WEND|WHILE)\b/,
    alias: "property"
  },
  instruction: {
    pattern: /((?:^|(?:^|[^\\])(?:\r\n?|\n))[ \t]*(?:(?:[A-Z][A-Z0-9_]*[a-z]\w*|[a-z]\w*|\d+)[ \t]+)?)\b[A-Z.]+\b/,
    lookbehind: true,
    alias: "keyword"
  },
  variable: /\$\w+/,
  number: /(?:\b[2-9]_\d+|(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e-?\d+)?|\b0(?:[fd]_|x)[0-9a-f]+|&[0-9a-f]+)\b/i,
  register: { pattern: /\b(?:r\d|lr)\b/, alias: "symbol" },
  operator: /<>|<<|>>|&&|\|\||[=!<>/]=?|[+\-*%#?&|^]|:[A-Z]+:/,
  punctuation: /[()[\],]/
}, Prism.languages["arm-asm"] = Prism.languages.armasm, function(e2) {
  for (var t8 = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", n2 = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    inside: null
  }, a = {
    bash: n2,
    environment: { pattern: RegExp("\\$" + t8), alias: "constant" },
    variable: [
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          variable: [
            { pattern: /(^\$\(\([\s\S]+)\)\)/, lookbehind: true },
            /^\$\(\(/
          ],
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          punctuation: /\(\(?|\)\)?|,|;/
        }
      },
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: { variable: /^\$\(|^`|\)$|`$/ }
      },
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          punctuation: /[\[\]]/,
          environment: {
            pattern: RegExp("(\\{)" + t8),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  }, r2 = (e2.languages.bash = {
    shebang: { pattern: /^#!\s*\/.*/, alias: "important" },
    comment: { pattern: /(^|[^"{\\$])#.*/, lookbehind: true },
    "function-name": [
      {
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      { pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/, alias: "function" }
    ],
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        environment: {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t8),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    parameter: {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    string: [
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: a
      },
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: { bash: n2 }
      },
      {
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: a
      },
      { pattern: /(^|[^$\\])'[^']*'/, lookbehind: true, greedy: true },
      {
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: { entity: a.entity }
      }
    ],
    environment: { pattern: RegExp("\\$?" + t8), alias: "constant" },
    variable: a.variable,
    function: {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    keyword: {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    builtin: {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      alias: "class-name"
    },
    boolean: {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": { pattern: /\B&\d\b/, alias: "important" },
    operator: {
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": { pattern: /^\d/, alias: "important" }
      }
    },
    punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    number: {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  }, n2.inside = e2.languages.bash, [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ]), i = a.variable[1].inside, o2 = 0; o2 < r2.length; o2++)
    i[r2[o2]] = e2.languages.bash[r2[o2]];
  e2.languages.sh = e2.languages.bash, e2.languages.shell = e2.languages.bash;
}(Prism), function(e2) {
  var t8 = /[*&][^\s[\]{},]+/, n2 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a = "(?:" + n2.source + "(?:[ 	]+" + t8.source + ")?|" + t8.source + "(?:[ 	]+" + n2.source + ")?)", r2 = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
    /<PLAIN>/g,
    function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }
  ), i = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function o2(e22, t22) {
    t22 = (t22 || "").replace(/m/g, "") + "m";
    var n22 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return a;
    }).replace(/<<value>>/g, function() {
      return e22;
    });
    return RegExp(n22, t22);
  }
  e2.languages.yaml = {
    scalar: {
      pattern: RegExp(
        /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
          /<<prop>>/g,
          function() {
            return a;
          }
        )
      ),
      lookbehind: true,
      alias: "string"
    },
    comment: /#.*/,
    key: {
      pattern: RegExp(
        /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
          return a;
        }).replace(/<<key>>/g, function() {
          return "(?:" + r2 + "|" + i + ")";
        })
      ),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    directive: {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    datetime: {
      pattern: o2(
        /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
      ),
      lookbehind: true,
      alias: "number"
    },
    boolean: {
      pattern: o2(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    null: {
      pattern: o2(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    string: { pattern: o2(i), lookbehind: true, greedy: true },
    number: {
      pattern: o2(
        /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
        "i"
      ),
      lookbehind: true
    },
    tag: n2,
    important: t8,
    punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
  }, e2.languages.yml = e2.languages.yaml;
}(Prism), function(s2) {
  var t8 = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function e2(e22) {
    return e22 = e22.replace(/<inner>/g, function() {
      return t8;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e22 + ")");
  }
  var n2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
    /__/g,
    function() {
      return n2;
    }
  ), r2 = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l2 = (s2.languages.markdown = s2.languages.extend("markup", {}), s2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        punctuation: /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: s2.languages.yaml
        }
      }
    },
    blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" },
    table: {
      pattern: RegExp("^" + a + r2 + "(?:" + a + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + a + r2 + ")(?:" + a + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(n2),
              inside: s2.languages.markdown
            },
            punctuation: /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + a + ")" + r2 + "$"),
          lookbehind: true,
          inside: { punctuation: /\||:?-{3,}:?/ }
        },
        "table-header-row": {
          pattern: RegExp("^" + a + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(n2),
              alias: "important",
              inside: s2.languages.markdown
            },
            punctuation: /\|/
          }
        }
      }
    },
    code: [
      {
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": { pattern: /^(```).+/, lookbehind: true },
          punctuation: /```/
        }
      }
    ],
    title: [
      {
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: { punctuation: /==+$|--+$/ }
      },
      {
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: { punctuation: /^#+|#+$/ }
      }
    ],
    hr: {
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    list: {
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true },
        string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        punctuation: /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    bold: {
      pattern: e2(
        /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        content: {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
        },
        punctuation: /\*\*|__/
      }
    },
    italic: {
      pattern: e2(
        /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        content: {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
        },
        punctuation: /[*_]/
      }
    },
    strike: {
      pattern: e2(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        content: {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
        },
        punctuation: /~~?/
      }
    },
    "code-snippet": {
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    url: {
      pattern: e2(
        /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        operator: /^!/,
        content: {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
        },
        variable: {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true },
        string: {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  }), ["url", "bold", "italic", "strike"].forEach(function(t22) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(
      function(e22) {
        t22 !== e22 && (s2.languages.markdown[t22].inside.content.inside[e22] = s2.languages.markdown[e22]);
      }
    );
  }), s2.hooks.add("after-tokenize", function(e22) {
    "markdown" !== e22.language && "md" !== e22.language || !function e3(t22) {
      if (t22 && "string" != typeof t22)
        for (var n22 = 0, a2 = t22.length; n22 < a2; n22++) {
          var r22, i = t22[n22];
          "code" !== i.type ? e3(i.content) : (r22 = i.content[1], i = i.content[3], r22 && i && "code-language" === r22.type && "code-block" === i.type && "string" == typeof r22.content && (r22 = r22.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r22 = "language-" + (r22 = (/[a-z][\w-]*/i.exec(r22) || [
            ""
          ])[0].toLowerCase()), i.alias ? "string" == typeof i.alias ? i.alias = [i.alias, r22] : i.alias.push(r22) : i.alias = [r22]));
        }
    }(e22.tokens);
  }), s2.hooks.add("wrap", function(e22) {
    if ("code-block" === e22.type) {
      for (var t22 = "", n22 = 0, a2 = e22.classes.length; n22 < a2; n22++) {
        var r22 = e22.classes[n22], r22 = /language-(.+)/.exec(r22);
        if (r22) {
          t22 = r22[1];
          break;
        }
      }
      var i, o2 = s2.languages[t22];
      o2 ? e22.content = s2.highlight(
        function(e3) {
          e3 = e3.replace(l2, "");
          return e3 = e3.replace(
            /&(\w{1,8}|#x?[\da-f]{1,8});/gi,
            function(e4, t32) {
              var n3;
              return "#" === (t32 = t32.toLowerCase())[0] ? (n3 = "x" === t32[1] ? parseInt(t32.slice(2), 16) : Number(t32.slice(1)), c2(n3)) : d2[t32] || e4;
            }
          );
        }(e22.content),
        o2,
        t22
      ) : t22 && "none" !== t22 && s2.plugins.autoloader && (i = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e22.attributes.id = i, s2.plugins.autoloader.loadLanguages(t22, function() {
        var e3 = document.getElementById(i);
        e3 && (e3.innerHTML = s2.highlight(
          e3.textContent,
          s2.languages[t22],
          t22
        ));
      }));
    }
  }), RegExp(s2.languages.markup.tag.pattern.source, "gi")), d2 = { amp: "&", lt: "<", gt: ">", quot: '"' }, c2 = String.fromCodePoint || String.fromCharCode;
  s2.languages.md = s2.languages.markdown;
}(Prism), function(n2) {
  function e2(e22, t8) {
    return {
      pattern: RegExp(
        /\{!/.source + "(?:" + (t8 || e22) + ")" + /$[\s\S]*\}/.source,
        "m"
      ),
      greedy: true,
      inside: {
        embedded: {
          pattern: /(^\{!\w+\b)[\s\S]+(?=\}$)/,
          lookbehind: true,
          alias: "language-" + e22,
          inside: n2.languages[e22]
        },
        string: /[\s\S]+/
      }
    };
  }
  n2.languages.arturo = {
    comment: { pattern: /;.*/, greedy: true },
    character: { pattern: /`.`/, alias: "char", greedy: true },
    number: { pattern: /\b\d+(?:\.\d+(?:\.\d+(?:-[\w+-]+)?)?)?\b/ },
    string: { pattern: /"(?:[^"\\\r\n]|\\.)*"/, greedy: true },
    regex: { pattern: /\{\/.*?\/\}/, greedy: true },
    "html-string": e2("html"),
    "css-string": e2("css"),
    "js-string": e2("js"),
    "md-string": e2("md"),
    "sql-string": e2("sql"),
    "sh-string": e2("shell", "sh"),
    multistring: {
      pattern: /».*|\{:[\s\S]*?:\}|\{[\s\S]*?\}|^-{6}$[\s\S]*/m,
      alias: "string",
      greedy: true
    },
    label: { pattern: /\w+\b\??:/, alias: "property" },
    literal: { pattern: /'(?:\w+\b\??:?)/, alias: "constant" },
    type: { pattern: /:(?:\w+\b\??:?)/, alias: "class-name" },
    color: /#\w+/,
    predicate: {
      pattern: /\b(?:all|and|any|ascii|attr|attribute|attributeLabel|binary|block|char|contains|database|date|dictionary|empty|equal|even|every|exists|false|floating|function|greater|greaterOrEqual|if|in|inline|integer|is|key|label|leap|less|lessOrEqual|literal|logical|lower|nand|negative|nor|not|notEqual|null|numeric|odd|or|path|pathLabel|positive|prefix|prime|regex|same|set|some|sorted|standalone|string|subset|suffix|superset|symbol|symbolLiteral|true|try|type|unless|upper|when|whitespace|word|xnor|xor|zero)\?/,
      alias: "keyword"
    },
    "builtin-function": {
      pattern: /\b(?:abs|acos|acosh|acsec|acsech|actan|actanh|add|after|alert|alias|and|angle|append|arg|args|arity|array|as|asec|asech|asin|asinh|atan|atan2|atanh|attr|attrs|average|before|benchmark|blend|break|call|capitalize|case|ceil|chop|clear|clip|close|color|combine|conj|continue|copy|cos|cosh|crc|csec|csech|ctan|ctanh|cursor|darken|dec|decode|define|delete|desaturate|deviation|dialog|dictionary|difference|digest|digits|div|do|download|drop|dup|e|else|empty|encode|ensure|env|escape|execute|exit|exp|extend|extract|factors|fdiv|filter|first|flatten|floor|fold|from|function|gamma|gcd|get|goto|hash|hypot|if|inc|indent|index|infinity|info|input|insert|inspect|intersection|invert|jaro|join|keys|kurtosis|last|let|levenshtein|lighten|list|ln|log|loop|lower|mail|map|match|max|median|min|mod|module|mul|nand|neg|new|nor|normalize|not|now|null|open|or|outdent|pad|palette|panic|path|pause|permissions|permutate|pi|pop|popup|pow|powerset|powmod|prefix|print|prints|process|product|query|random|range|read|relative|remove|rename|render|repeat|replace|request|return|reverse|round|sample|saturate|script|sec|sech|select|serve|set|shl|shr|shuffle|sin|sinh|size|skewness|slice|sort|spin|split|sqrt|squeeze|stack|strip|sub|suffix|sum|switch|symbols|symlink|sys|take|tan|tanh|terminal|terminate|to|truncate|try|type|unclip|union|unique|unless|until|unzip|upper|values|var|variance|volume|webview|while|with|wordwrap|write|xnor|xor|zip)\b/,
      alias: "keyword"
    },
    sugar: { pattern: /->|=>|\||::/, alias: "operator" },
    punctuation: /[()[\],]/,
    symbol: {
      pattern: /<:|-:|ø|@|#|\+|\||\*|\$|---|-|%|\/|\.\.|\^|~|=|<|>|\\/
    },
    boolean: { pattern: /\b(?:false|maybe|true)\b/ }
  }, n2.languages.art = n2.languages.arturo;
}(Prism), function(e2) {
  var t8 = {
    pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
    lookbehind: true,
    inside: {
      quoted: {
        pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
        inside: { punctuation: /^[$`]|[$`]$/ }
      },
      interpreted: {
        pattern: /'(?:[^'\\]|\\.)*'/,
        inside: { punctuation: /^'|'$/ }
      },
      string: /"(?:[^"\\]|\\.)*"/,
      variable: /\w+(?==)/,
      punctuation: /^\[|\]$|,/,
      operator: /=/,
      "attr-value": /(?!^\s+$).+/
    }
  }, r2 = e2.languages.asciidoc = {
    "comment-block": {
      pattern: /^(\/{4,})$[\s\S]*?^\1/m,
      alias: "comment"
    },
    table: {
      pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
      inside: {
        specifiers: {
          pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
          alias: "attr-value"
        },
        punctuation: { pattern: /(^|[^\\])[|!]=*/, lookbehind: true }
      }
    },
    "passthrough-block": {
      pattern: /^(\+{4,})$[\s\S]*?^\1$/m,
      inside: { punctuation: /^\++|\++$/ }
    },
    "literal-block": {
      pattern: /^(-{4,}|\.{4,})$[\s\S]*?^\1$/m,
      inside: { punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/ }
    },
    "other-block": {
      pattern: /^(--|\*{4,}|_{4,}|={4,})$[\s\S]*?^\1$/m,
      inside: { punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/ }
    },
    "list-punctuation": {
      pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
      lookbehind: true,
      alias: "punctuation"
    },
    "list-label": {
      pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
      lookbehind: true,
      alias: "symbol"
    },
    "indented-block": {
      pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
      lookbehind: true
    },
    comment: /^\/\/.*/m,
    title: {
      pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
      alias: "important",
      inside: { punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/ }
    },
    "attribute-entry": {
      pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
      alias: "tag"
    },
    attributes: t8,
    hr: { pattern: /^'{3,}$/m, alias: "punctuation" },
    "page-break": { pattern: /^<{3,}$/m, alias: "punctuation" },
    admonition: {
      pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
      alias: "keyword"
    },
    callout: [
      { pattern: /(^[ \t]*)<?\d*>/m, lookbehind: true, alias: "symbol" },
      { pattern: /<\d+>/, alias: "symbol" }
    ],
    macro: {
      pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
      inside: {
        function: /^[a-z\d-]+(?=:)/,
        punctuation: /^::?/,
        attributes: {
          pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
          inside: t8.inside
        }
      }
    },
    inline: {
      pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
      lookbehind: true,
      inside: {
        attributes: t8,
        url: {
          pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
          inside: { punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/ }
        },
        "attribute-ref": {
          pattern: /^\{.+\}$/,
          inside: {
            variable: { pattern: /(^\{)[a-z\d,+_-]+/, lookbehind: true },
            operator: /^[=?!#%@$]|!(?=[:}])/,
            punctuation: /^\{|\}$|::?/
          }
        },
        italic: {
          pattern: /^(['_])[\s\S]+\1$/,
          inside: { punctuation: /^(?:''?|__?)|(?:''?|__?)$/ }
        },
        bold: {
          pattern: /^\*[\s\S]+\*$/,
          inside: { punctuation: /^\*\*?|\*\*?$/ }
        },
        punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
      }
    },
    replacement: { pattern: /\((?:C|R|TM)\)/, alias: "builtin" },
    entity: /&#?[\da-z]{1,8};/i,
    "line-continuation": {
      pattern: /(^| )\+$/m,
      lookbehind: true,
      alias: "punctuation"
    }
  };
  function n2(e22) {
    for (var t22 = {}, n22 = 0, a = (e22 = e22.split(" ")).length; n22 < a; n22++)
      t22[e22[n22]] = r2[e22[n22]];
    return t22;
  }
  t8.inside.interpreted.inside.rest = n2("macro inline replacement entity"), r2["passthrough-block"].inside.rest = n2("macro"), r2["literal-block"].inside.rest = n2("callout"), r2.table.inside.rest = n2(
    "comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"
  ), r2["other-block"].inside.rest = n2(
    "table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"
  ), r2.title.inside.rest = n2("macro inline replacement entity"), e2.hooks.add("wrap", function(e22) {
    "entity" === e22.type && (e22.attributes.title = e22.content.replace(/&amp;/, "&"));
  }), e2.languages.adoc = e2.languages.asciidoc;
}(Prism), function(n2) {
  function a(e22, n22) {
    return e22.replace(/<<(\d+)>>/g, function(e3, t22) {
      return "(?:" + n22[+t22] + ")";
    });
  }
  function r2(e22, t22, n22) {
    return RegExp(a(e22, t22), n22 || "");
  }
  function e2(e22, t22) {
    for (var n22 = 0; n22 < t22; n22++)
      e22 = e22.replace(/<<self>>/g, function() {
        return "(?:" + e22 + ")";
      });
    return e22.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var t8 = "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void", i = "class enum interface record struct", o2 = "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)", s2 = "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield";
  function l2(e22) {
    return "\\b(?:" + e22.trim().replace(/ /g, "|") + ")\\b";
  }
  var d2 = l2(i), c2 = RegExp(l2(t8 + " " + i + " " + o2 + " " + s2)), o2 = l2(i + " " + o2 + " " + s2), t8 = l2(t8 + " " + i + " " + s2), i = e2(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), s2 = e2(/\((?:[^()]|<<self>>)*\)/.source, 2), u = /@?\b[A-Za-z_]\w*\b/.source, p = a(/<<0>>(?:\s*<<1>>)?/.source, [u, i]), o2 = a(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [o2, p]), m = /\[\s*(?:,\s*)*\]/.source, g2 = a(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [o2, m]), b3 = a(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [i, s2, m]), b3 = a(/\(<<0>>+(?:,<<0>>+)+\)/.source, [b3]), b3 = a(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
    b3,
    o2,
    m
  ]), m = { keyword: c2, punctuation: /[<>()?,.:[\]]/ }, E2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, f = /"(?:\\.|[^\\"\r\n])*"/.source, g2 = (n2.languages.csharp = n2.languages.extend("clike", {
    string: [
      {
        pattern: r2(/(^|[^$\\])<<0>>/.source, [
          /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source
        ]),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: r2(/(^|[^@$\\])<<0>>/.source, [f]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        pattern: r2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [o2]),
        lookbehind: true,
        inside: m
      },
      {
        pattern: r2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
          u,
          b3
        ]),
        lookbehind: true,
        inside: m
      },
      {
        pattern: r2(/(\busing\s+)<<0>>(?=\s*=)/.source, [u]),
        lookbehind: true
      },
      {
        pattern: r2(/(\b<<0>>\s+)<<1>>/.source, [d2, p]),
        lookbehind: true,
        inside: m
      },
      {
        pattern: r2(/(\bcatch\s*\(\s*)<<0>>/.source, [o2]),
        lookbehind: true,
        inside: m
      },
      { pattern: r2(/(\bwhere\s+)<<0>>/.source, [u]), lookbehind: true },
      {
        pattern: r2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [g2]),
        lookbehind: true,
        inside: m
      },
      {
        pattern: r2(
          /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
          [b3, t8, u]
        ),
        inside: m
      }
    ],
    keyword: c2,
    number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    punctuation: /\?\.?|::|[{}[\];(),.:]/
  }), n2.languages.insertBefore("csharp", "number", {
    range: { pattern: /\.\./, alias: "operator" }
  }), n2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: r2(/([(,]\s*)<<0>>(?=\s*:)/.source, [u]),
      lookbehind: true,
      alias: "punctuation"
    }
  }), n2.languages.insertBefore("csharp", "class-name", {
    namespace: {
      pattern: r2(
        /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
        [u]
      ),
      lookbehind: true,
      inside: { punctuation: /\./ }
    },
    "type-expression": {
      pattern: r2(
        /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
        [s2]
      ),
      lookbehind: true,
      alias: "class-name",
      inside: m
    },
    "return-type": {
      pattern: r2(
        /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
        [b3, o2]
      ),
      inside: m,
      alias: "class-name"
    },
    "constructor-invocation": {
      pattern: r2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [b3]),
      lookbehind: true,
      inside: m,
      alias: "class-name"
    },
    "generic-method": {
      pattern: r2(/<<0>>\s*<<1>>(?=\s*\()/.source, [u, i]),
      inside: {
        function: r2(/^<<0>>/.source, [u]),
        generic: { pattern: RegExp(i), alias: "class-name", inside: m }
      }
    },
    "type-list": {
      pattern: r2(
        /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
        [d2, p, u, b3, c2.source, s2, /\bnew\s*\(\s*\)/.source]
      ),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: r2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [p, s2]),
          lookbehind: true,
          greedy: true,
          inside: n2.languages.csharp
        },
        keyword: c2,
        "class-name": { pattern: RegExp(b3), greedy: true, inside: m },
        punctuation: /[,()]/
      }
    },
    preprocessor: {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        directive: {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  }), f + "|" + E2), t8 = a(
    /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
    [g2]
  ), i = e2(a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [t8]), 2), d2 = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, u = a(/<<0>>(?:\s*\(<<1>>*\))?/.source, [o2, i]), h7 = (n2.languages.insertBefore("csharp", "class-name", {
    attribute: {
      pattern: r2(
        /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
        [d2, u]
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        target: {
          pattern: r2(/^<<0>>(?=\s*:)/.source, [d2]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: r2(/\(<<0>>*\)/.source, [i]),
          inside: n2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(o2),
          inside: { punctuation: /\./ }
        },
        punctuation: /[:,]/
      }
    }
  }), /:[^}\r\n]+/.source), p = e2(a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [t8]), 2), s2 = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [p, h7]), c2 = e2(
    a(
      /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
      [g2]
    ),
    2
  ), b3 = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [c2, h7]);
  function S3(e22, t22) {
    return {
      interpolation: {
        pattern: r2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [e22]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: r2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [t22, h7]),
            lookbehind: true,
            inside: { punctuation: /^:/ }
          },
          punctuation: /^\{|\}$/,
          expression: {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: n2.languages.csharp
          }
        }
      },
      string: /[\s\S]+/
    };
  }
  n2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [
      {
        pattern: r2(
          /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
          [s2]
        ),
        lookbehind: true,
        greedy: true,
        inside: S3(s2, p)
      },
      {
        pattern: r2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [b3]),
        lookbehind: true,
        greedy: true,
        inside: S3(b3, c2)
      }
    ],
    char: { pattern: RegExp(E2), greedy: true }
  }), n2.languages.dotnet = n2.languages.cs = n2.languages.csharp;
}(Prism), Prism.languages.aspnet = Prism.languages.extend("markup", {
  "page-directive": {
    pattern: /<%\s*@.*%>/,
    alias: "tag",
    inside: {
      "page-directive": {
        pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
        alias: "tag"
      },
      rest: Prism.languages.markup.tag.inside
    }
  },
  directive: {
    pattern: /<%.*%>/,
    alias: "tag",
    inside: {
      directive: { pattern: /<%\s*?[$=%#:]{0,2}|%>/, alias: "tag" },
      rest: Prism.languages.csharp
    }
  }
}), Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, Prism.languages.insertBefore(
  "inside",
  "punctuation",
  { directive: Prism.languages.aspnet.directive },
  Prism.languages.aspnet.tag.inside["attr-value"]
), Prism.languages.insertBefore("aspnet", "comment", {
  "asp-comment": { pattern: /<%--[\s\S]*?--%>/, alias: ["asp", "comment"] }
}), Prism.languages.insertBefore(
  "aspnet",
  Prism.languages.javascript ? "script" : "tag",
  {
    "asp-script": {
      pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
      lookbehind: true,
      alias: ["asp", "script"],
      inside: Prism.languages.csharp || {}
    }
  }
), Prism.languages.asm6502 = {
  comment: /;.*/,
  directive: { pattern: /\.\w+(?= )/, alias: "property" },
  string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
  "op-code": {
    pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
    alias: "keyword"
  },
  "hex-number": { pattern: /#?\$[\da-f]{1,4}\b/i, alias: "number" },
  "binary-number": { pattern: /#?%[01]+\b/, alias: "number" },
  "decimal-number": { pattern: /#?\b\d+\b/, alias: "number" },
  register: { pattern: /\b[xya]\b/i, alias: "variable" },
  punctuation: /[(),:]/
}, Prism.languages.asmatmel = {
  comment: { pattern: /;.*/, greedy: true },
  string: { pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
  directive: { pattern: /\.\w+(?= )/, alias: "property" },
  "r-register": { pattern: /\br(?:\d|[12]\d|3[01])\b/, alias: "variable" },
  "op-code": {
    pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
    alias: "keyword"
  },
  "hex-number": { pattern: /#?\$[\da-f]{2,4}\b/i, alias: "number" },
  "binary-number": { pattern: /#?%[01]+\b/, alias: "number" },
  "decimal-number": { pattern: /#?\b\d+\b/, alias: "number" },
  register: { pattern: /\b[acznvshtixy]\b/i, alias: "variable" },
  operator: />>=?|<<=?|&[&=]?|\|[\|=]?|[-+*/%^!=<>?]=?/,
  punctuation: /[(),:]/
}, Prism.languages.autohotkey = {
  comment: [
    { pattern: /(^|\s);.*/, lookbehind: true },
    {
      pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
      lookbehind: true,
      greedy: true
    }
  ],
  tag: { pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m, lookbehind: true },
  string: /"(?:[^"\n\r]|"")*"/,
  variable: /%\w+%/,
  number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
  operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
  boolean: /\b(?:false|true)\b/,
  command: {
    pattern: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
    alias: "selector"
  },
  constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
  builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
  symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
  directive: { pattern: /#[a-z]+\b/i, alias: "important" },
  keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
  function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
  punctuation: /[{}[\]():,]/
}, Prism.languages.autoit = {
  comment: [
    /;.*/,
    {
      pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
      lookbehind: true
    }
  ],
  url: {
    pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
    lookbehind: true
  },
  string: {
    pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
    greedy: true,
    inside: { variable: /([%$@])\w+\1/ }
  },
  directive: {
    pattern: /(^[\t ]*)#[\w-]+/m,
    lookbehind: true,
    alias: "keyword"
  },
  function: /\b\w+(?=\()/,
  variable: /[$@]\w+/,
  keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
  number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
  boolean: /\b(?:False|True)\b/i,
  operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
  punctuation: /[\[\]().,:]/
}, function(e2) {
  function t8(e22, t22, n22) {
    return RegExp(
      (a2 = t22, e22.replace(/<<(\d+)>>/g, function(e3, t32) {
        return a2[+t32];
      })),
      n22 || ""
    );
    var a2;
  }
  var n2 = /bool|clip|float|int|string|val/.source, a = [
    [
      /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
      /apply|assert|default|eval|import|nop|select|undefined/.source,
      /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
      /hex(?:value)?|value/.source,
      /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
      /a?sinh?|a?cosh?|a?tan[2h]?/.source,
      /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
      /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
      /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
      /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
      /isversionorgreater|version(?:number|string)/.source,
      /buildpixeltype|colorspacenametopixeltype/.source,
      /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
    ].join("|"),
    [
      /has(?:audio|video)/.source,
      /height|width/.source,
      /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
      /getparity|is(?:field|frame)based/.source,
      /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
      /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
    ].join("|"),
    [
      /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
      /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
      /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
      /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
      /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
      /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
      /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
      /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
      /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
      /imagewriter/.source,
      /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
    ].join("|")
  ].join("|");
  e2.languages.avisynth = {
    comment: [
      {
        pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      { pattern: /(^|[^\\$])#.*/, lookbehind: true, greedy: true }
    ],
    argument: {
      pattern: t8(/\b(?:<<0>>)\s+("?)\w+\1/.source, [n2], "i"),
      inside: { keyword: /^\w+/ }
    },
    "argument-label": {
      pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
      lookbehind: true,
      inside: {
        "argument-name": { pattern: /^\w+/, alias: "punctuation" },
        punctuation: /=$/
      }
    },
    string: [
      { pattern: /"""[\s\S]*?"""/, greedy: true },
      {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true,
        inside: {
          constant: {
            pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
          }
        }
      }
    ],
    variable: /\b(?:last)\b/i,
    boolean: /\b(?:false|no|true|yes)\b/i,
    keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
    constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
    "builtin-function": {
      pattern: t8(/\b(?:<<0>>)\b/.source, [a], "i"),
      alias: "function"
    },
    "type-cast": {
      pattern: t8(/\b(?:<<0>>)(?=\s*\()/.source, [n2], "i"),
      alias: "keyword"
    },
    function: {
      pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
      lookbehind: true
    },
    "line-continuation": {
      pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
    operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
    punctuation: /[{}\[\]();,.]/
  }, e2.languages.avs = e2.languages.avisynth;
}(Prism), Prism.languages["avro-idl"] = {
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
  string: {
    pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
    lookbehind: true,
    greedy: true
  },
  annotation: {
    pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
    greedy: true,
    alias: "function"
  },
  "function-identifier": {
    pattern: /`[^\r\n`]+`(?=\s*\()/,
    greedy: true,
    alias: "function"
  },
  identifier: { pattern: /`[^\r\n`]+`/, greedy: true },
  "class-name": {
    pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: [
    {
      pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
      lookbehind: true
    },
    /-?\b(?:Infinity|NaN)\b/
  ],
  operator: /=/,
  punctuation: /[()\[\]{}<>.:,;-]/
}, Prism.languages.avdl = Prism.languages["avro-idl"], Prism.languages.awk = {
  hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" },
  comment: { pattern: /#.*/, greedy: true },
  string: {
    pattern: /(^|[^\\])"(?:[^\\"\r\n]|\\.)*"/,
    lookbehind: true,
    greedy: true
  },
  regex: {
    pattern: /((?:^|[^\w\s)])\s*)\/(?:[^\/\\\r\n]|\\.)*\//,
    lookbehind: true,
    greedy: true
  },
  variable: /\$\w+/,
  keyword: /\b(?:BEGIN|BEGINFILE|END|ENDFILE|break|case|continue|default|delete|do|else|exit|for|function|getline|if|in|next|nextfile|printf?|return|switch|while)\b|@(?:include|load)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[a-fA-F0-9]+)\b/,
  operator: /--|\+\+|!?~|>&|>>|<<|(?:\*\*|[<>!=+\-*/%^])=?|&&|\|[|&]|[?:]/,
  punctuation: /[()[\]{},;]/
}, Prism.languages.gawk = Prism.languages.awk, Prism.languages.basic = {
  comment: { pattern: /(?:!|REM\b).+/i, inside: { keyword: /^REM/i } },
  string: { pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/, greedy: true },
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
  function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
  operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
  punctuation: /[,;:()]/
}, function() {
  var e2 = /%%?[~:\w]+%?|!\S+!/, t8 = {
    pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
    alias: "attr-name",
    inside: { punctuation: /:/ }
  }, n2 = /"(?:[\\"]"|[^"])*"(?!")/, a = /(?:\b|-)\d+\b/;
  Prism.languages.batch = {
    comment: [
      /^::.*/m,
      {
        pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
        lookbehind: true
      }
    ],
    label: { pattern: /^:.*/m, alias: "property" },
    command: [
      {
        pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
        lookbehind: true,
        inside: {
          keyword: /\b(?:do|in)\b|^for\b/i,
          string: n2,
          parameter: t8,
          variable: e2,
          number: a,
          punctuation: /[()',]/
        }
      },
      {
        pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
        lookbehind: true,
        inside: {
          keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
          string: n2,
          parameter: t8,
          variable: e2,
          number: a,
          operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
        }
      },
      {
        pattern: /((?:^|[&()])[ \t]*)else\b/im,
        lookbehind: true,
        inside: { keyword: /^else\b/i }
      },
      {
        pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        inside: {
          keyword: /^set\b/i,
          string: n2,
          parameter: t8,
          variable: [e2, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
          number: a,
          operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
          punctuation: /[()',]/
        }
      },
      {
        pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
        lookbehind: true,
        inside: {
          keyword: /^\w+\b/,
          string: n2,
          parameter: t8,
          label: {
            pattern: /(^\s*):\S+/m,
            lookbehind: true,
            alias: "property"
          },
          variable: e2,
          number: a,
          operator: /\^/
        }
      }
    ],
    operator: /[&@]/,
    punctuation: /[()']/
  };
}(), Prism.languages.bbcode = {
  tag: {
    pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
    inside: {
      tag: { pattern: /^\[\/?[^\s=\]]+/, inside: { punctuation: /^\[\/?/ } },
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
        inside: {
          punctuation: [
            /^=/,
            { pattern: /^(\s*)["']|["']$/, lookbehind: true }
          ]
        }
      },
      punctuation: /\]/,
      "attr-name": /[^\s=\]]+/
    }
  }
}, Prism.languages.shortcode = Prism.languages.bbcode, Prism.languages.bbj = {
  comment: { pattern: /(^|[^\\:])rem\s+.*/i, lookbehind: true, greedy: true },
  string: { pattern: /(['"])(?:(?!\1|\\).|\\.)*\1/, greedy: true },
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  keyword: /\b(?:abstract|all|argc|begin|bye|callback|case|chn|class|classend|ctl|day|declare|delete|dim|dom|dread|dsz|else|end|endif|err|exitto|extends|fi|field|for|from|gosub|goto|if|implements|interface|interfaceend|iol|iolist|let|list|load|method|methodend|methodret|on|opts|pfx|print|private|process_events|protected|psz|public|read|read_resource|release|remove_callback|repeat|restore|return|rev|seterr|setesc|sqlchn|sqlunt|ssn|start|static|swend|switch|sys|then|tim|unt|until|use|void|wend|where|while)\b/i,
  function: /\b\w+(?=\()/,
  boolean: /\b(?:BBjAPI\.TRUE|BBjAPI\.FALSE)\b/i,
  operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:and|not|or|xor)\b/i,
  punctuation: /[.,;:()]/
}, Prism.languages.bicep = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  property: [
    { pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i, lookbehind: true },
    {
      pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
      lookbehind: true,
      greedy: true
    }
  ],
  string: [
    { pattern: /'''[^'][\s\S]*?'''/, greedy: true },
    {
      pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
      lookbehind: true,
      greedy: true
    }
  ],
  "interpolated-string": {
    pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
    lookbehind: true,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /\$\{[^{}\r\n]*\}/,
        inside: {
          expression: { pattern: /(^\$\{)[\s\S]+(?=\}$)/, lookbehind: true },
          punctuation: /^\$\{|\}$/
        }
      },
      string: /[\s\S]+/
    }
  },
  datatype: {
    pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
    lookbehind: true,
    alias: "class-name"
  },
  boolean: /\b(?:false|true)\b/,
  keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
  decorator: /@\w+\b/,
  function: /\b[a-z_]\w*(?=[ \t]*\()/i,
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.bicep["interpolated-string"].inside.interpolation.inside.expression.inside = Prism.languages.bicep, Prism.languages.birb = Prism.languages.extend("clike", {
  string: { pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/, greedy: true },
  "class-name": [
    /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
    /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
  ],
  keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
  operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
  variable: /\b[a-z_]\w*\b/
}), Prism.languages.insertBefore("birb", "function", {
  metadata: { pattern: /<\w+>/, greedy: true, alias: "symbol" }
}), Prism.languages.bison = Prism.languages.extend("c", {}), Prism.languages.insertBefore("bison", "comment", {
  bison: {
    pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
    inside: {
      c: {
        pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
        inside: {
          delimiter: { pattern: /^%?\{|%?\}$/, alias: "punctuation" },
          "bison-variable": {
            pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
            alias: "variable",
            inside: { punctuation: /<|>/ }
          },
          rest: Prism.languages.c
        }
      },
      comment: Prism.languages.c.comment,
      string: Prism.languages.c.string,
      property: /\S+(?=:)/,
      keyword: /%\w+/,
      number: { pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i, lookbehind: true },
      punctuation: /%[%?]|[|:;\[\]<>]/
    }
  }
}), Prism.languages.bnf = {
  string: { pattern: /"[^\r\n"]*"|'[^\r\n']*'/ },
  definition: {
    pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
    alias: ["rule", "keyword"],
    inside: { punctuation: /^<|>$/ }
  },
  rule: { pattern: /<[^<>\r\n\t]+>/, inside: { punctuation: /^<|>$/ } },
  operator: /::=|[|()[\]{}*+?]|\.{3}/
}, Prism.languages.rbnf = Prism.languages.bnf, Prism.languages.bqn = {
  shebang: { pattern: /^#![ \t]*\/.*/, alias: "important", greedy: true },
  comment: { pattern: /#.*/, greedy: true },
  "string-literal": {
    pattern: /"(?:[^"]|"")*"/,
    greedy: true,
    alias: "string"
  },
  "character-literal": {
    pattern: /'(?:[\s\S]|[\uD800-\uDBFF][\uDC00-\uDFFF])'/,
    greedy: true,
    alias: "char"
  },
  function: /•[\w¯.∞π]+[\w¯.∞π]*/,
  "dot-notation-on-brackets": {
    pattern: /\{(?=.*\}\.)|\}\./,
    alias: "namespace"
  },
  "special-name": {
    pattern: /(?:𝕨|𝕩|𝕗|𝕘|𝕤|𝕣|𝕎|𝕏|𝔽|𝔾|𝕊|_𝕣_|_𝕣)/,
    alias: "keyword"
  },
  "dot-notation-on-name": {
    pattern: /[A-Za-z_][\w¯∞π]*\./,
    alias: "namespace"
  },
  "word-number-scientific": {
    pattern: /\d+(?:\.\d+)?[eE]¯?\d+/,
    alias: "number"
  },
  "word-name": { pattern: /[A-Za-z_][\w¯∞π]*/, alias: "symbol" },
  "word-number": {
    pattern: /[¯∞π]?(?:\d*\.?\b\d+(?:e[+¯]?\d+|E[+¯]?\d+)?|¯|∞|π)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+|E[+¯]?\d+)?|¯|∞|π))?/,
    alias: "number"
  },
  "null-literal": { pattern: /@/, alias: "char" },
  "primitive-functions": {
    pattern: /[-+×÷⋆√⌊⌈|¬∧∨<>≠=≤≥≡≢⊣⊢⥊∾≍⋈↑↓↕«»⌽⍉/⍋⍒⊏⊑⊐⊒∊⍷⊔!]/,
    alias: "operator"
  },
  "primitive-1-operators": { pattern: /[`˜˘¨⁼⌜´˝˙]/, alias: "operator" },
  "primitive-2-operators": { pattern: /[∘⊸⟜○⌾⎉⚇⍟⊘◶⎊]/, alias: "operator" },
  punctuation: /[←⇐↩(){}⟨⟩[\]‿·⋄,.;:?]/
}, Prism.languages.brainfuck = {
  pointer: { pattern: /<|>/, alias: "keyword" },
  increment: { pattern: /\+/, alias: "inserted" },
  decrement: { pattern: /-/, alias: "deleted" },
  branching: { pattern: /\[|\]/, alias: "important" },
  operator: /[.,]/,
  comment: /\S+/
}, Prism.languages.brightscript = {
  comment: /(?:\brem|').*/i,
  "directive-statement": {
    pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
    lookbehind: true,
    alias: "property",
    inside: {
      "error-message": { pattern: /(^#error).+/, lookbehind: true },
      directive: {
        pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
        alias: "keyword"
      },
      expression: { pattern: /[\s\S]+/, inside: null }
    }
  },
  property: {
    pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
    lookbehind: true,
    greedy: true
  },
  string: { pattern: /"(?:[^"\r\n]|"")*"(?!")/, greedy: true },
  "class-name": { pattern: /(\bAs[\t ]+)\w+/i, lookbehind: true },
  keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
  boolean: /\b(?:false|true)\b/i,
  function: /\b(?!\d)\w+(?=[\t ]*\()/,
  number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
  operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
  punctuation: /[.,;()[\]{}]/,
  constant: /\b(?:LINE_NUM)\b/i
}, Prism.languages.brightscript["directive-statement"].inside.expression.inside = Prism.languages.brightscript, Prism.languages.bro = {
  comment: {
    pattern: /(^|[^\\$])#.*/,
    lookbehind: true,
    inside: { italic: /\b(?:FIXME|TODO|XXX)\b/ }
  },
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  boolean: /\b[TF]\b/,
  function: {
    pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
    lookbehind: true
  },
  builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
  constant: { pattern: /(\bconst[ \t]+)\w+/i, lookbehind: true },
  keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
  operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.bsl = {
  comment: /\/\/.*/,
  string: [
    { pattern: /"(?:[^"]|"")*"(?!")/, greedy: true },
    { pattern: /'(?:[^'\r\n\\]|\\.)*'/ }
  ],
  keyword: [
    {
      pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
      lookbehind: true
    },
    {
      pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
    }
  ],
  number: {
    pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
    lookbehind: true
  },
  operator: [
    /[<>+\-*/]=?|[%=]/,
    {
      pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
      lookbehind: true
    },
    { pattern: /\b(?:and|not|or)\b/i }
  ],
  punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
  directive: [
    {
      pattern: /^([ \t]*)&.*/m,
      lookbehind: true,
      greedy: true,
      alias: "important"
    },
    {
      pattern: /^([ \t]*)#.*/gm,
      lookbehind: true,
      greedy: true,
      alias: "important"
    }
  ]
}, Prism.languages.oscript = Prism.languages.bsl, Prism.languages.cfscript = Prism.languages.extend("clike", {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      inside: {
        annotation: { pattern: /(?:^|[^.])@[\w\.]+/, alias: "punctuation" }
      }
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
  operator: [
    /\+\+|--|&&|\|\||::|=>|[!=]==|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|:/,
    /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
  ],
  scope: {
    pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
    alias: "global"
  },
  type: {
    pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
    alias: "builtin"
  }
}), Prism.languages.insertBefore("cfscript", "keyword", {
  "function-variable": {
    pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  }
}), delete Prism.languages.cfscript["class-name"], Prism.languages.cfc = Prism.languages.cfscript, Prism.languages.chaiscript = Prism.languages.extend("clike", {
  string: {
    pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
    lookbehind: true,
    greedy: true
  },
  "class-name": [
    { pattern: /(\bclass\s+)\w+/, lookbehind: true },
    { pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/, lookbehind: true }
  ],
  keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
  number: [Prism.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
  operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
}), Prism.languages.insertBefore("chaiscript", "operator", {
  "parameter-type": {
    pattern: /([,(]\s*)\w+(?=\s+\w)/,
    lookbehind: true,
    alias: "class-name"
  }
}), Prism.languages.insertBefore("chaiscript", "string", {
  "string-interpolation": {
    pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
    lookbehind: true,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
        lookbehind: true,
        inside: {
          "interpolation-expression": {
            pattern: /(^\$\{)[\s\S]+(?=\}$)/,
            lookbehind: true,
            inside: Prism.languages.chaiscript
          },
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          }
        }
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.cil = {
  comment: /\/\/.*/,
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  directive: {
    pattern: /(^|\W)\.[a-z]+(?=\s)/,
    lookbehind: true,
    alias: "class-name"
  },
  variable: /\[[\w\.]+\]/,
  keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
  function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
  boolean: /\b(?:false|true)\b/,
  number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
  punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
}, Prism.languages.cilkc = Prism.languages.insertBefore("c", "function", {
  "parallel-keyword": {
    pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
    alias: "keyword"
  }
}), Prism.languages["cilk-c"] = Prism.languages.cilkc, Prism.languages.cilkcpp = Prism.languages.insertBefore("cpp", "function", {
  "parallel-keyword": {
    pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
    alias: "keyword"
  }
}), Prism.languages["cilk-cpp"] = Prism.languages.cilkcpp, Prism.languages.cilk = Prism.languages.cilkcpp, Prism.languages.clojure = {
  comment: { pattern: /;.*/, greedy: true },
  string: { pattern: /"(?:[^"\\]|\\.)*"/, greedy: true },
  char: /\\\w+/,
  symbol: { pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/, lookbehind: true },
  keyword: {
    pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
    lookbehind: true
  },
  boolean: /\b(?:false|nil|true)\b/,
  number: {
    pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
    lookbehind: true
  },
  function: {
    pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
    lookbehind: true
  },
  operator: /[#@^`~]/,
  punctuation: /[{}\[\](),]/
}, Prism.languages.cmake = {
  comment: /#.*/,
  string: {
    pattern: /"(?:[^\\"]|\\.)*"/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
        inside: { punctuation: /\$\{|\}/, variable: /\w+/ }
      }
    }
  },
  variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
  property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
  keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
  boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
  namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
  operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
  inserted: { pattern: /\b\w+::\w+\b/, alias: "class-name" },
  number: /\b\d+(?:\.\d+)*\b/,
  function: /\b[a-z_]\w*(?=\s*\()\b/i,
  punctuation: /[()>}]|\$[<{]/
}, Prism.languages.cobol = {
  comment: { pattern: /\*>.*|(^[ \t]*)\*.*/m, lookbehind: true, greedy: true },
  string: {
    pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
    greedy: true
  },
  level: {
    pattern: /(^[ \t]*)\d+\b/m,
    lookbehind: true,
    greedy: true,
    alias: "number"
  },
  "class-name": {
    pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
    lookbehind: true,
    inside: {
      number: { pattern: /(\()\d+/, lookbehind: true },
      punctuation: /[()]/
    }
  },
  keyword: {
    pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
    lookbehind: true
  },
  boolean: { pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i, lookbehind: true },
  number: {
    pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
    lookbehind: true
  },
  operator: [
    /<>|[<>]=?|[=+*/&]/,
    {
      pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
      lookbehind: true
    }
  ],
  punctuation: /[.:,()]/
}, function(e2) {
  var t8 = /#(?!\{).+/, n2 = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e2.languages.coffeescript = e2.languages.extend("javascript", {
    comment: t8,
    string: [
      { pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        greedy: true,
        inside: { interpolation: n2 }
      }
    ],
    keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
    "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" }
  }), e2.languages.insertBefore("coffeescript", "comment", {
    "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" },
    "block-regex": {
      pattern: /\/{3}[\s\S]*?\/{3}/,
      alias: "regex",
      inside: { comment: t8, interpolation: n2 }
    }
  }), e2.languages.insertBefore("coffeescript", "string", {
    "inline-javascript": {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      inside: {
        delimiter: { pattern: /^`|`$/, alias: "punctuation" },
        script: {
          pattern: /[\s\S]+/,
          alias: "language-javascript",
          inside: e2.languages.javascript
        }
      }
    },
    "multiline-string": [
      { pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" },
      {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string",
        inside: { interpolation: n2 }
      }
    ]
  }), e2.languages.insertBefore("coffeescript", "keyword", {
    property: /(?!\d)\w+(?=\s*:(?!:))/
  }), delete e2.languages.coffeescript["template-string"], e2.languages.coffee = e2.languages.coffeescript;
}(Prism), Prism.languages.concurnas = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
    lookbehind: true,
    greedy: true
  },
  langext: {
    pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
    greedy: true,
    inside: {
      "class-name": /^\w+/,
      string: { pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/, lookbehind: true },
      punctuation: /\|\|/
    }
  },
  function: {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
    lookbehind: true
  },
  keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
  boolean: /\b(?:false|true)\b/,
  number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
  punctuation: /[{}[\];(),.:]/,
  operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
  annotation: { pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/, alias: "builtin" }
}, Prism.languages.insertBefore("concurnas", "langext", {
  "regex-literal": {
    pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: Prism.languages.concurnas
      },
      regex: /[\s\S]+/
    }
  },
  "string-literal": {
    pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: Prism.languages.concurnas
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.conc = Prism.languages.concurnas, function() {
  function e2(e22) {
    return RegExp(
      /([ \t])/.source + "(?:" + e22 + ")" + /(?=[\s;]|$)/.source,
      "i"
    );
  }
  Prism.languages.csp = {
    directive: {
      pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
      lookbehind: true,
      alias: "property"
    },
    scheme: { pattern: e2(/[a-z][a-z0-9.+-]*:/.source), lookbehind: true },
    none: { pattern: e2(/'none'/.source), lookbehind: true, alias: "keyword" },
    nonce: {
      pattern: e2(/'nonce-[-+/\w=]+'/.source),
      lookbehind: true,
      alias: "number"
    },
    hash: {
      pattern: e2(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
      lookbehind: true,
      alias: "number"
    },
    host: {
      pattern: e2(
        /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
      ),
      lookbehind: true,
      alias: "url",
      inside: { important: /\*/ }
    },
    keyword: [
      {
        pattern: e2(/'unsafe-[a-z-]+'/.source),
        lookbehind: true,
        alias: "unsafe"
      },
      { pattern: e2(/'[a-z-]+'/.source), lookbehind: true, alias: "safe" }
    ],
    punctuation: /;/
  };
}(), function(e2) {
  var t8 = /(?:(?!\s)[\d$+<=a-zA-Z\x80-\uFFFF])+/.source, n2 = /[^{}@#]+/.source, a = n2 + /\{[^}#@]*\}/.source, r2 = /(?:h|hours|hrs|m|min|minutes)/.source;
  e2.languages.cooklang = {
    comment: { pattern: /\[-[\s\S]*?-\]|--.*/, greedy: true },
    meta: {
      pattern: />>.*:.*/,
      inside: {
        property: {
          pattern: /(>>\s*)[^\s:](?:[^:]*[^\s:])?/,
          lookbehind: true
        }
      }
    },
    "cookware-group": {
      pattern: new RegExp("#(?:" + a + "|" + t8 + ")"),
      inside: {
        cookware: {
          pattern: new RegExp("(^#)(?:" + n2 + ")"),
          lookbehind: true,
          alias: "variable"
        },
        "cookware-keyword": { pattern: /^#/, alias: "keyword" },
        "quantity-group": {
          pattern: new RegExp(/\{[^{}@#]*\}/),
          inside: {
            quantity: {
              pattern: new RegExp(/(^\{)/.source + n2),
              lookbehind: true,
              alias: "number"
            },
            punctuation: /[{}]/
          }
        }
      }
    },
    "ingredient-group": {
      pattern: new RegExp("@(?:" + a + "|" + t8 + ")"),
      inside: {
        ingredient: {
          pattern: new RegExp("(^@)(?:" + n2 + ")"),
          lookbehind: true,
          alias: "variable"
        },
        "ingredient-keyword": { pattern: /^@/, alias: "keyword" },
        "amount-group": {
          pattern: /\{[^{}]*\}/,
          inside: {
            amount: {
              pattern: /([\{|])[^{}|*%]+/,
              lookbehind: true,
              alias: "number"
            },
            unit: { pattern: /(%)[^}]+/, lookbehind: true, alias: "symbol" },
            "servings-scaler": { pattern: /\*/, alias: "operator" },
            "servings-alternative-separator": {
              pattern: /\|/,
              alias: "operator"
            },
            "unit-separator": {
              pattern: /(?:%|(\*)%)/,
              lookbehind: true,
              alias: "operator"
            },
            punctuation: /[{}]/
          }
        }
      }
    },
    "timer-group": {
      pattern: /~(?!\s)[^@#~{}]*\{[^{}]*\}/,
      inside: {
        timer: { pattern: /(^~)[^{]+/, lookbehind: true, alias: "variable" },
        "duration-group": {
          pattern: /\{[^{}]*\}/,
          inside: {
            punctuation: /[{}]/,
            unit: {
              pattern: new RegExp(/(%\s*)/.source + r2 + /\b/.source),
              lookbehind: true,
              alias: "symbol"
            },
            operator: /%/,
            duration: { pattern: /\d+/, alias: "number" }
          }
        },
        "timer-keyword": { pattern: /^~/, alias: "keyword" }
      }
    }
  };
}(Prism), function(e2) {
  for (var t8 = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source, n2 = 0; n2 < 2; n2++)
    t8 = t8.replace(/<self>/g, function() {
      return t8;
    });
  t8 = t8.replace(/<self>/g, "[]"), e2.languages.coq = {
    comment: RegExp(t8),
    string: { pattern: /"(?:[^"]|"")*"(?!")/, greedy: true },
    attribute: [
      {
        pattern: RegExp(
          /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
            /<comment>/g,
            function() {
              return t8;
            }
          )
        ),
        greedy: true,
        alias: "attr-name",
        inside: {
          comment: RegExp(t8),
          string: { pattern: /"(?:[^"]|"")*"(?!")/, greedy: true },
          operator: /=/,
          punctuation: /^#\[|\]$|[,()]/
        }
      },
      {
        pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
        alias: "attr-name"
      }
    ],
    keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
    number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
    punct: { pattern: /@\{|\{\||\[=|:>/, alias: "punctuation" },
    operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
    punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
  };
}(Prism), function(e2) {
  e2.languages.ruby = e2.languages.extend("clike", {
    comment: { pattern: /#.*|^=begin\s[\s\S]*?^=end/m, greedy: true },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: { punctuation: /[.\\]/ }
    },
    keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    punctuation: /[(){}[\].,;]/
  }), e2.languages.insertBefore("ruby", "operator", {
    "double-colon": { pattern: /::/, alias: "punctuation" }
  });
  var t8 = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      content: {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: e2.languages.ruby
      },
      delimiter: { pattern: /^#\{|\}$/, alias: "punctuation" }
    }
  }, n2 = (delete e2.languages.ruby.function, "(?:" + [
    /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
    /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
    /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
    /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
    /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
  ].join("|") + ")"), a = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  e2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [
      {
        pattern: RegExp(/%r/.source + n2 + /[egimnosux]{0,6}/.source),
        greedy: true,
        inside: { interpolation: t8, regex: /[\s\S]+/ }
      },
      {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
        lookbehind: true,
        greedy: true,
        inside: { interpolation: t8, regex: /[\s\S]+/ }
      }
    ],
    variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    symbol: [
      { pattern: RegExp(/(^|[^:]):/.source + a), lookbehind: true, greedy: true },
      {
        pattern: RegExp(/([\r\n{(,][ \t]*)/.source + a + /(?=:(?!:))/.source),
        lookbehind: true,
        greedy: true
      }
    ],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        function: /\b\w+$/,
        keyword: /^self\b/,
        "class-name": /^\w+/,
        punctuation: /\./
      }
    }
  }), e2.languages.insertBefore("ruby", "string", {
    "string-literal": [
      {
        pattern: RegExp(/%[qQiIwWs]?/.source + n2),
        greedy: true,
        inside: { interpolation: t8, string: /[\s\S]+/ }
      },
      {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: true,
        inside: { interpolation: t8, string: /[\s\S]+/ }
      },
      {
        pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          delimiter: {
            pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
            inside: { symbol: /\b\w+/, punctuation: /^<<[-~]?/ }
          },
          interpolation: t8,
          string: /[\s\S]+/
        }
      },
      {
        pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          delimiter: {
            pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
            inside: { symbol: /\b\w+/, punctuation: /^<<[-~]?'|'$/ }
          },
          string: /[\s\S]+/
        }
      }
    ],
    "command-literal": [
      {
        pattern: RegExp(/%x/.source + n2),
        greedy: true,
        inside: {
          interpolation: t8,
          command: { pattern: /[\s\S]+/, alias: "string" }
        }
      },
      {
        pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
        greedy: true,
        inside: {
          interpolation: t8,
          command: { pattern: /[\s\S]+/, alias: "string" }
        }
      }
    ]
  }), delete e2.languages.ruby.string, e2.languages.insertBefore("ruby", "number", {
    builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  }), e2.languages.rb = e2.languages.ruby;
}(Prism), function(e2) {
  e2.languages.crystal = e2.languages.extend("ruby", {
    keyword: [
      /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
      { pattern: /(\.\s*)(?:is_a|responds_to)\?/, lookbehind: true }
    ],
    number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
    operator: [/->/, e2.languages.ruby.operator],
    punctuation: /[(){}[\].,;\\]/
  }), e2.languages.insertBefore("crystal", "string-literal", {
    attribute: {
      pattern: /@\[.*?\]/,
      inside: {
        delimiter: { pattern: /^@\[|\]$/, alias: "punctuation" },
        attribute: {
          pattern: /^(\s*)\w+/,
          lookbehind: true,
          alias: "class-name"
        },
        args: { pattern: /\S(?:[\s\S]*\S)?/, inside: e2.languages.crystal }
      }
    },
    expansion: {
      pattern: /\{(?:\{.*?\}|%.*?%)\}/,
      inside: {
        content: {
          pattern: /^(\{.)[\s\S]+(?=.\}$)/,
          lookbehind: true,
          inside: e2.languages.crystal
        },
        delimiter: { pattern: /^\{[\{%]|[\}%]\}$/, alias: "operator" }
      }
    },
    char: {
      pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
      greedy: true
    }
  });
}(Prism), function(e2) {
  var t8 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, t8 = (e2.languages.css.selector = {
    pattern: e2.languages.css.selector.pattern,
    lookbehind: true,
    inside: t8 = {
      "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
      "pseudo-class": /:[-\w]+/,
      class: /\.[-\w]+/,
      id: /#[-\w]+/,
      attribute: {
        pattern: RegExp(`\\[(?:[^[\\]"']|` + t8.source + ")*\\]"),
        greedy: true,
        inside: {
          punctuation: /^\[|\]$/,
          "case-sensitivity": {
            pattern: /(\s)[si]$/i,
            lookbehind: true,
            alias: "keyword"
          },
          namespace: {
            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
            lookbehind: true,
            inside: { punctuation: /\|$/ }
          },
          "attr-name": {
            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
            lookbehind: true
          },
          "attr-value": [
            t8,
            {
              pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
              lookbehind: true
            }
          ],
          operator: /[|~*^$]?=/
        }
      },
      "n-th": [
        {
          pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
          lookbehind: true,
          inside: { number: /[\dn]+/, operator: /[+-]/ }
        },
        { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }
      ],
      combinator: />|\+|~|\|\|/,
      punctuation: /[(),]/
    }
  }, e2.languages.css.atrule.inside["selector-function-argument"].inside = t8, e2.languages.insertBefore("css", "property", {
    variable: {
      pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
      lookbehind: true
    }
  }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), n2 = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e2.languages.insertBefore("css", "function", {
    operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true },
    hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" },
    color: [
      {
        pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
        lookbehind: true
      },
      {
        pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
        inside: {
          unit: t8,
          number: n2,
          function: /[\w-]+(?=\()/,
          punctuation: /[(),]/
        }
      }
    ],
    entity: /\\[\da-f]{1,8}/i,
    unit: t8,
    number: n2
  });
}(Prism), Prism.languages.csv = {
  value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
  punctuation: /,/
}, function(e2) {
  var t8 = "(?:" + (/"""(?:[^\\"]|"(?!""\2)|<esc>)*"""/.source + "|" + /'''(?:[^\\']|'(?!''\2)|<esc>)*'''/.source + "|" + /"(?:[^\\\r\n"]|"(?!\2)|<esc>)*"/.source + "|" + /'(?:[^\\\r\n']|'(?!\2)|<esc>)*'/.source).replace(/<esc>/g, /\\(?:(?!\2)|\2(?:[^()\r\n]|\([^()]*\)))/.source) + ")";
  e2.languages.cue = {
    comment: { pattern: /\/\/.*/, greedy: true },
    "string-literal": {
      pattern: RegExp(/(^|[^#"'\\])(#*)/.source + t8 + /(?!["'])\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        escape: {
          pattern: /(?=[\s\S]*["'](#*)$)\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\d{2,3}|[^(])/,
          greedy: true,
          alias: "string"
        },
        interpolation: {
          pattern: /(?=[\s\S]*["'](#*)$)\\\1\([^()]*\)/,
          greedy: true,
          inside: {
            punctuation: /^\\#*\(|\)$/,
            expression: { pattern: /[\s\S]+/, inside: null }
          }
        },
        string: /[\s\S]+/
      }
    },
    keyword: {
      pattern: /(^|[^\w$])(?:for|if|import|in|let|null|package)(?![\w$])/,
      lookbehind: true
    },
    boolean: { pattern: /(^|[^\w$])(?:false|true)(?![\w$])/, lookbehind: true },
    builtin: {
      pattern: /(^|[^\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\w$])/,
      lookbehind: true
    },
    attribute: { pattern: /@[\w$]+(?=\s*\()/, alias: "function" },
    function: {
      pattern: /(^|[^\w$])[a-z_$][\w$]*(?=\s*\()/i,
      lookbehind: true
    },
    number: {
      pattern: /(^|[^\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[eE][+-]?\d+(?:_\d+)*)?(?:[KMGTP]i?)?)(?![\w$])/,
      lookbehind: true
    },
    operator: /\.{3}|_\|_|&&?|\|\|?|[=!]~|[<>=!]=?|[+\-*/?]/,
    punctuation: /[()[\]{},.:]/
  }, e2.languages.cue["string-literal"].inside.interpolation.inside.expression.inside = e2.languages.cue;
}(Prism), Prism.languages.cypher = {
  comment: /\/\/.*/,
  string: {
    pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
    greedy: true
  },
  "class-name": {
    pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
    lookbehind: true,
    greedy: true
  },
  relationship: {
    pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
    lookbehind: true,
    greedy: true,
    alias: "property"
  },
  identifier: { pattern: /`(?:[^`\\\r\n])*`/, greedy: true },
  variable: /\$\w+/,
  keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
  function: /\b\w+\b(?=\s*\()/,
  boolean: /\b(?:false|null|true)\b/i,
  number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
  operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
  punctuation: /[()[\]{},;.]/
}, Prism.languages.d = Prism.languages.extend("clike", {
  comment: [
    { pattern: /^\s*#!.+/, greedy: true },
    {
      pattern: RegExp(
        /(^|[^\\])/.source + "(?:" + [
          /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
          /\/\/.*/.source,
          /\/\*[\s\S]*?\*\//.source
        ].join("|") + ")"
      ),
      lookbehind: true,
      greedy: true
    }
  ],
  string: [
    {
      pattern: RegExp(
        [
          /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
          /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
          /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
          /\bq"(.)[\s\S]*?\2"/.source,
          /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
        ].join("|"),
        "m"
      ),
      greedy: true
    },
    {
      pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
      greedy: true,
      alias: "token-string"
    }
  ],
  keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
  number: [
    /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
    {
      pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
      lookbehind: true
    }
  ],
  operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
}), Prism.languages.insertBefore("d", "string", {
  char: /'(?:\\(?:\W|\w+)|[^\\])'/
}), Prism.languages.insertBefore("d", "keyword", { property: /\B@\w*/ }), Prism.languages.insertBefore("d", "function", {
  register: {
    pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
    alias: "variable"
  }
}), function(e2) {
  var t8 = [
    /\b(?:async|sync|yield)\*/,
    /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
  ], n2 = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, a = {
    pattern: RegExp(n2 + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      namespace: {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: { punctuation: /\./ }
      }
    }
  };
  e2.languages.dart = e2.languages.extend("clike", {
    "class-name": [
      a,
      {
        pattern: RegExp(n2 + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
        lookbehind: true,
        inside: a.inside
      }
    ],
    keyword: t8,
    operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
  }), e2.languages.insertBefore("dart", "string", {
    "string-literal": {
      pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          lookbehind: true,
          inside: {
            punctuation: /^\$\{?|\}$/,
            expression: { pattern: /[\s\S]+/, inside: e2.languages.dart }
          }
        },
        string: /[\s\S]+/
      }
    },
    string: void 0
  }), e2.languages.insertBefore("dart", "class-name", {
    metadata: { pattern: /@\w+/, alias: "function" }
  }), e2.languages.insertBefore("dart", "class-name", {
    generics: {
      pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
      inside: {
        "class-name": a,
        keyword: t8,
        punctuation: /[<>(),.:]/,
        operator: /[?&|]/
      }
    }
  });
}(Prism), Prism.languages.dataweave = {
  url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
  property: {
    pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
    greedy: true
  },
  string: { pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/, greedy: true },
  "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
  date: { pattern: /\|[\w:+-]+\|/, greedy: true },
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  regex: { pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//, greedy: true },
  keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
  function: /\b[A-Z_]\w*(?=\s*\()/i,
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  punctuation: /[{}[\];(),.:@]/,
  operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
  boolean: /\b(?:false|true)\b/
}, Prism.languages.dax = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
    lookbehind: true
  },
  "data-field": {
    pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
    alias: "symbol"
  },
  measure: { pattern: /\[[ \w\xA0-\uFFFF]+\]/, alias: "constant" },
  string: { pattern: /"(?:[^"]|"")*"(?!")/, greedy: true },
  function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
  keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
  boolean: { pattern: /\b(?:FALSE|NULL|TRUE)\b/i, alias: "constant" },
  number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
  operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
  punctuation: /[;\[\](){}`,.]/
}, Prism.languages.dhall = {
  comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
  string: {
    pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /\$\{[^{}]*\}/,
        inside: {
          expression: {
            pattern: /(^\$\{)[\s\S]+(?=\}$)/,
            lookbehind: true,
            alias: "language-dhall",
            inside: null
          },
          punctuation: /\$\{|\}/
        }
      }
    }
  },
  label: { pattern: /`[^`]*`/, greedy: true },
  url: {
    pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
    greedy: true
  },
  env: {
    pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
    greedy: true,
    inside: { function: /^env/, operator: /^:/, variable: /[\s\S]+/ }
  },
  hash: {
    pattern: /\bsha256:[\da-fA-F]{64}\b/,
    inside: { function: /sha256/, operator: /:/, number: /[\da-fA-F]{64}/ }
  },
  keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
  builtin: /\b(?:None|Some)\b/,
  boolean: /\b(?:False|True)\b/,
  number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
  operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
  punctuation: /\.\.|[{}\[\](),./]/,
  "class-name": /\b[A-Z]\w*\b/
}, Prism.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism.languages.dhall, function(a) {
  a.languages.diff = {
    coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m]
  };
  var r2 = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    unchanged: " ",
    diff: "!"
  };
  Object.keys(r2).forEach(function(e2) {
    var t8 = r2[e2], n2 = [];
    /^\w+$/.test(e2) || n2.push(/\w+/.exec(e2)[0]), "diff" === e2 && n2.push("bold"), a.languages.diff[e2] = {
      pattern: RegExp("^(?:[" + t8 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias: n2,
      inside: {
        line: { pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/, lookbehind: true },
        prefix: { pattern: /[\s\S]/, alias: /\w+/.exec(e2)[0] }
      }
    };
  }), Object.defineProperty(a.languages.diff, "PREFIXES", { value: r2 });
}(Prism), function(m) {
  function g2(e2, t8) {
    return "___" + e2.toUpperCase() + t8 + "___";
  }
  Object.defineProperties(m.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      value: function(a, r2, e2, i) {
        var o2;
        a.language === r2 && (o2 = a.tokenStack = [], a.code = a.code.replace(e2, function(e22) {
          if ("function" == typeof i && !i(e22)) return e22;
          for (var t8, n2 = o2.length; -1 !== a.code.indexOf(t8 = g2(r2, n2)); )
            ++n2;
          return o2[n2] = e22, t8;
        }), a.grammar = m.languages.markup);
      }
    },
    tokenizePlaceholders: {
      value: function(d2, c2) {
        var u, p;
        d2.language === c2 && d2.tokenStack && (d2.grammar = m.languages[c2], u = 0, p = Object.keys(d2.tokenStack), function e2(t8) {
          for (var n2 = 0; n2 < t8.length && !(u >= p.length); n2++) {
            var a, r2, i, o2, s2, l2 = t8[n2];
            "string" == typeof l2 || l2.content && "string" == typeof l2.content ? (a = p[u], i = d2.tokenStack[a], o2 = "string" == typeof l2 ? l2 : l2.content, a = g2(c2, a), -1 < (s2 = o2.indexOf(a)) && (++u, r2 = o2.substring(0, s2), i = new m.Token(
              c2,
              m.tokenize(i, d2.grammar),
              "language-" + c2,
              i
            ), o2 = o2.substring(s2 + a.length), s2 = [], r2 && s2.push.apply(s2, e2([r2])), s2.push(i), o2 && s2.push.apply(s2, e2([o2])), "string" == typeof l2 ? t8.splice.apply(t8, [n2, 1].concat(s2)) : l2.content = s2)) : l2.content && e2(l2.content);
          }
          return t8;
        }(d2.tokens));
      }
    }
  });
}(Prism), function(e2) {
  e2.languages.django = {
    comment: /^\{#[\s\S]*?#\}$/,
    tag: { pattern: /(^\{%[+-]?\s*)\w+/, lookbehind: true, alias: "keyword" },
    delimiter: { pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/, alias: "punctuation" },
    string: { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
    filter: { pattern: /(\|)\w+/, lookbehind: true, alias: "function" },
    test: {
      pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
      lookbehind: true,
      alias: "function"
    },
    function: /\b[a-z_]\w+(?=\s*\()/i,
    keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    number: /\b\d+(?:\.\d+)?\b/,
    boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
    variable: /\b\w+\b/,
    punctuation: /[{}[\](),.:;]/
  };
  var t8 = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g, n2 = e2.languages["markup-templating"];
  e2.hooks.add("before-tokenize", function(e22) {
    n2.buildPlaceholders(e22, "django", t8);
  }), e2.hooks.add("after-tokenize", function(e22) {
    n2.tokenizePlaceholders(e22, "django");
  }), e2.languages.jinja2 = e2.languages.django, e2.hooks.add("before-tokenize", function(e22) {
    n2.buildPlaceholders(e22, "jinja2", t8);
  }), e2.hooks.add("after-tokenize", function(e22) {
    n2.tokenizePlaceholders(e22, "jinja2");
  });
}(Prism), Prism.languages["dns-zone-file"] = {
  comment: /;.*/,
  string: { pattern: /"(?:\\.|[^"\\\r\n])*"/, greedy: true },
  variable: [
    { pattern: /(^\$ORIGIN[ \t]+)\S+/m, lookbehind: true },
    { pattern: /(^|\s)@(?=\s|$)/, lookbehind: true }
  ],
  keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
  class: {
    pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
    lookbehind: true,
    alias: "keyword"
  },
  type: {
    pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
    lookbehind: true,
    alias: "keyword"
  },
  punctuation: /[()]/
}, Prism.languages["dns-zone"] = Prism.languages["dns-zone-file"], function(e2) {
  var t8 = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source, n2 = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
    /<SP_BS>/g,
    function() {
      return t8;
    }
  ), a = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source, r2 = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
    /<STR>/g,
    function() {
      return a;
    }
  ), i = { pattern: RegExp(a), greedy: true }, o2 = { pattern: /(^[ \t]*)#.*/m, lookbehind: true, greedy: true };
  function s2(e22, t22) {
    return e22 = e22.replace(/<OPT>/g, function() {
      return r2;
    }).replace(/<SP>/g, function() {
      return n2;
    }), RegExp(e22, t22);
  }
  e2.languages.docker = {
    instruction: {
      pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
      lookbehind: true,
      greedy: true,
      inside: {
        options: {
          pattern: s2(
            /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
            "i"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            property: { pattern: /(^|\s)--[\w-]+/, lookbehind: true },
            string: [
              i,
              { pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/, lookbehind: true }
            ],
            operator: /\\$/m,
            punctuation: /=/
          }
        },
        keyword: [
          {
            pattern: s2(
              /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
              "i"
            ),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: s2(
              /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
              "i"
            ),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: s2(/(^ONBUILD<SP>)\w+/.source, "i"),
            lookbehind: true,
            greedy: true
          },
          { pattern: /^\w+/, greedy: true }
        ],
        comment: o2,
        string: i,
        variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
        operator: /\\$/m
      }
    },
    comment: o2
  }, e2.languages.dockerfile = e2.languages.docker;
}(Prism), function(e2) {
  var n2 = "(?:" + [
    /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
    /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
    /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
    /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
  ].join("|") + ")", t8 = {
    markup: {
      pattern: /(^<)[\s\S]+(?=>$)/,
      lookbehind: true,
      alias: ["language-markup", "language-html", "language-xml"],
      inside: e2.languages.markup
    }
  };
  function a(e22, t22) {
    return RegExp(
      e22.replace(/<ID>/g, function() {
        return n2;
      }),
      t22
    );
  }
  e2.languages.dot = {
    comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m, greedy: true },
    "graph-name": {
      pattern: a(/(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source, "i"),
      lookbehind: true,
      greedy: true,
      alias: "class-name",
      inside: t8
    },
    "attr-value": {
      pattern: a(/(=[ \t\r\n]*)<ID>/.source),
      lookbehind: true,
      greedy: true,
      inside: t8
    },
    "attr-name": {
      pattern: a(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
      lookbehind: true,
      greedy: true,
      inside: t8
    },
    keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
    "compass-point": {
      pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
      lookbehind: true,
      alias: "builtin"
    },
    node: {
      pattern: a(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
      lookbehind: true,
      greedy: true,
      inside: t8
    },
    operator: /[=:]|-[->]/,
    punctuation: /[\[\]{};,]/
  }, e2.languages.gv = e2.languages.dot;
}(Prism), Prism.languages.ebnf = {
  comment: /\(\*[\s\S]*?\*\)/,
  string: { pattern: /"[^"\r\n]*"|'[^'\r\n]*'/, greedy: true },
  special: { pattern: /\?[^?\r\n]*\?/, greedy: true, alias: "class-name" },
  definition: {
    pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
    lookbehind: true,
    alias: ["rule", "keyword"]
  },
  rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
  punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
  operator: /[-=|*/!]/
}, Prism.languages.editorconfig = {
  comment: /[;#].*/,
  section: {
    pattern: /(^[ \t]*)\[.+\]/m,
    lookbehind: true,
    alias: "selector",
    inside: {
      regex: /\\\\[\[\]{},!?.*]/,
      operator: /[!?]|\.\.|\*{1,2}/,
      punctuation: /[\[\]{},]/
    }
  },
  key: {
    pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
    lookbehind: true,
    alias: "attr-name"
  },
  value: {
    pattern: /=.*/,
    alias: "attr-value",
    inside: { punctuation: /^=/ }
  }
}, Prism.languages.eiffel = {
  comment: /--.*/,
  string: [
    { pattern: /"([^[]*)\[[\s\S]*?\]\1"/, greedy: true },
    { pattern: /"([^{]*)\{[\s\S]*?\}\1"/, greedy: true },
    { pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/, greedy: true }
  ],
  char: /'(?:%.|[^%'\r\n])+'/,
  keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
  boolean: /\b(?:False|True)\b/i,
  "class-name": /\b[A-Z][\dA-Z_]*\b/,
  number: [
    /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
    /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
  ],
  punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
  operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
}, function(t8) {
  t8.languages.ejs = {
    delimiter: { pattern: /^<%[-_=]?|[-_]?%>$/, alias: "punctuation" },
    comment: /^#[\s\S]*/,
    "language-javascript": {
      pattern: /[\s\S]+/,
      inside: t8.languages.javascript
    }
  }, t8.hooks.add("before-tokenize", function(e2) {
    t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "ejs",
      /<%(?!%)[\s\S]+?%>/g
    );
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "ejs");
  }), t8.languages.eta = t8.languages.ejs;
}(Prism), Prism.languages.elixir = {
  doc: {
    pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
    inside: { attribute: /^@\w+/, string: /['"][\s\S]+/ }
  },
  comment: { pattern: /#.*/, greedy: true },
  regex: {
    pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
    greedy: true
  },
  string: [
    {
      pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
      greedy: true,
      inside: {}
    },
    { pattern: /("""|''')[\s\S]*?\1/, greedy: true, inside: {} },
    {
      pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true,
      inside: {}
    }
  ],
  atom: { pattern: /(^|[^:]):\w+/, lookbehind: true, alias: "symbol" },
  module: { pattern: /\b[A-Z]\w*\b/, alias: "class-name" },
  "attr-name": /\b\w+\??:(?!:)/,
  argument: { pattern: /(^|[^&])&\d+/, lookbehind: true, alias: "variable" },
  attribute: { pattern: /@\w+/, alias: "variable" },
  function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
  number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
  keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
  boolean: /\b(?:false|nil|true)\b/,
  operator: [
    /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
    { pattern: /([^<])<(?!<)/, lookbehind: true },
    { pattern: /([^>])>(?!>)/, lookbehind: true }
  ],
  punctuation: /<<|>>|[.,%\[\]{}()]/
}, Prism.languages.elixir.string.forEach(function(e2) {
  e2.inside = {
    interpolation: {
      pattern: /#\{[^}]+\}/,
      inside: {
        delimiter: { pattern: /^#\{|\}$/, alias: "punctuation" },
        rest: Prism.languages.elixir
      }
    }
  };
}), Prism.languages.elm = {
  comment: /--.*|\{-[\s\S]*?-\}/,
  char: {
    pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
    greedy: true
  },
  string: [
    { pattern: /"""[\s\S]*?"""/, greedy: true },
    { pattern: /"(?:[^\\"\r\n]|\\.)*"/, greedy: true }
  ],
  "import-statement": {
    pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
    lookbehind: true,
    inside: { keyword: /\b(?:as|exposing|import)\b/ }
  },
  keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
  builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
  number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
  operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
  hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
  constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
  punctuation: /[{}[\]|(),.:]/
}, Prism.languages.lua = {
  comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  string: {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  function: /(?!\d)\w+(?=\s*(?:[({]))/,
  operator: [
    /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
    { pattern: /(^|[^.])\.\.(?!\.)/, lookbehind: true }
  ],
  punctuation: /[\[\](){},;]|\.+|:+/
}, function(t8) {
  t8.languages.etlua = {
    delimiter: { pattern: /^<%[-=]?|-?%>$/, alias: "punctuation" },
    "language-lua": { pattern: /[\s\S]+/, inside: t8.languages.lua }
  }, t8.hooks.add("before-tokenize", function(e2) {
    t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "etlua",
      /<%[\s\S]+?%>/g
    );
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "etlua");
  });
}(Prism), function(t8) {
  t8.languages.erb = {
    delimiter: {
      pattern: /^(\s*)<%=?|%>(?=\s*$)/,
      lookbehind: true,
      alias: "punctuation"
    },
    ruby: {
      pattern: /\s*\S[\s\S]*/,
      alias: "language-ruby",
      inside: t8.languages.ruby
    }
  }, t8.hooks.add("before-tokenize", function(e2) {
    t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "erb",
      /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g
    );
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "erb");
  });
}(Prism), Prism.languages.erlang = {
  comment: /%.+/,
  string: { pattern: /"(?:\\.|[^\\"\r\n])*"/, greedy: true },
  "quoted-function": {
    pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
    alias: "function"
  },
  "quoted-atom": { pattern: /'(?:\\.|[^\\'\r\n])+'/, alias: "atom" },
  boolean: /\b(?:false|true)\b/,
  keyword: /\b(?:after|begin|case|catch|end|fun|if|of|receive|try|when)\b/,
  number: [
    /\$\\?./,
    /\b\d+#[a-z0-9]+/i,
    /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
  ],
  function: /\b[a-z][\w@]*(?=\()/,
  variable: { pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/, lookbehind: true },
  operator: [
    /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
    { pattern: /(^|[^<])<(?!<)/, lookbehind: true },
    { pattern: /(^|[^>])>(?!>)/, lookbehind: true }
  ],
  atom: /\b[a-z][\w@]*/,
  punctuation: /[()[\]{}:;,.#|]|<<|>>/
}, Prism.languages["excel-formula"] = {
  comment: {
    pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
    lookbehind: true,
    greedy: true
  },
  string: { pattern: /"(?:[^"]|"")*"(?!")/, greedy: true },
  reference: {
    pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
    greedy: true,
    alias: "string",
    inside: {
      operator: /!$/,
      punctuation: /'/,
      sheet: { pattern: /[^[\]]+$/, alias: "function" },
      file: { pattern: /\[[^[\]]+\]$/, inside: { punctuation: /[[\]]/ } },
      path: /[\s\S]+/
    }
  },
  "function-name": { pattern: /\b[A-Z]\w*(?=\()/i, alias: "builtin" },
  range: {
    pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
    alias: "selector",
    inside: {
      operator: /:/,
      cell: /\$?[A-Z]+\$?\d+/i,
      column: /\$?[A-Z]+/i,
      row: /\$?\d+/
    }
  },
  cell: {
    pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
    alias: "selector"
  },
  number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
  boolean: /\b(?:FALSE|TRUE)\b/i,
  operator: /[-+*/^%=&,]|<[=>]?|>=?/,
  punctuation: /[[\]();{}|]/
}, Prism.languages.xlsx = Prism.languages.xls = Prism.languages["excel-formula"], Prism.languages.fsharp = Prism.languages.extend("clike", {
  comment: [
    {
      pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  string: {
    pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
    lookbehind: true,
    inside: { operator: /->|\*/, punctuation: /\./ }
  },
  keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
  number: [
    /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
    /\b0b[01]+(?:uy|y)?\b/,
    /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
    /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
  ],
  operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
}), Prism.languages.insertBefore("fsharp", "keyword", {
  preprocessor: {
    pattern: /(^[\t ]*)#.*/m,
    lookbehind: true,
    alias: "property",
    inside: {
      directive: {
        pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
        lookbehind: true,
        alias: "keyword"
      }
    }
  }
}), Prism.languages.insertBefore("fsharp", "punctuation", {
  "computation-expression": {
    pattern: /\b[_a-z]\w*(?=\s*\{)/i,
    alias: "keyword"
  }
}), Prism.languages.insertBefore("fsharp", "string", {
  annotation: {
    pattern: /\[<.+?>\]/,
    greedy: true,
    inside: {
      punctuation: /^\[<|>\]$/,
      "class-name": {
        pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
        lookbehind: true
      },
      "annotation-content": {
        pattern: /[\s\S]+/,
        inside: Prism.languages.fsharp
      }
    }
  },
  char: {
    pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
    greedy: true
  }
}), function(e2) {
  function t8(e22) {
    return (e22 + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
  }
  function n2(e22) {
    return new RegExp("(^|\\s)(?:" + e22.map(t8).join("|") + ")(?=\\s|$)");
  }
  var a = {
    function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
  }, r2 = { number: /\\[^\s']|%\w/ }, i = {
    comment: [
      { pattern: /(^|\s)(?:! .*|!$)/, lookbehind: true, inside: a },
      {
        pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
        lookbehind: true,
        greedy: true,
        inside: a
      },
      {
        pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
        lookbehind: true,
        greedy: true,
        inside: a
      }
    ],
    number: [
      { pattern: /(^|\s)[+-]?\d+(?=\s|$)/, lookbehind: true },
      {
        pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
        lookbehind: true
      },
      { pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/, lookbehind: true },
      { pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/, lookbehind: true },
      { pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/, lookbehind: true },
      {
        pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
        lookbehind: true
      },
      { pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/, lookbehind: true },
      {
        pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
        lookbehind: true
      }
    ],
    regexp: {
      pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
      lookbehind: true,
      alias: "number",
      inside: {
        variable: /\\\S/,
        keyword: /[+?*\[\]^$(){}.|]/,
        operator: { pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/, lookbehind: true }
      }
    },
    boolean: { pattern: /(^|\s)[tf](?=\s|$)/, lookbehind: true },
    "custom-string": {
      pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
      lookbehind: true,
      greedy: true,
      alias: "string",
      inside: { number: /\\\S|%\w|\// }
    },
    "multiline-string": [
      {
        pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
        lookbehind: true,
        greedy: true,
        alias: "string",
        inside: {
          number: r2.number,
          "semicolon-or-setlocal": {
            pattern: /([\r\n][ \t]*);(?=\s|$)/,
            lookbehind: true,
            alias: "function"
          }
        }
      },
      {
        pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
        lookbehind: true,
        greedy: true,
        alias: "string",
        inside: r2
      },
      {
        pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
        lookbehind: true,
        greedy: true,
        alias: "string",
        inside: r2
      }
    ],
    "special-using": {
      pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
      lookbehind: true,
      alias: "function",
      inside: { string: { pattern: /(\s)[^:\s]+/, lookbehind: true } }
    },
    "stack-effect-delimiter": [
      {
        pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
        lookbehind: true,
        alias: "operator"
      },
      { pattern: /(\s)--(?=\s)/, lookbehind: true, alias: "operator" },
      { pattern: /(\s)\)(?=\s|$)/, lookbehind: true, alias: "operator" }
    ],
    combinators: { pattern: null, lookbehind: true, alias: "keyword" },
    "kernel-builtin": { pattern: null, lookbehind: true, alias: "variable" },
    "sequences-builtin": {
      pattern: null,
      lookbehind: true,
      alias: "variable"
    },
    "math-builtin": { pattern: null, lookbehind: true, alias: "variable" },
    "constructor-word": {
      pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
      lookbehind: true,
      alias: "keyword"
    },
    "other-builtin-syntax": {
      pattern: null,
      lookbehind: true,
      alias: "operator"
    },
    "conventionally-named-word": {
      pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
      lookbehind: true,
      alias: "keyword"
    },
    "colon-syntax": {
      pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
      lookbehind: true,
      greedy: true,
      alias: "function"
    },
    "semicolon-or-setlocal": {
      pattern: /(\s)(?:;|:>)(?=\s|$)/,
      lookbehind: true,
      alias: "function"
    },
    "curly-brace-literal-delimiter": [
      {
        pattern: /(^|\s)[a-z]*\{(?=\s)/i,
        lookbehind: true,
        alias: "operator"
      },
      { pattern: /(\s)\}(?=\s|$)/, lookbehind: true, alias: "operator" }
    ],
    "quotation-delimiter": [
      { pattern: /(^|\s)\[(?=\s)/, lookbehind: true, alias: "operator" },
      { pattern: /(\s)\](?=\s|$)/, lookbehind: true, alias: "operator" }
    ],
    "normal-word": { pattern: /(^|\s)[^"\s]\S*(?=\s|$)/, lookbehind: true },
    string: { pattern: /"(?:\\\S|[^"\\])*"/, greedy: true, inside: r2 }
  }, o2 = {
    "kernel-builtin": [
      "or",
      "2nipd",
      "4drop",
      "tuck",
      "wrapper",
      "nip",
      "wrapper?",
      "callstack>array",
      "die",
      "dupd",
      "callstack",
      "callstack?",
      "3dup",
      "hashcode",
      "pick",
      "4nip",
      "build",
      ">boolean",
      "nipd",
      "clone",
      "5nip",
      "eq?",
      "?",
      "=",
      "swapd",
      "2over",
      "clear",
      "2dup",
      "get-retainstack",
      "not",
      "tuple?",
      "dup",
      "3nipd",
      "call",
      "-rotd",
      "object",
      "drop",
      "assert=",
      "assert?",
      "-rot",
      "execute",
      "boa",
      "get-callstack",
      "curried?",
      "3drop",
      "pickd",
      "overd",
      "over",
      "roll",
      "3nip",
      "swap",
      "and",
      "2nip",
      "rotd",
      "throw",
      "(clone)",
      "hashcode*",
      "spin",
      "reach",
      "4dup",
      "equal?",
      "get-datastack",
      "assert",
      "2drop",
      "<wrapper>",
      "boolean?",
      "identity-hashcode",
      "identity-tuple?",
      "null",
      "composed?",
      "new",
      "5drop",
      "rot",
      "-roll",
      "xor",
      "identity-tuple",
      "boolean"
    ],
    "other-builtin-syntax": [
      "=======",
      "recursive",
      "flushable",
      ">>",
      "<<<<<<",
      "M\\",
      "B",
      "PRIVATE>",
      "\\",
      "======",
      "final",
      "inline",
      "delimiter",
      "deprecated",
      "<PRIVATE",
      ">>>>>>",
      "<<<<<<<",
      "parse-complex",
      "malformed-complex",
      "read-only",
      ">>>>>>>",
      "call-next-method",
      "<<",
      "foldable",
      "$",
      "$[",
      "${"
    ],
    "sequences-builtin": [
      "member-eq?",
      "mismatch",
      "append",
      "assert-sequence=",
      "longer",
      "repetition",
      "clone-like",
      "3sequence",
      "assert-sequence?",
      "last-index-from",
      "reversed",
      "index-from",
      "cut*",
      "pad-tail",
      "join-as",
      "remove-eq!",
      "concat-as",
      "but-last",
      "snip",
      "nths",
      "nth",
      "sequence",
      "longest",
      "slice?",
      "<slice>",
      "remove-nth",
      "tail-slice",
      "empty?",
      "tail*",
      "member?",
      "virtual-sequence?",
      "set-length",
      "drop-prefix",
      "iota",
      "unclip",
      "bounds-error?",
      "unclip-last-slice",
      "non-negative-integer-expected",
      "non-negative-integer-expected?",
      "midpoint@",
      "longer?",
      "?set-nth",
      "?first",
      "rest-slice",
      "prepend-as",
      "prepend",
      "fourth",
      "sift",
      "subseq-start",
      "new-sequence",
      "?last",
      "like",
      "first4",
      "1sequence",
      "reverse",
      "slice",
      "virtual@",
      "repetition?",
      "set-last",
      "index",
      "4sequence",
      "max-length",
      "set-second",
      "immutable-sequence",
      "first2",
      "first3",
      "supremum",
      "unclip-slice",
      "suffix!",
      "insert-nth",
      "tail",
      "3append",
      "short",
      "suffix",
      "concat",
      "flip",
      "immutable?",
      "reverse!",
      "2sequence",
      "sum",
      "delete-all",
      "indices",
      "snip-slice",
      "<iota>",
      "check-slice",
      "sequence?",
      "head",
      "append-as",
      "halves",
      "sequence=",
      "collapse-slice",
      "?second",
      "slice-error?",
      "product",
      "bounds-check?",
      "bounds-check",
      "immutable",
      "virtual-exemplar",
      "harvest",
      "remove",
      "pad-head",
      "last",
      "set-fourth",
      "cartesian-product",
      "remove-eq",
      "shorten",
      "shorter",
      "reversed?",
      "shorter?",
      "shortest",
      "head-slice",
      "pop*",
      "tail-slice*",
      "but-last-slice",
      "iota?",
      "append!",
      "cut-slice",
      "new-resizable",
      "head-slice*",
      "sequence-hashcode",
      "pop",
      "set-nth",
      "?nth",
      "second",
      "join",
      "immutable-sequence?",
      "<reversed>",
      "3append-as",
      "virtual-sequence",
      "subseq?",
      "remove-nth!",
      "length",
      "last-index",
      "lengthen",
      "assert-sequence",
      "copy",
      "move",
      "third",
      "first",
      "tail?",
      "set-first",
      "prefix",
      "bounds-error",
      "<repetition>",
      "exchange",
      "surround",
      "cut",
      "min-length",
      "set-third",
      "push-all",
      "head?",
      "subseq-start-from",
      "delete-slice",
      "rest",
      "sum-lengths",
      "head*",
      "infimum",
      "remove!",
      "glue",
      "slice-error",
      "subseq",
      "push",
      "replace-slice",
      "subseq-as",
      "unclip-last"
    ],
    "math-builtin": [
      "number=",
      "next-power-of-2",
      "?1+",
      "fp-special?",
      "imaginary-part",
      "float>bits",
      "number?",
      "fp-infinity?",
      "bignum?",
      "fp-snan?",
      "denominator",
      "gcd",
      "*",
      "+",
      "fp-bitwise=",
      "-",
      "u>=",
      "/",
      ">=",
      "bitand",
      "power-of-2?",
      "log2-expects-positive",
      "neg?",
      "<",
      "log2",
      ">",
      "integer?",
      "number",
      "bits>double",
      "2/",
      "zero?",
      "bits>float",
      "float?",
      "shift",
      "ratio?",
      "rect>",
      "even?",
      "ratio",
      "fp-sign",
      "bitnot",
      ">fixnum",
      "complex?",
      "/i",
      "integer>fixnum",
      "/f",
      "sgn",
      ">bignum",
      "next-float",
      "u<",
      "u>",
      "mod",
      "recip",
      "rational",
      ">float",
      "2^",
      "integer",
      "fixnum?",
      "neg",
      "fixnum",
      "sq",
      "bignum",
      ">rect",
      "bit?",
      "fp-qnan?",
      "simple-gcd",
      "complex",
      "<fp-nan>",
      "real",
      ">fraction",
      "double>bits",
      "bitor",
      "rem",
      "fp-nan-payload",
      "real-part",
      "log2-expects-positive?",
      "prev-float",
      "align",
      "unordered?",
      "float",
      "fp-nan?",
      "abs",
      "bitxor",
      "integer>fixnum-strict",
      "u<=",
      "odd?",
      "<=",
      "/mod",
      ">integer",
      "real?",
      "rational?",
      "numerator"
    ]
  };
  Object.keys(o2).forEach(function(e22) {
    i[e22].pattern = n2(o2[e22]);
  });
  i.combinators.pattern = n2([
    "2bi",
    "while",
    "2tri",
    "bi*",
    "4dip",
    "both?",
    "same?",
    "tri@",
    "curry",
    "prepose",
    "3bi",
    "?if",
    "tri*",
    "2keep",
    "3keep",
    "curried",
    "2keepd",
    "when",
    "2bi*",
    "2tri*",
    "4keep",
    "bi@",
    "keepdd",
    "do",
    "unless*",
    "tri-curry",
    "if*",
    "loop",
    "bi-curry*",
    "when*",
    "2bi@",
    "2tri@",
    "with",
    "2with",
    "either?",
    "bi",
    "until",
    "3dip",
    "3curry",
    "tri-curry*",
    "tri-curry@",
    "bi-curry",
    "keepd",
    "compose",
    "2dip",
    "if",
    "3tri",
    "unless",
    "tuple",
    "keep",
    "2curry",
    "tri",
    "most",
    "while*",
    "dip",
    "composed",
    "bi-curry@",
    "find-last-from",
    "trim-head-slice",
    "map-as",
    "each-from",
    "none?",
    "trim-tail",
    "partition",
    "if-empty",
    "accumulate*",
    "reject!",
    "find-from",
    "accumulate-as",
    "collector-for-as",
    "reject",
    "map",
    "map-sum",
    "accumulate!",
    "2each-from",
    "follow",
    "supremum-by",
    "map!",
    "unless-empty",
    "collector",
    "padding",
    "reduce-index",
    "replicate-as",
    "infimum-by",
    "trim-tail-slice",
    "count",
    "find-index",
    "filter",
    "accumulate*!",
    "reject-as",
    "map-integers",
    "map-find",
    "reduce",
    "selector",
    "interleave",
    "2map",
    "filter-as",
    "binary-reduce",
    "map-index-as",
    "find",
    "produce",
    "filter!",
    "replicate",
    "cartesian-map",
    "cartesian-each",
    "find-index-from",
    "map-find-last",
    "3map-as",
    "3map",
    "find-last",
    "selector-as",
    "2map-as",
    "2map-reduce",
    "accumulate",
    "each",
    "each-index",
    "accumulate*-as",
    "when-empty",
    "all?",
    "collector-as",
    "push-either",
    "new-like",
    "collector-for",
    "2selector",
    "push-if",
    "2all?",
    "map-reduce",
    "3each",
    "any?",
    "trim-slice",
    "2reduce",
    "change-nth",
    "produce-as",
    "2each",
    "trim",
    "trim-head",
    "cartesian-find",
    "map-index",
    "if-zero",
    "each-integer",
    "unless-zero",
    "(find-integer)",
    "when-zero",
    "find-last-integer",
    "(all-integers?)",
    "times",
    "(each-integer)",
    "find-integer",
    "all-integers?",
    "unless-negative",
    "if-positive",
    "when-positive",
    "when-negative",
    "unless-positive",
    "if-negative",
    "case",
    "2cleave",
    "cond>quot",
    "case>quot",
    "3cleave",
    "wrong-values",
    "to-fixed-point",
    "alist>quot",
    "cond",
    "cleave",
    "call-effect",
    "recursive-hashcode",
    "spread",
    "deep-spread>quot",
    "2||",
    "0||",
    "n||",
    "0&&",
    "2&&",
    "3||",
    "1||",
    "1&&",
    "n&&",
    "3&&",
    "smart-unless*",
    "keep-inputs",
    "reduce-outputs",
    "smart-when*",
    "cleave>array",
    "smart-with",
    "smart-apply",
    "smart-if",
    "inputs/outputs",
    "output>sequence-n",
    "map-outputs",
    "map-reduce-outputs",
    "dropping",
    "output>array",
    "smart-map-reduce",
    "smart-2map-reduce",
    "output>array-n",
    "nullary",
    "input<sequence",
    "append-outputs",
    "drop-inputs",
    "inputs",
    "smart-2reduce",
    "drop-outputs",
    "smart-reduce",
    "preserving",
    "smart-when",
    "outputs",
    "append-outputs-as",
    "smart-unless",
    "smart-if*",
    "sum-outputs",
    "input<sequence-unsafe",
    "output>sequence"
  ]), e2.languages.factor = i;
}(Prism), Prism.languages.false = {
  comment: { pattern: /\{[^}]*\}/ },
  string: { pattern: /"[^"]*"/, greedy: true },
  "character-code": { pattern: /'(?:[^\r]|\r\n?)/, alias: "number" },
  "assembler-code": { pattern: /\d+`/, alias: "important" },
  number: /\d+/,
  operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
  punctuation: /\[|\]/,
  variable: /[a-z]/,
  "non-standard": { pattern: /[()<BDO®]/, alias: "bold" }
}, Prism.languages["firestore-security-rules"] = Prism.languages.extend(
  "clike",
  {
    comment: /\/\/.*/,
    keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
    operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
  }
), delete Prism.languages["firestore-security-rules"]["class-name"], Prism.languages.insertBefore("firestore-security-rules", "keyword", {
  path: {
    pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
    lookbehind: true,
    greedy: true,
    inside: {
      variable: {
        pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
        inside: { operator: /=/, keyword: /\*\*/, punctuation: /[.$(){}]/ }
      },
      punctuation: /\//
    }
  },
  method: {
    pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
    lookbehind: true,
    alias: "builtin",
    inside: { punctuation: /,/ }
  }
}), function(e2) {
  e2.languages.flow = e2.languages.extend("javascript", {}), e2.languages.insertBefore("flow", "keyword", {
    type: [
      {
        pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/,
        alias: "class-name"
      }
    ]
  }), e2.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e2.languages.flow.parameter, e2.languages.insertBefore("flow", "operator", {
    "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" }
  }), Array.isArray(e2.languages.flow.keyword) || (e2.languages.flow.keyword = [e2.languages.flow.keyword]), e2.languages.flow.keyword.unshift(
    {
      pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
      lookbehind: true
    },
    {
      pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
      lookbehind: true
    }
  );
}(Prism), Prism.languages.fortran = {
  "quoted-number": { pattern: /[BOZ](['"])[A-F0-9]+\1/i, alias: "number" },
  string: {
    pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
    inside: { comment: { pattern: /(&(?:\r\n?|\n)\s*)!.*/, lookbehind: true } }
  },
  comment: { pattern: /!.*/, greedy: true },
  boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
  keyword: [
    /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
    /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
    /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
    /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
  ],
  operator: [
    /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
    { pattern: /(^|(?!\().)\/(?!\))/, lookbehind: true }
  ],
  punctuation: /\(\/|\/\)|[(),;:&]/
}, function(n2) {
  for (var a = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source, e2 = 0; e2 < 2; e2++)
    a = a.replace(/<expr>/g, function() {
      return a;
    });
  var a = a.replace(/<expr>/g, /[^\s\S]/.source), t8 = {
    comment: /<#--[\s\S]*?-->/,
    string: [
      { pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/, greedy: true },
      {
        pattern: RegExp(
          /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
            /<expr>/g,
            function() {
              return a;
            }
          )
        ),
        greedy: true,
        inside: {
          interpolation: {
            pattern: RegExp(
              /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
                /<expr>/g,
                function() {
                  return a;
                }
              )
            ),
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: null
            }
          }
        }
      }
    ],
    keyword: /\b(?:as)\b/,
    boolean: /\b(?:false|true)\b/,
    "builtin-function": {
      pattern: /((?:^|[^?])\?\s*)\w+/,
      lookbehind: true,
      alias: "function"
    },
    function: /\b\w+(?=\s*\()/,
    number: /\b\d+(?:\.\d+)?\b/,
    operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
    punctuation: /[,;.:()[\]{}]/
  };
  t8.string[1].inside.interpolation.inside.rest = t8, n2.languages.ftl = {
    "ftl-comment": { pattern: /^<#--[\s\S]*/, alias: "comment" },
    "ftl-directive": {
      pattern: /^<[\s\S]+>$/,
      inside: {
        directive: {
          pattern: /(^<\/?)[#@][a-z]\w*/i,
          lookbehind: true,
          alias: "keyword"
        },
        punctuation: /^<\/?|\/?>$/,
        content: { pattern: /\s*\S[\s\S]*/, alias: "ftl", inside: t8 }
      }
    },
    "ftl-interpolation": {
      pattern: /^\$\{[\s\S]*\}$/,
      inside: {
        punctuation: /^\$\{|\}$/,
        content: { pattern: /\s*\S[\s\S]*/, alias: "ftl", inside: t8 }
      }
    }
  }, n2.hooks.add("before-tokenize", function(e22) {
    var t22 = RegExp(
      /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
        /<expr>/g,
        function() {
          return a;
        }
      ),
      "gi"
    );
    n2.languages["markup-templating"].buildPlaceholders(e22, "ftl", t22);
  }), n2.hooks.add("after-tokenize", function(e22) {
    n2.languages["markup-templating"].tokenizePlaceholders(e22, "ftl");
  });
}(Prism), Prism.languages.gamemakerlanguage = Prism.languages.gml = Prism.languages.extend("clike", {
  keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
  number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
  operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
  constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
  variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
}), Prism.languages.gap = {
  shell: {
    pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
    greedy: true,
    inside: {
      gap: {
        pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
        lookbehind: true,
        inside: null
      },
      punctuation: /^gap>/
    }
  },
  comment: { pattern: /#.*/, greedy: true },
  string: {
    pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
    lookbehind: true,
    greedy: true,
    inside: {
      continuation: {
        pattern: /([\r\n])>/,
        lookbehind: true,
        alias: "punctuation"
      }
    }
  },
  keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: {
    pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
    lookbehind: true
  },
  continuation: {
    pattern: /([\r\n])>/,
    lookbehind: true,
    alias: "punctuation"
  },
  operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
  punctuation: /[()[\]{},;.:]/
}, Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap, Prism.languages.gcode = {
  comment: /;.*|\B\(.*?\)\B/,
  string: { pattern: /"(?:""|[^"])*"/, greedy: true },
  keyword: /\b[GM]\d+(?:\.\d+)?\b/,
  property: /\b[A-Z]/,
  checksum: { pattern: /(\*)\d+/, lookbehind: true, alias: "number" },
  punctuation: /[:*]/
}, Prism.languages.gdscript = {
  comment: /#.*/,
  string: {
    pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
    greedy: true
  },
  "class-name": {
    pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
    lookbehind: true
  },
  keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
  function: /\b[a-z_]\w*(?=[ \t]*\()/i,
  variable: /\$\w+/,
  number: [
    /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
    /\b(?:INF|NAN|PI|TAU)\b/
  ],
  constant: /\b[A-Z][A-Z_\d]*\b/,
  boolean: /\b(?:false|true)\b/,
  operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
  punctuation: /[.:,;()[\]{}]/
}, Prism.languages.gedcom = {
  "line-value": {
    pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
    lookbehind: true,
    inside: {
      pointer: {
        pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
        alias: "variable"
      }
    }
  },
  record: {
    pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
    lookbehind: true,
    alias: "tag"
  },
  level: { pattern: /(^[\t ]*)\d+/m, lookbehind: true, alias: "number" },
  pointer: {
    pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
    alias: "variable"
  }
}, Prism.languages.gettext = {
  comment: [
    { pattern: /# .*/, greedy: true, alias: "translator-comment" },
    { pattern: /#\..*/, greedy: true, alias: "extracted-comment" },
    { pattern: /#:.*/, greedy: true, alias: "reference-comment" },
    { pattern: /#,.*/, greedy: true, alias: "flag-comment" },
    {
      pattern: /#\|.*/,
      greedy: true,
      alias: "previously-untranslated-comment"
    },
    { pattern: /#.*/, greedy: true }
  ],
  string: {
    pattern: /(^|[^\\])"(?:[^"\\]|\\.)*"/,
    lookbehind: true,
    greedy: true
  },
  keyword: /^msg(?:ctxt|id|id_plural|str)\b/m,
  number: /\b\d+\b/,
  punctuation: /[\[\]]/
}, Prism.languages.po = Prism.languages.gettext, function(e2) {
  var t8 = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
  e2.languages.gherkin = {
    pystring: { pattern: /("""|''')[\s\S]+?\1/, alias: "string" },
    comment: { pattern: /(^[ \t]*)#.*/m, lookbehind: true },
    tag: { pattern: /(^[ \t]*)@\S*/m, lookbehind: true },
    feature: {
      pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
      lookbehind: true,
      inside: {
        important: { pattern: /(:)[^\r\n]+/, lookbehind: true },
        keyword: /[^:\r\n]+:/
      }
    },
    scenario: {
      pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
      lookbehind: true,
      inside: {
        important: { pattern: /(:)[^\r\n]*/, lookbehind: true },
        keyword: /[^:\r\n]+:/
      }
    },
    "table-body": {
      pattern: RegExp("(" + t8 + ")(?:" + t8 + ")+"),
      lookbehind: true,
      inside: {
        outline: { pattern: /<[^>]+>/, alias: "variable" },
        td: { pattern: /\s*[^\s|][^|]*/, alias: "string" },
        punctuation: /\|/
      }
    },
    "table-head": {
      pattern: RegExp(t8),
      inside: {
        th: { pattern: /\s*[^\s|][^|]*/, alias: "variable" },
        punctuation: /\|/
      }
    },
    atrule: {
      pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
      lookbehind: true
    },
    string: {
      pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
      inside: { outline: { pattern: /<[^>]+>/, alias: "variable" } }
    },
    outline: { pattern: /<[^>]+>/, alias: "variable" }
  };
}(Prism), Prism.languages.git = {
  comment: /^#.*/m,
  deleted: /^[-–].*/m,
  inserted: /^\+.*/m,
  string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  command: { pattern: /^.*\$ git .*$/m, inside: { parameter: /\s--?\w+/ } },
  coord: /^@@.*@@$/m,
  "commit-sha1": /^commit \w{40}$/m
}, Prism.languages.glsl = Prism.languages.extend("c", {
  keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
}), Prism.languages.gn = {
  comment: { pattern: /#.*/, greedy: true },
  "string-literal": {
    pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
    lookbehind: true,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
        lookbehind: true,
        inside: {
          number: /^\$0x[\s\S]{2}$/,
          variable: /^\$\w+$/,
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          expression: { pattern: /[\s\S]+/, inside: null }
        }
      },
      string: /[\s\S]+/
    }
  },
  keyword: /\b(?:else|if)\b/,
  boolean: /\b(?:false|true)\b/,
  "builtin-function": {
    pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
    alias: "keyword"
  },
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
  number: /-?\b\d+\b/,
  operator: /[-+!=<>]=?|&&|\|\|/,
  punctuation: /[(){}[\],.]/
}, Prism.languages.gn["string-literal"].inside.interpolation.inside.expression.inside = Prism.languages.gn, Prism.languages.gni = Prism.languages.gn, Prism.languages["linker-script"] = {
  comment: {
    pattern: /(^|\s)\/\*[\s\S]*?(?:$|\*\/)/,
    lookbehind: true,
    greedy: true
  },
  identifier: { pattern: /"[^"\r\n]*"/, greedy: true },
  "location-counter": { pattern: /\B\.\B/, alias: "important" },
  section: { pattern: /(^|[^\w*])\.\w+\b/, lookbehind: true, alias: "keyword" },
  function: /\b[A-Z][A-Z_]*(?=\s*\()/,
  number: /\b(?:0[xX][a-fA-F0-9]+|\d+)[KM]?\b/,
  operator: />>=?|<<=?|->|\+\+|--|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?/,
  punctuation: /[(){},;]/
}, Prism.languages.ld = Prism.languages["linker-script"], Prism.languages.go = Prism.languages.extend("clike", {
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  boolean: /\b(?:_|false|iota|nil|true)\b/,
  number: [
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
}), Prism.languages.insertBefore("go", "string", {
  char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true }
}), delete Prism.languages.go["class-name"], Prism.languages["go-mod"] = Prism.languages["go-module"] = {
  comment: { pattern: /\/\/.*/, greedy: true },
  version: {
    pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
    lookbehind: true,
    alias: "number"
  },
  "go-version": {
    pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
    lookbehind: true,
    alias: "number"
  },
  keyword: {
    pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
    lookbehind: true
  },
  operator: /=>/,
  punctuation: /[()[\],]/
}, function(e2) {
  var t8 = {
    pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
    lookbehind: true,
    inside: {
      "interpolation-punctuation": {
        pattern: /^\$\{?|\}$/,
        alias: "punctuation"
      },
      expression: { pattern: /[\s\S]+/, inside: null }
    }
  };
  e2.languages.gradle = e2.languages.extend("clike", {
    string: {
      pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
      greedy: true
    },
    keyword: /\b(?:apply|def|dependencies|else|if|implementation|import|plugin|plugins|project|repositories|repository|sourceSets|tasks|val)\b/,
    number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
    operator: {
      pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
      lookbehind: true
    },
    punctuation: /\.+|[{}[\];(),:$]/
  }), e2.languages.insertBefore("gradle", "string", {
    shebang: { pattern: /#!.+/, alias: "comment", greedy: true },
    "interpolation-string": {
      pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
      greedy: true,
      inside: { interpolation: t8, string: /[\s\S]+/ }
    }
  }), e2.languages.insertBefore("gradle", "punctuation", {
    "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
  }), e2.languages.insertBefore("gradle", "function", {
    annotation: {
      pattern: /(^|[^.])@\w+/,
      lookbehind: true,
      alias: "punctuation"
    }
  }), t8.inside.expression.inside = e2.languages.gradle;
}(Prism), Prism.languages.graphql = {
  comment: /#.*/,
  description: {
    pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
    greedy: true,
    alias: "string",
    inside: {
      "language-markdown": {
        pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
        lookbehind: true,
        inside: Prism.languages.markdown
      }
    }
  },
  string: {
    pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
    greedy: true
  },
  number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  boolean: /\b(?:false|true)\b/,
  variable: /\$[a-z_]\w*/i,
  directive: { pattern: /@[a-z_]\w*/i, alias: "function" },
  "attr-name": {
    pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
    greedy: true
  },
  "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" },
  scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
  constant: /\b[A-Z][A-Z_\d]*\b/,
  "class-name": {
    pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
    lookbehind: true
  },
  fragment: {
    pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-mutation": {
    pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-query": {
    pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
  operator: /[!=|&]|\.{3}/,
  "property-query": /\w+(?=\s*\()/,
  object: /\w+(?=\s*\{)/,
  punctuation: /[!(){}\[\]:=,]/,
  property: /\w+/
}, Prism.hooks.add("after-tokenize", function(e2) {
  if ("graphql" === e2.language)
    for (var o2 = e2.tokens.filter(function(e22) {
      return "string" != typeof e22 && "comment" !== e22.type && "scalar" !== e22.type;
    }), s2 = 0; s2 < o2.length; ) {
      var t8 = o2[s2++];
      if ("keyword" === t8.type && "mutation" === t8.content) {
        var n2 = [];
        if (u(["definition-mutation", "punctuation"]) && "(" === c2(1).content) {
          s2 += 2;
          var a = p(/^\($/, /^\)$/);
          if (-1 === a) continue;
          for (; s2 < a; s2++) {
            var r2 = c2(0);
            "variable" === r2.type && (m(r2, "variable-input"), n2.push(r2.content));
          }
          s2 = a + 1;
        }
        if (u(["punctuation", "property-query"]) && "{" === c2(0).content && (s2++, m(c2(0), "property-mutation"), 0 < n2.length)) {
          var i = p(/^\{$/, /^\}$/);
          if (-1 !== i)
            for (var l2 = s2; l2 < i; l2++) {
              var d2 = o2[l2];
              "variable" === d2.type && 0 <= n2.indexOf(d2.content) && m(d2, "variable-input");
            }
        }
      }
    }
  function c2(e22) {
    return o2[s2 + e22];
  }
  function u(e22, t22) {
    t22 = t22 || 0;
    for (var n22 = 0; n22 < e22.length; n22++) {
      var a2 = c2(n22 + t22);
      if (!a2 || a2.type !== e22[n22]) return;
    }
    return 1;
  }
  function p(e22, t22) {
    for (var n22 = 1, a2 = s2; a2 < o2.length; a2++) {
      var r22 = o2[a2], i2 = r22.content;
      if ("punctuation" === r22.type && "string" == typeof i2) {
        if (e22.test(i2)) n22++;
        else if (t22.test(i2) && 0 === --n22) return a2;
      }
    }
    return -1;
  }
  function m(e22, t22) {
    var n22 = e22.alias;
    n22 ? Array.isArray(n22) || (e22.alias = n22 = [n22]) : e22.alias = n22 = [], n22.push(t22);
  }
}), function(e2) {
  var t8 = {
    pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
    lookbehind: true,
    inside: {
      "interpolation-punctuation": {
        pattern: /^\$\{?|\}$/,
        alias: "punctuation"
      },
      expression: { pattern: /[\s\S]+/, inside: null }
    }
  };
  e2.languages.groovy = e2.languages.extend("clike", {
    string: {
      pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
      greedy: true
    },
    keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
    number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
    operator: {
      pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
      lookbehind: true
    },
    punctuation: /\.+|[{}[\];(),:$]/
  }), e2.languages.insertBefore("groovy", "string", {
    shebang: { pattern: /#!.+/, alias: "comment", greedy: true },
    "interpolation-string": {
      pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
      greedy: true,
      inside: { interpolation: t8, string: /[\s\S]+/ }
    }
  }), e2.languages.insertBefore("groovy", "punctuation", {
    "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
  }), e2.languages.insertBefore("groovy", "function", {
    annotation: {
      pattern: /(^|[^.])@\w+/,
      lookbehind: true,
      alias: "punctuation"
    }
  }), t8.inside.expression.inside = e2.languages.groovy;
}(Prism), Prism.languages.less = Prism.languages.extend("css", {
  comment: [
    /\/\*[\s\S]*?\*\//,
    { pattern: /(^|[^\\])\/\/.*/, lookbehind: true }
  ],
  atrule: {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: { punctuation: /[:()]/ }
  },
  selector: {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: { variable: /@+[\w-]+/ }
  },
  property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  operator: /[+\-*\/]/
}), Prism.languages.insertBefore("less", "property", {
  variable: [
    { pattern: /@[\w-]+\s*:/, inside: { punctuation: /:/ } },
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
}), Prism.languages.scss = Prism.languages.extend("css", {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  atrule: {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: { rule: /@[\w-]+/ }
  },
  url: /(?:[-a-z]+-)?url(?=\()/i,
  selector: {
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      parent: { pattern: /&/, alias: "important" },
      placeholder: /%[-\w]+/,
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  property: {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ }
  }
}), Prism.languages.insertBefore("scss", "atrule", {
  keyword: [
    /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
    { pattern: /( )(?:from|through)(?= )/, lookbehind: true }
  ]
}), Prism.languages.insertBefore("scss", "important", {
  variable: /\$[-\w]+|#\{\$[-\w]+\}/
}), Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  placeholder: { pattern: /%[-\w]+/, alias: "selector" },
  statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" },
  boolean: /\b(?:false|true)\b/,
  null: { pattern: /\bnull\b/, alias: "keyword" },
  operator: {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
}), Prism.languages.scss.atrule.inside.rest = Prism.languages.scss, function(e2) {
  var n2 = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source, a = /\)|\((?![^|()\n]+\))/.source;
  function t8(e22, t22) {
    return RegExp(
      e22.replace(/<MOD>/g, function() {
        return "(?:" + n2 + ")";
      }).replace(/<PAR>/g, function() {
        return "(?:" + a + ")";
      }),
      t22 || ""
    );
  }
  var r2 = {
    css: { pattern: /\{[^{}]+\}/, inside: { rest: e2.languages.css } },
    "class-id": {
      pattern: /(\()[^()]+(?=\))/,
      lookbehind: true,
      alias: "attr-value"
    },
    lang: {
      pattern: /(\[)[^\[\]]+(?=\])/,
      lookbehind: true,
      alias: "attr-value"
    },
    punctuation: /[\\\/]\d+|\S/
  }, e2 = e2.languages.textile = e2.languages.extend("markup", {
    phrase: {
      pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
      lookbehind: true,
      inside: {
        "block-tag": {
          pattern: t8(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
          inside: {
            modifier: {
              pattern: t8(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
              lookbehind: true,
              inside: r2
            },
            tag: /^[a-z]\w*/,
            punctuation: /\.$/
          }
        },
        list: {
          pattern: t8(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
          inside: {
            modifier: {
              pattern: t8(/(^[*#]+)<MOD>+/.source),
              lookbehind: true,
              inside: r2
            },
            punctuation: /^[*#]+/
          }
        },
        table: {
          pattern: t8(
            /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source,
            "m"
          ),
          inside: {
            modifier: {
              pattern: t8(
                /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
              ),
              lookbehind: true,
              inside: r2
            },
            punctuation: /\||^\./
          }
        },
        inline: {
          pattern: t8(
            /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
          ),
          lookbehind: true,
          inside: {
            bold: {
              pattern: t8(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
              lookbehind: true
            },
            italic: {
              pattern: t8(/(^(__?)<MOD>*).+?(?=\2)/.source),
              lookbehind: true
            },
            cite: {
              pattern: t8(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
              lookbehind: true,
              alias: "string"
            },
            code: {
              pattern: t8(/(^@<MOD>*).+?(?=@)/.source),
              lookbehind: true,
              alias: "keyword"
            },
            inserted: {
              pattern: t8(/(^\+<MOD>*).+?(?=\+)/.source),
              lookbehind: true
            },
            deleted: {
              pattern: t8(/(^-<MOD>*).+?(?=-)/.source),
              lookbehind: true
            },
            span: {
              pattern: t8(/(^%<MOD>*).+?(?=%)/.source),
              lookbehind: true
            },
            modifier: {
              pattern: t8(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
              lookbehind: true,
              inside: r2
            },
            punctuation: /[*_%?@+\-^~]+/
          }
        },
        "link-ref": {
          pattern: /^\[[^\]]+\]\S+$/m,
          inside: {
            string: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true },
            url: { pattern: /(^\])\S+$/, lookbehind: true },
            punctuation: /[\[\]]/
          }
        },
        link: {
          pattern: t8(/"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source),
          inside: {
            text: {
              pattern: t8(/(^"<MOD>*)[^"]+(?=")/.source),
              lookbehind: true
            },
            modifier: {
              pattern: t8(/(^")<MOD>+/.source),
              lookbehind: true,
              inside: r2
            },
            url: { pattern: /(:).+/, lookbehind: true },
            punctuation: /[":]/
          }
        },
        image: {
          pattern: t8(
            /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source
          ),
          inside: {
            source: {
              pattern: t8(
                /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
              ),
              lookbehind: true,
              alias: "url"
            },
            modifier: {
              pattern: t8(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
              lookbehind: true,
              inside: r2
            },
            url: { pattern: /(:).+/, lookbehind: true },
            punctuation: /[!:]/
          }
        },
        footnote: {
          pattern: /\b\[\d+\]/,
          alias: "comment",
          inside: { punctuation: /\[|\]/ }
        },
        acronym: {
          pattern: /\b[A-Z\d]+\([^)]+\)/,
          inside: {
            comment: { pattern: /(\()[^()]+(?=\))/, lookbehind: true },
            punctuation: /[()]/
          }
        },
        mark: {
          pattern: /\b\((?:C|R|TM)\)/,
          alias: "comment",
          inside: { punctuation: /[()]/ }
        }
      }
    }
  }), r2 = e2.phrase.inside, i = {
    inline: r2.inline,
    link: r2.link,
    image: r2.image,
    footnote: r2.footnote,
    acronym: r2.acronym,
    mark: r2.mark
  }, e2 = (e2.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i, r2.inline.inside), e2 = (e2.bold.inside = i, e2.italic.inside = i, e2.inserted.inside = i, e2.deleted.inside = i, e2.span.inside = i, r2.table.inside);
  e2.inline = i.inline, e2.link = i.link, e2.image = i.image, e2.footnote = i.footnote, e2.acronym = i.acronym, e2.mark = i.mark;
}(Prism), function(e2) {
  e2.languages.haml = {
    "multiline-comment": {
      pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
      lookbehind: true,
      alias: "comment"
    },
    "multiline-code": [
      {
        pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
        lookbehind: true,
        inside: e2.languages.ruby
      },
      {
        pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
        lookbehind: true,
        inside: e2.languages.ruby
      }
    ],
    filter: {
      pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
      lookbehind: true,
      inside: { "filter-name": { pattern: /^:[\w-]+/, alias: "symbol" } }
    },
    markup: {
      pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
      lookbehind: true,
      inside: e2.languages.markup
    },
    doctype: { pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/, lookbehind: true },
    tag: {
      pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
      lookbehind: true,
      inside: {
        attributes: [
          {
            pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
            lookbehind: true,
            inside: e2.languages.ruby
          },
          {
            pattern: /\([^)]+\)/,
            inside: {
              "attr-value": {
                pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                lookbehind: true
              },
              "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
              punctuation: /[=(),]/
            }
          },
          { pattern: /\[[^\]]+\]/, inside: e2.languages.ruby }
        ],
        punctuation: /[<>]/
      }
    },
    code: {
      pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
      lookbehind: true,
      inside: e2.languages.ruby
    },
    interpolation: {
      pattern: /#\{[^}]+\}/,
      inside: {
        delimiter: { pattern: /^#\{|\}$/, alias: "punctuation" },
        ruby: { pattern: /[\s\S]+/, inside: e2.languages.ruby }
      }
    },
    punctuation: {
      pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
      lookbehind: true
    }
  };
  for (var t8 = [
    "css",
    { filter: "coffee", language: "coffeescript" },
    "erb",
    "javascript",
    "less",
    "markdown",
    "ruby",
    "scss",
    "textile"
  ], n2 = {}, a = 0, r2 = t8.length; a < r2; a++) {
    var i = t8[a];
    e2.languages[(i = "string" == typeof i ? { filter: i, language: i } : i).language] && (n2["filter-" + i.filter] = {
      pattern: RegExp(
        "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+".replace(
          "{{filter_name}}",
          function() {
            return i.filter;
          }
        )
      ),
      lookbehind: true,
      inside: {
        "filter-name": { pattern: /^:[\w-]+/, alias: "symbol" },
        text: {
          pattern: /[\s\S]+/,
          alias: [i.language, "language-" + i.language],
          inside: e2.languages[i.language]
        }
      }
    });
  }
  e2.languages.insertBefore("haml", "filter", n2);
}(Prism), function(t8) {
  t8.languages.handlebars = {
    comment: /\{\{![\s\S]*?\}\}/,
    delimiter: { pattern: /^\{\{\{?|\}\}\}?$/, alias: "punctuation" },
    string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    boolean: /\b(?:false|true)\b/,
    block: {
      pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
      lookbehind: true,
      alias: "keyword"
    },
    brackets: {
      pattern: /\[[^\]]+\]/,
      inside: { punctuation: /\[|\]/, variable: /[\s\S]+/ }
    },
    punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
    variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
  }, t8.hooks.add("before-tokenize", function(e2) {
    t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "handlebars",
      /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g
    );
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "handlebars");
  }), t8.languages.hbs = t8.languages.handlebars, t8.languages.mustache = t8.languages.handlebars;
}(Prism), Prism.languages.haskell = {
  comment: {
    pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
    lookbehind: true
  },
  char: {
    pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
    alias: "string"
  },
  string: { pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/, greedy: true },
  keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
  "import-statement": {
    pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
    lookbehind: true,
    inside: {
      keyword: /\b(?:as|hiding|import|qualified)\b/,
      punctuation: /\./
    }
  },
  builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
  number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
  operator: [
    { pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/, greedy: true },
    { pattern: /(\s)\.(?=\s)/, lookbehind: true },
    /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
  ],
  hvariable: {
    pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
    inside: { punctuation: /\./ }
  },
  constant: {
    pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
    inside: { punctuation: /\./ }
  },
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.hs = Prism.languages.haskell, Prism.languages.haxe = Prism.languages.extend("clike", {
  string: { pattern: /"(?:[^"\\]|\\[\s\S])*"/, greedy: true },
  "class-name": [
    {
      pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
      lookbehind: true
    },
    /\b[A-Z]\w*/
  ],
  keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
  function: { pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i, greedy: true },
  operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
}), Prism.languages.insertBefore("haxe", "string", {
  "string-interpolation": {
    pattern: /'(?:[^'\\]|\\[\s\S])*'/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{?|\}$/,
            alias: "punctuation"
          },
          expression: { pattern: /[\s\S]+/, inside: Prism.languages.haxe }
        }
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.insertBefore("haxe", "class-name", {
  regex: {
    pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
    greedy: true,
    inside: {
      "regex-flags": /\b[a-z]+$/,
      "regex-source": {
        pattern: /^(~\/)[\s\S]+(?=\/$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^~\/|\/$/
    }
  }
}), Prism.languages.insertBefore("haxe", "keyword", {
  preprocessor: { pattern: /#(?:else|elseif|end|if)\b.*/, alias: "property" },
  metadata: { pattern: /@:?[\w.]+/, alias: "symbol" },
  reification: { pattern: /\$(?:\w+|(?=\{))/, alias: "important" }
}), Prism.languages.hcl = {
  comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
  heredoc: {
    pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
    greedy: true,
    alias: "string"
  },
  keyword: [
    {
      pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
      inside: {
        type: {
          pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
          lookbehind: true,
          alias: "variable"
        }
      }
    },
    {
      pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
      inside: {
        type: {
          pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
          lookbehind: true,
          alias: "variable"
        }
      }
    },
    /[\w-]+(?=\s+\{)/
  ],
  property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
  string: {
    pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
        lookbehind: true,
        inside: {
          type: {
            pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
            lookbehind: true,
            alias: "variable"
          },
          keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
          function: /\w+(?=\()/,
          string: { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true },
          number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
          punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
        }
      }
    }
  },
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
  boolean: /\b(?:false|true)\b/i,
  punctuation: /[=\[\]{}]/
}, Prism.languages.hlsl = Prism.languages.extend("c", {
  "class-name": [
    Prism.languages.c["class-name"],
    /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
  ],
  keyword: [
    /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
    /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
  ],
  number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
  boolean: /\b(?:false|true)\b/
}), Prism.languages.hoon = {
  comment: { pattern: /::.*/, greedy: true },
  string: { pattern: /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/, greedy: true },
  constant: /%(?:\.[ny]|[\w-]+)/,
  "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
  function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
  keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
}, Prism.languages.hpkp = {
  directive: {
    pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
    alias: "property"
  },
  operator: /=/,
  punctuation: /;/
}, Prism.languages.hsts = {
  directive: {
    pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
    alias: "property"
  },
  operator: /=/,
  punctuation: /;/
}, Prism.languages.json = {
  property: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true },
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  punctuation: /[{}[\],]/,
  operator: /:/,
  boolean: /\b(?:false|true)\b/,
  null: { pattern: /\bnull\b/, alias: "keyword" }
}, Prism.languages.webmanifest = Prism.languages.json, Prism.languages.uri = {
  scheme: {
    pattern: /^[a-z][a-z0-9+.-]*:/im,
    greedy: true,
    inside: { "scheme-delimiter": /:$/ }
  },
  fragment: {
    pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
    inside: { "fragment-delimiter": /^#/ }
  },
  query: {
    pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
    inside: {
      "query-delimiter": { pattern: /^\?/, greedy: true },
      "pair-delimiter": /[&;]/,
      pair: {
        pattern: /^[^=][\s\S]*/,
        inside: {
          key: /^[^=]+/,
          value: { pattern: /(^=)[\s\S]+/, lookbehind: true }
        }
      }
    }
  },
  authority: {
    pattern: RegExp(
      /^\/\//.source + /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + "(?:" + /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + /[\w\-.~!$&'()*+,;=%]*/.source + ")" + /(?::\d*)?/.source,
      "m"
    ),
    inside: {
      "authority-delimiter": /^\/\//,
      "user-info-segment": {
        pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
        inside: {
          "user-info-delimiter": /@$/,
          "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
        }
      },
      "port-segment": {
        pattern: /:\d*$/,
        inside: { "port-delimiter": /^:/, port: /^\d+/ }
      },
      host: {
        pattern: /[\s\S]+/,
        inside: {
          "ip-literal": {
            pattern: /^\[[\s\S]+\]$/,
            inside: {
              "ip-literal-delimiter": /^\[|\]$/,
              "ipv-future": /^v[\s\S]+/,
              "ipv6-address": /^[\s\S]+/
            }
          },
          "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
        }
      }
    }
  },
  path: {
    pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
    inside: { "path-separator": /\// }
  }
}, Prism.languages.url = Prism.languages.uri, function(e2) {
  function t8(e22) {
    return RegExp("(^(?:" + e22 + "):[ 	]*(?![ 	]))[^]+", "i");
  }
  e2.languages.http = {
    "request-line": {
      pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
      inside: {
        method: { pattern: /^[A-Z]+\b/, alias: "property" },
        "request-target": {
          pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
          lookbehind: true,
          alias: "url",
          inside: e2.languages.uri
        },
        "http-version": {
          pattern: /^(\s)HTTP\/[\d.]+/,
          lookbehind: true,
          alias: "property"
        }
      }
    },
    "response-status": {
      pattern: /^HTTP\/[\d.]+ \d+ .+/m,
      inside: {
        "http-version": { pattern: /^HTTP\/[\d.]+/, alias: "property" },
        "status-code": {
          pattern: /^(\s)\d+(?=\s)/,
          lookbehind: true,
          alias: "number"
        },
        "reason-phrase": {
          pattern: /^(\s).+/,
          lookbehind: true,
          alias: "string"
        }
      }
    },
    header: {
      pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
      inside: {
        "header-value": [
          {
            pattern: t8(/Content-Security-Policy/.source),
            lookbehind: true,
            alias: ["csp", "languages-csp"],
            inside: e2.languages.csp
          },
          {
            pattern: t8(/Public-Key-Pins(?:-Report-Only)?/.source),
            lookbehind: true,
            alias: ["hpkp", "languages-hpkp"],
            inside: e2.languages.hpkp
          },
          {
            pattern: t8(/Strict-Transport-Security/.source),
            lookbehind: true,
            alias: ["hsts", "languages-hsts"],
            inside: e2.languages.hsts
          },
          { pattern: t8(/[^:]+/.source), lookbehind: true }
        ],
        "header-name": { pattern: /^[^:]+/, alias: "keyword" },
        punctuation: /^:/
      }
    }
  };
  var n2, a, r2, i, o2 = e2.languages, s2 = {
    "application/javascript": o2.javascript,
    "application/json": o2.json || o2.javascript,
    "application/xml": o2.xml,
    "text/xml": o2.xml,
    "text/html": o2.html,
    "text/css": o2.css,
    "text/plain": o2.plain
  }, l2 = { "application/json": true, "application/xml": true };
  for (n2 in s2)
    s2[n2] && (a = a || {}, r2 = l2[n2] ? (i = void 0, i = (r2 = n2).replace(/^[a-z]+\//, ""), "(?:" + r2 + "|" + ("\\w+/(?:[\\w.-]+\\+)+" + i + "(?![+\\w.-])") + ")") : n2, a[n2.replace(/\//g, "-")] = {
      pattern: RegExp(
        "(" + /content-type:\s*/.source + r2 + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + /[^ \t\w-][\s\S]*/.source,
        "i"
      ),
      lookbehind: true,
      inside: s2[n2]
    });
  a && e2.languages.insertBefore("http", "header", a);
}(Prism), Prism.languages.ichigojam = {
  comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
  string: { pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/, greedy: true },
  number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
  function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
  label: /(?:\B@\S+)/,
  operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
  punctuation: /[\[,;:()\]]/
}, Prism.languages.icon = {
  comment: /#.*/,
  string: {
    pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
    greedy: true
  },
  number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
  "builtin-keyword": {
    pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
    alias: "variable"
  },
  directive: { pattern: /\$\w+/, alias: "builtin" },
  keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
  function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
  operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
  punctuation: /[\[\](){},;]/
}, function(e2) {
  function n2(e22, t22) {
    return t22 <= 0 ? /[]/.source : e22.replace(/<SELF>/g, function() {
      return n2(e22, t22 - 1);
    });
  }
  var t8 = /'[{}:=,](?:[^']|'')*'(?!')/, a = { pattern: /''/, greedy: true, alias: "operator" }, r2 = { pattern: t8, greedy: true, inside: { escape: a } }, i = n2(
    /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
      /<STR>/g,
      function() {
        return t8.source;
      }
    ),
    8
  ), o2 = {
    pattern: RegExp(i),
    inside: {
      message: {
        pattern: /^(\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: null
      },
      "message-delimiter": { pattern: /./, alias: "punctuation" }
    }
  };
  e2.languages["icu-message-format"] = {
    argument: {
      pattern: RegExp(i),
      greedy: true,
      inside: {
        content: {
          pattern: /^(\{)[\s\S]+(?=\}$)/,
          lookbehind: true,
          inside: {
            "argument-name": { pattern: /^(\s*)[^{}:=,\s]+/, lookbehind: true },
            "choice-style": {
              pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
              lookbehind: true,
              inside: {
                punctuation: /\|/,
                range: {
                  pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                  lookbehind: true,
                  inside: { operator: /[<#\u2264]/, number: /\S+/ }
                },
                rest: null
              }
            },
            "plural-style": {
              pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
              lookbehind: true,
              inside: {
                offset: /^offset:\s*\d+/,
                "nested-message": o2,
                selector: {
                  pattern: /=\d+|[^{}:=,\s]+/,
                  inside: { keyword: /^(?:few|many|one|other|two|zero)$/ }
                }
              }
            },
            "select-style": {
              pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
              lookbehind: true,
              inside: {
                "nested-message": o2,
                selector: {
                  pattern: /[^{}:=,\s]+/,
                  inside: { keyword: /^other$/ }
                }
              }
            },
            keyword: /\b(?:choice|plural|select|selectordinal)\b/,
            "arg-type": {
              pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
              alias: "keyword"
            },
            "arg-skeleton": {
              pattern: /(,\s*)::[^{}:=,\s]+/,
              lookbehind: true
            },
            "arg-style": {
              pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
              lookbehind: true
            },
            "arg-style-text": {
              pattern: RegExp(
                /(^\s*,\s*(?=\S))/.source + n2(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
              ),
              lookbehind: true,
              alias: "string"
            },
            punctuation: /,/
          }
        },
        "argument-delimiter": { pattern: /./, alias: "operator" }
      }
    },
    escape: a,
    string: r2
  }, o2.inside.message.inside = e2.languages["icu-message-format"], e2.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = e2.languages["icu-message-format"];
}(Prism), Prism.languages.idris = Prism.languages.extend("haskell", {
  comment: { pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m },
  keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
  builtin: void 0
}), Prism.languages.insertBefore("idris", "keyword", {
  "import-statement": {
    pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
    lookbehind: true,
    inside: { punctuation: /\./ }
  }
}), Prism.languages.idr = Prism.languages.idris, function(e2) {
  e2.languages.ignore = {
    comment: /^#.*/m,
    entry: {
      pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
      alias: "string",
      inside: {
        operator: /^!|\*\*?|\?/,
        regex: { pattern: /(^|[^\\])\[[^\[\]]*\]/, lookbehind: true },
        punctuation: /\//
      }
    }
  }, e2.languages.gitignore = e2.languages.ignore, e2.languages.hgignore = e2.languages.ignore, e2.languages.npmignore = e2.languages.ignore;
}(Prism), Prism.languages.inform7 = {
  string: {
    pattern: /"[^"]*"/,
    inside: {
      substitution: {
        pattern: /\[[^\[\]]+\]/,
        inside: { delimiter: { pattern: /\[|\]/, alias: "punctuation" } }
      }
    }
  },
  comment: { pattern: /\[[^\[\]]+\]/, greedy: true },
  title: {
    pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
    alias: "important"
  },
  number: {
    pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
    lookbehind: true
  },
  verb: {
    pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
    lookbehind: true,
    alias: "operator"
  },
  keyword: {
    pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
    lookbehind: true
  },
  property: {
    pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
    lookbehind: true,
    alias: "symbol"
  },
  position: {
    pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
    lookbehind: true,
    alias: "keyword"
  },
  type: {
    pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
    lookbehind: true,
    alias: "variable"
  },
  punctuation: /[.,:;(){}]/
}, Prism.languages.inform7.string.inside.substitution.inside.rest = Prism.languages.inform7, Prism.languages.inform7.string.inside.substitution.inside.rest.text = {
  pattern: /\S(?:\s*\S)*/,
  alias: "comment"
}, Prism.languages.ini = {
  comment: { pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m, lookbehind: true },
  section: {
    pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
    lookbehind: true,
    inside: {
      "section-name": {
        pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
        lookbehind: true,
        alias: "selector"
      },
      punctuation: /\[|\]/
    }
  },
  key: {
    pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
    lookbehind: true,
    alias: "attr-name"
  },
  value: {
    pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
    lookbehind: true,
    alias: "attr-value",
    inside: { "inner-value": { pattern: /^("|').+(?=\1$)/, lookbehind: true } }
  },
  punctuation: /=/
}, Prism.languages.io = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
    lookbehind: true,
    greedy: true
  },
  "triple-quoted-string": {
    pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
    greedy: true,
    alias: "string"
  },
  string: { pattern: /"(?:\\.|[^\\\r\n"])*"/, greedy: true },
  keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
  builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
  boolean: /\b(?:false|nil|true)\b/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
  operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.j = {
  comment: { pattern: /\bNB\..*/, greedy: true },
  string: { pattern: /'(?:''|[^'\r\n])*'/, greedy: true },
  keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
  verb: {
    pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
    alias: "keyword"
  },
  number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
  adverb: { pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/, alias: "builtin" },
  operator: /[=a][.:]|_\./,
  conjunction: {
    pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
    alias: "variable"
  },
  punctuation: /[()]/
}, function(e2) {
  var t8 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, n2 = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, a = {
    pattern: RegExp(
      /(^|[^\w.])/.source + n2 + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source
    ),
    lookbehind: true,
    inside: {
      namespace: {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: { punctuation: /\./ }
      },
      punctuation: /\./
    }
  };
  e2.languages.java = e2.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      a,
      {
        pattern: RegExp(
          /(^|[^\w.])/.source + n2 + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source
        ),
        lookbehind: true,
        inside: a.inside
      },
      {
        pattern: RegExp(
          /(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n2 + /[A-Z]\w*\b/.source
        ),
        lookbehind: true,
        inside: a.inside
      }
    ],
    keyword: t8,
    function: [
      e2.languages.clike.function,
      { pattern: /(::\s*)[a-z_]\w*/, lookbehind: true }
    ],
    number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    constant: /\b[A-Z][A-Z_\d]+\b/
  }), e2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    char: { pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/, greedy: true }
  }), e2.languages.insertBefore("java", "class-name", {
    annotation: {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    generics: {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": a,
        keyword: t8,
        punctuation: /[<>(),.:]/,
        operator: /[?&|]/
      }
    },
    import: [
      {
        pattern: RegExp(
          /(\bimport\s+)/.source + n2 + /(?:[A-Z]\w*|\*)(?=\s*;)/.source
        ),
        lookbehind: true,
        inside: {
          namespace: a.inside.namespace,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(
          /(\bimport\s+static\s+)/.source + n2 + /(?:\w+|\*)(?=\s*;)/.source
        ),
        lookbehind: true,
        alias: "static",
        inside: {
          namespace: a.inside.namespace,
          static: /\b\w+$/,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      }
    ],
    namespace: {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
          /<keyword>/g,
          function() {
            return t8.source;
          }
        )
      ),
      lookbehind: true,
      inside: { punctuation: /\./ }
    }
  });
}(Prism), Prism.languages.scala = Prism.languages.extend("java", {
  "triple-quoted-string": {
    pattern: /"""[\s\S]*?"""/,
    greedy: true,
    alias: "string"
  },
  string: { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
  number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
  builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
  symbol: /'[^\d\s\\]\w*/
}), Prism.languages.insertBefore("scala", "triple-quoted-string", {
  "string-interpolation": {
    pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
    greedy: true,
    inside: {
      id: { pattern: /^\w+/, greedy: true, alias: "function" },
      escape: { pattern: /\\\$"|\$[$"]/, greedy: true, alias: "symbol" },
      interpolation: {
        pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
        greedy: true,
        inside: {
          punctuation: /^\$\{?|\}$/,
          expression: { pattern: /[\s\S]+/, inside: Prism.languages.scala }
        }
      },
      string: /[\s\S]+/
    }
  }
}), delete Prism.languages.scala["class-name"], delete Prism.languages.scala.function, delete Prism.languages.scala.constant, function(l2) {
  var e2 = l2.languages.javadoclike = {
    parameter: {
      pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
      lookbehind: true
    },
    keyword: {
      pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
      lookbehind: true
    },
    punctuation: /[{}]/
  };
  Object.defineProperty(e2, "addSupport", {
    value: function(e22, s2) {
      (e22 = "string" == typeof e22 ? [e22] : e22).forEach(function(e3) {
        var t8 = function(e4) {
          e4.inside || (e4.inside = {}), e4.inside.rest = s2;
        }, n2 = "doc-comment";
        if (a = l2.languages[e3]) {
          var a, r2 = a[n2];
          if ((r2 = r2 ? r2 : (a = l2.languages.insertBefore(e3, "comment", {
            "doc-comment": {
              pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              alias: "comment"
            }
          }))[n2]) instanceof RegExp && (r2 = a[n2] = { pattern: r2 }), Array.isArray(r2))
            for (var i = 0, o2 = r2.length; i < o2; i++)
              r2[i] instanceof RegExp && (r2[i] = { pattern: r2[i] }), t8(r2[i]);
          else t8(r2);
        }
      });
    }
  }), e2.addSupport(["java", "javascript", "php"], e2);
}(Prism), function(e2) {
  var t8 = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m, n2 = /#\s*\w+(?:\s*\([^()]*\))?/.source, a = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
    /<mem>/g,
    function() {
      return n2;
    }
  );
  e2.languages.javadoc = e2.languages.extend("javadoclike", {}), e2.languages.insertBefore("javadoc", "keyword", {
    reference: {
      pattern: RegExp(
        /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + a + ")"
      ),
      lookbehind: true,
      inside: {
        function: { pattern: /(#\s*)\w+(?=\s*\()/, lookbehind: true },
        field: { pattern: /(#\s*)\w+/, lookbehind: true },
        namespace: {
          pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
          inside: { punctuation: /\./ }
        },
        "class-name": /\b[A-Z]\w*/,
        keyword: e2.languages.java.keyword,
        punctuation: /[#()[\],.]/
      }
    },
    "class-name": {
      pattern: /(@param\s+)<[A-Z]\w*>/,
      lookbehind: true,
      inside: { punctuation: /[.<>]/ }
    },
    "code-section": [
      {
        pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
        lookbehind: true,
        inside: {
          code: {
            pattern: t8,
            lookbehind: true,
            inside: e2.languages.java,
            alias: "language-java"
          }
        }
      },
      {
        pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
        lookbehind: true,
        inside: {
          line: {
            pattern: t8,
            lookbehind: true,
            inside: {
              tag: e2.languages.markup.tag,
              entity: e2.languages.markup.entity,
              code: {
                pattern: /.+/,
                inside: e2.languages.java,
                alias: "language-java"
              }
            }
          }
        }
      }
    ],
    tag: e2.languages.markup.tag,
    entity: e2.languages.markup.entity
  }), e2.languages.javadoclike.addSupport("java", e2.languages.javadoc);
}(Prism), Prism.languages.javastacktrace = {
  summary: {
    pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
    lookbehind: true,
    inside: {
      keyword: {
        pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
        lookbehind: true
      },
      string: { pattern: /^(\s*)"[^"]*"/, lookbehind: true },
      exceptions: {
        pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
        lookbehind: true,
        inside: {
          "class-name": /[\w$]+$/,
          namespace: /\b[a-z]\w*\b/,
          punctuation: /\./
        }
      },
      message: { pattern: /(:\s*)\S.*/, lookbehind: true, alias: "string" },
      punctuation: /:/
    }
  },
  "stack-frame": {
    pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
    lookbehind: true,
    inside: {
      keyword: { pattern: /^(\s*)at(?= )/, lookbehind: true },
      source: [
        {
          pattern: /(\()\w+\.\w+:\d+(?=\))/,
          lookbehind: true,
          inside: {
            file: /^\w+\.\w+/,
            punctuation: /:/,
            "line-number": { pattern: /\b\d+\b/, alias: "number" }
          }
        },
        {
          pattern: /(\()[^()]*(?=\))/,
          lookbehind: true,
          inside: { keyword: /^(?:Native Method|Unknown Source)$/ }
        }
      ],
      "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
      function: /(?:<init>|[\w$]+)(?=\()/,
      "class-loader": {
        pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
        lookbehind: true,
        alias: "namespace",
        inside: { punctuation: /\./ }
      },
      module: {
        pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
        lookbehind: true,
        inside: {
          version: { pattern: /(@)[\s\S]+/, lookbehind: true, alias: "number" },
          punctuation: /[@.]/
        }
      },
      namespace: {
        pattern: /(?:\b[a-z]\w*\.)+/,
        inside: { punctuation: /\./ }
      },
      punctuation: /[()/.]/
    }
  },
  more: {
    pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
    lookbehind: true,
    inside: {
      punctuation: /\.{3}/,
      number: /\d+/,
      keyword: /\b[a-z]+(?: [a-z]+)*\b/
    }
  }
}, Prism.languages.jexl = {
  string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
  transform: {
    pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
    alias: "function",
    lookbehind: true
  },
  function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
  number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
  operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
  boolean: /\b(?:false|true)\b/,
  keyword: /\bin\b/,
  punctuation: /[{}[\](),.]/
}, Prism.languages.jolie = Prism.languages.extend("clike", {
  string: {
    pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
    lookbehind: true,
    greedy: true
  },
  "class-name": {
    pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
    lookbehind: true
  },
  keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
  function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
  operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
  punctuation: /[()[\]{},;.:]/,
  builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
}), Prism.languages.insertBefore("jolie", "keyword", {
  aggregates: {
    pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
    lookbehind: true,
    inside: { keyword: /\bwith\b/, "class-name": /\w+/, punctuation: /,/ }
  },
  redirects: {
    pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
    lookbehind: true,
    inside: { punctuation: /,/, "class-name": /\w+/, operator: /=>/ }
  },
  property: {
    pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
  }
}), function(e2) {
  var t8 = /\\\((?:[^()]|\([^()]*\))*\)/.source, n2 = RegExp(
    /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
      /__/g,
      function() {
        return t8;
      }
    )
  ), a = {
    interpolation: {
      pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + t8),
      lookbehind: true,
      inside: {
        content: {
          pattern: /^(\\\()[\s\S]+(?=\)$)/,
          lookbehind: true,
          inside: null
        },
        punctuation: /^\\\(|\)$/
      }
    }
  }, e2 = e2.languages.jq = {
    comment: /#.*/,
    property: {
      pattern: RegExp(n2.source + /(?=\s*:(?!:))/.source),
      lookbehind: true,
      greedy: true,
      inside: a
    },
    string: { pattern: n2, lookbehind: true, greedy: true, inside: a },
    function: { pattern: /(\bdef\s+)[a-z_]\w+/i, lookbehind: true },
    variable: /\B\$\w+/,
    "property-literal": {
      pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
      alias: "property"
    },
    keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
    operator: [
      { pattern: /\|=?/, alias: "pipe" },
      /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
    ],
    "c-style-function": {
      pattern: /\b[a-z_]\w*(?=\s*\()/i,
      alias: "function"
    },
    punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
    dot: { pattern: /\./, alias: "important" }
  };
  a.interpolation.inside.content.inside = e2;
}(Prism), function(g2) {
  var e2 = g2.languages.javascript["template-string"], n2 = e2.pattern.source, b3 = e2.inside.interpolation, E2 = b3.inside["interpolation-punctuation"], i = b3.pattern.source;
  function t8(e22, t22) {
    if (g2.languages[e22])
      return {
        pattern: RegExp("((?:" + t22 + ")\\s*)" + n2),
        lookbehind: true,
        greedy: true,
        inside: {
          "template-punctuation": { pattern: /^`|`$/, alias: "string" },
          "embedded-code": { pattern: /[\s\S]+/, alias: e22 }
        }
      };
  }
  function f(e22, t22, n22) {
    e22 = { code: e22, grammar: t22, language: n22 };
    return g2.hooks.run("before-tokenize", e22), e22.tokens = g2.tokenize(e22.code, e22.grammar), g2.hooks.run("after-tokenize", e22), e22.tokens;
  }
  function l2(a2, e22, r2) {
    var t22 = g2.tokenize(a2, {
      interpolation: { pattern: RegExp(i), lookbehind: true }
    }), u = 0, p = {}, t22 = f(
      t22.map(function(e3) {
        if ("string" == typeof e3) return e3;
        for (var t32, n22, e3 = e3.content; -1 !== a2.indexOf(
          (n22 = u++, t32 = "___" + r2.toUpperCase() + "_" + n22 + "___")
        ); ) ;
        return p[t32] = e3, t32;
      }).join(""),
      e22,
      r2
    ), m = Object.keys(p);
    return u = 0, function e3(t32) {
      for (var n22 = 0; n22 < t32.length; n22++) {
        if (u >= m.length) return;
        var a3, r22, i2, o2, s2, l22, d22, c2 = t32[n22];
        "string" == typeof c2 || "string" == typeof c2.content ? (a3 = m[u], -1 !== (d22 = (l22 = "string" == typeof c2 ? c2 : c2.content).indexOf(a3)) && (++u, r22 = l22.substring(0, d22), s2 = p[a3], i2 = void 0, (o2 = {})["interpolation-punctuation"] = E2, 3 === (o2 = g2.tokenize(s2, o2)).length && ((i2 = [1, 1]).push.apply(
          i2,
          f(o2[1], g2.languages.javascript, "javascript")
        ), o2.splice.apply(o2, i2)), i2 = new g2.Token("interpolation", o2, b3.alias, s2), o2 = l22.substring(d22 + a3.length), s2 = [], r22 && s2.push(r22), s2.push(i2), o2 && (e3(l22 = [o2]), s2.push.apply(s2, l22)), "string" == typeof c2 ? (t32.splice.apply(t32, [n22, 1].concat(s2)), n22 += s2.length - 1) : c2.content = s2)) : (d22 = c2.content, Array.isArray(d22) ? e3(d22) : e3([d22]));
      }
    }(t22), new g2.Token(r2, t22, "language-" + r2, a2);
  }
  g2.languages.javascript["template-string"] = [
    t8(
      "css",
      /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source
    ),
    t8("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
    t8("svg", /\bsvg/.source),
    t8("markdown", /\b(?:markdown|md)/.source),
    t8("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
    t8("sql", /\bsql/.source),
    e2
  ].filter(Boolean);
  var a = {
    javascript: true,
    js: true,
    typescript: true,
    ts: true,
    jsx: true,
    tsx: true
  };
  function d2(e22) {
    return "string" == typeof e22 ? e22 : Array.isArray(e22) ? e22.map(d2).join("") : d2(e22.content);
  }
  g2.hooks.add("after-tokenize", function(e22) {
    e22.language in a && !function e3(t22) {
      for (var n22 = 0, a2 = t22.length; n22 < a2; n22++) {
        var r2, i2, o2, s2 = t22[n22];
        "string" != typeof s2 && (r2 = s2.content, Array.isArray(r2) ? "template-string" === s2.type ? (s2 = r2[1], 3 === r2.length && "string" != typeof s2 && "embedded-code" === s2.type && (i2 = d2(s2), s2 = s2.alias, s2 = Array.isArray(s2) ? s2[0] : s2, o2 = g2.languages[s2]) && (r2[1] = l2(i2, o2, s2))) : e3(r2) : "string" != typeof r2 && e3([r2]));
      }
    }(e22.tokens);
  });
}(Prism), function(e2) {
  e2.languages.typescript = e2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  }), e2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    /\btype\b(?=\s*(?:[\{*]|$))/
  ), delete e2.languages.typescript.parameter, delete e2.languages.typescript["literal-property"];
  var t8 = e2.languages.extend("typescript", {});
  delete t8["class-name"], e2.languages.typescript["class-name"].inside = t8, e2.languages.insertBefore("typescript", "function", {
    decorator: {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        at: { pattern: /^@/, alias: "operator" },
        function: /^[\s\S]+/
      }
    },
    "generic-function": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t8 }
      }
    }
  }), e2.languages.ts = e2.languages.typescript;
}(Prism), function(e2) {
  var t8 = e2.languages.javascript, n2 = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a = "(@(?:arg|argument|param|property)\\s+(?:" + n2 + "\\s+)?)";
  e2.languages.jsdoc = e2.languages.extend("javadoclike", {
    parameter: {
      pattern: RegExp(a + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),
      lookbehind: true,
      inside: { punctuation: /\./ }
    }
  }), e2.languages.insertBefore("jsdoc", "keyword", {
    "optional-parameter": {
      pattern: RegExp(
        a + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
      ),
      lookbehind: true,
      inside: {
        parameter: {
          pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
          lookbehind: true,
          inside: { punctuation: /\./ }
        },
        code: {
          pattern: /(=)[\s\S]*(?=\]$)/,
          lookbehind: true,
          inside: t8,
          alias: "language-javascript"
        },
        punctuation: /[=[\]]/
      }
    },
    "class-name": [
      {
        pattern: RegExp(
          /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
            /<TYPE>/g,
            function() {
              return n2;
            }
          )
        ),
        lookbehind: true,
        inside: { punctuation: /\./ }
      },
      {
        pattern: RegExp("(@[a-z]+\\s+)" + n2),
        lookbehind: true,
        inside: {
          string: t8.string,
          number: t8.number,
          boolean: t8.boolean,
          keyword: e2.languages.typescript.keyword,
          operator: /=>|\.\.\.|[&|?:*]/,
          punctuation: /[.,;=<>{}()[\]]/
        }
      }
    ],
    example: {
      pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
      lookbehind: true,
      inside: {
        code: {
          pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
          lookbehind: true,
          inside: t8,
          alias: "language-javascript"
        }
      }
    }
  }), e2.languages.javadoclike.addSupport("javascript", e2.languages.jsdoc);
}(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", {
  keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
}), Prism.languages.insertBefore("n4js", "constant", {
  annotation: { pattern: /@+\w+/, alias: "operator" }
}), Prism.languages.n4jsd = Prism.languages.n4js, function(e2) {
  function t8(e22, t22) {
    return RegExp(
      e22.replace(/<ID>/g, function() {
        return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
      }),
      t22
    );
  }
  e2.languages.insertBefore("javascript", "function-variable", {
    "method-variable": {
      pattern: RegExp(
        "(\\.\\s*)" + e2.languages.javascript["function-variable"].pattern.source
      ),
      lookbehind: true,
      alias: ["function-variable", "method", "function", "property-access"]
    }
  }), e2.languages.insertBefore("javascript", "function", {
    method: {
      pattern: RegExp("(\\.\\s*)" + e2.languages.javascript.function.source),
      lookbehind: true,
      alias: ["function", "property-access"]
    }
  }), e2.languages.insertBefore("javascript", "constant", {
    "known-class-name": [
      {
        pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
        alias: "class-name"
      },
      { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }
    ]
  }), e2.languages.insertBefore("javascript", "keyword", {
    imports: {
      pattern: t8(
        /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
      ),
      lookbehind: true,
      inside: e2.languages.javascript
    },
    exports: {
      pattern: t8(
        /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
      ),
      lookbehind: true,
      inside: e2.languages.javascript
    }
  }), e2.languages.javascript.keyword.unshift(
    { pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" },
    {
      pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
      alias: "control-flow"
    },
    { pattern: /\bnull\b/, alias: ["null", "nil"] },
    { pattern: /\bundefined\b/, alias: "nil" }
  ), e2.languages.insertBefore("javascript", "operator", {
    spread: { pattern: /\.{3}/, alias: "operator" },
    arrow: { pattern: /=>/, alias: "operator" }
  }), e2.languages.insertBefore("javascript", "punctuation", {
    "property-access": {
      pattern: t8(/(\.\s*)#?<ID>/.source),
      lookbehind: true
    },
    "maybe-class-name": {
      pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
      lookbehind: true
    },
    dom: {
      pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
      alias: "variable"
    },
    console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" }
  });
  for (var n2 = [
    "function",
    "function-variable",
    "method",
    "method-variable",
    "property-access"
  ], a = 0; a < n2.length; a++) {
    var r2 = n2[a], i = e2.languages.javascript[r2], r2 = (i = "RegExp" === e2.util.type(i) ? e2.languages.javascript[r2] = { pattern: i } : i).inside || {};
    (i.inside = r2)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(Prism), function(e2) {
  var t8 = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
  e2.languages.json5 = e2.languages.extend("json", {
    property: [
      { pattern: RegExp(t8.source + "(?=\\s*:)"), greedy: true },
      {
        pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
        alias: "unquoted"
      }
    ],
    string: { pattern: t8, greedy: true },
    number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
  });
}(Prism), Prism.languages.jsonp = Prism.languages.extend("json", {
  punctuation: /[{}[\]();,.]/
}), Prism.languages.insertBefore("jsonp", "punctuation", {
  function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
}), Prism.languages.jsstacktrace = {
  "error-message": { pattern: /^\S.*/m, alias: "string" },
  "stack-frame": {
    pattern: /(^[ \t]+)at[ \t].*/m,
    lookbehind: true,
    inside: {
      "not-my-code": {
        pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
        alias: "comment"
      },
      filename: {
        pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
        lookbehind: true,
        alias: "url"
      },
      function: {
        pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
        lookbehind: true,
        inside: { punctuation: /\./ }
      },
      punctuation: /[()]/,
      keyword: /\b(?:at|new)\b/,
      alias: {
        pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
        alias: "variable"
      },
      "line-number": {
        pattern: /:\d+(?::\d+)?\b/,
        alias: "number",
        inside: { punctuation: /:/ }
      }
    }
  }
}, Prism.languages.julia = {
  comment: {
    pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
    lookbehind: true
  },
  regex: { pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/, greedy: true },
  string: {
    pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
    greedy: true
  },
  char: {
    pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
  boolean: /\b(?:false|true)\b/,
  number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
  operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
  punctuation: /::?|[{}[\]();,.?]/,
  constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
}, Prism.languages.keepalived = {
  comment: { pattern: /[#!].*/, greedy: true },
  string: {
    pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
    lookbehind: true,
    greedy: true
  },
  ip: {
    pattern: RegExp(
      /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
        /<ipv4>/g,
        function() {
          return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
        }
      ),
      "i"
    ),
    alias: "number"
  },
  path: {
    pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
    lookbehind: true,
    alias: "string"
  },
  variable: /\$\{?\w+\}?/,
  email: { pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/, alias: "string" },
  "conditional-configuration": { pattern: /@\^?[\w-]+/, alias: "variable" },
  operator: /=/,
  property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
  constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
  number: { pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/, lookbehind: true },
  boolean: /\b(?:false|no|off|on|true|yes)\b/,
  punctuation: /[\{\}]/
}, Prism.languages.keyman = {
  comment: { pattern: /\bc .*/i, greedy: true },
  string: { pattern: /"[^"\r\n]*"|'[^'\r\n]*'/, greedy: true },
  "virtual-key": {
    pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
    greedy: true,
    alias: "function"
  },
  "header-keyword": { pattern: /&\w+/, alias: "bold" },
  "header-statement": {
    pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
    alias: "bold"
  },
  "rule-keyword": {
    pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
    alias: "keyword"
  },
  "structural-keyword": {
    pattern: /\b(?:ansi|begin|group|match|newcontext|nomatch|postkeystroke|readonly|unicode|using keys)\b/i,
    alias: "keyword"
  },
  "compile-target": {
    pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
    alias: "property"
  },
  number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
  operator: /[+>\\$]|\.\./,
  punctuation: /[()=,]/
}, function(e2) {
  e2.languages.kotlin = e2.languages.extend("clike", {
    keyword: {
      pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
      lookbehind: true
    },
    function: [
      { pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true },
      {
        pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
        lookbehind: true,
        greedy: true
      }
    ],
    number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
    operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
  }), delete e2.languages.kotlin["class-name"];
  var t8 = {
    "interpolation-punctuation": {
      pattern: /^\$\{?|\}$/,
      alias: "punctuation"
    },
    expression: { pattern: /[\s\S]+/, inside: e2.languages.kotlin }
  };
  e2.languages.insertBefore("kotlin", "string", {
    "string-literal": [
      {
        pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
        alias: "multiline",
        inside: {
          interpolation: {
            pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
            inside: t8
          },
          string: /[\s\S]+/
        }
      },
      {
        pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
        alias: "singleline",
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
            lookbehind: true,
            inside: t8
          },
          string: /[\s\S]+/
        }
      }
    ],
    char: {
      pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
      greedy: true
    }
  }), delete e2.languages.kotlin.string, e2.languages.insertBefore("kotlin", "keyword", {
    annotation: {
      pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
      alias: "builtin"
    }
  }), e2.languages.insertBefore("kotlin", "function", {
    label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" }
  }), e2.languages.kt = e2.languages.kotlin, e2.languages.kts = e2.languages.kotlin;
}(Prism), function(e2) {
  var n2 = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
  function t8(e22, t22) {
    return RegExp(e22.replace(/<nonId>/g, n2), t22);
  }
  e2.languages.kumir = {
    comment: { pattern: /\|.*/ },
    prolog: { pattern: /#.*/, greedy: true },
    string: { pattern: /"[^\n\r"]*"|'[^\n\r']*'/, greedy: true },
    boolean: {
      pattern: t8(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
      lookbehind: true
    },
    "operator-word": {
      pattern: t8(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
      lookbehind: true,
      alias: "keyword"
    },
    "system-variable": {
      pattern: t8(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
      lookbehind: true,
      alias: "keyword"
    },
    type: [
      {
        pattern: t8(
          /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source
        ),
        lookbehind: true,
        alias: "builtin"
      },
      {
        pattern: t8(
          /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
        ),
        lookbehind: true,
        alias: "important"
      }
    ],
    keyword: {
      pattern: t8(
        /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source
      ),
      lookbehind: true
    },
    name: {
      pattern: t8(
        /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
      ),
      lookbehind: true
    },
    number: {
      pattern: t8(
        /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
        "i"
      ),
      lookbehind: true
    },
    punctuation: /:=|[(),:;\[\]]/,
    "operator-char": {
      pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
      alias: "operator"
    }
  }, e2.languages.kum = e2.languages.kumir;
}(Prism), Prism.languages.kusto = {
  comment: { pattern: /\/\/.*/, greedy: true },
  string: {
    pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
    greedy: true
  },
  verb: { pattern: /(\|\s*)[a-z][\w-]*/i, lookbehind: true, alias: "keyword" },
  command: { pattern: /\.[a-z][a-z\d-]*\b/, alias: "keyword" },
  "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
  keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
  boolean: /\b(?:false|null|true)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/,
  datetime: [
    {
      pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
      alias: "number"
    },
    {
      pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
      alias: "number"
    }
  ],
  number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
  operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
  punctuation: /[()\[\]{},;.:]/
}, function(e2) {
  var t8 = /\\(?:[^a-z()[\]]|[a-z*]+)/i, n2 = { "equation-command": { pattern: t8, alias: "regex" } };
  e2.languages.latex = {
    comment: /%.*/,
    cdata: {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true
    },
    equation: [
      {
        pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
        inside: n2,
        alias: "string"
      },
      {
        pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
        lookbehind: true,
        inside: n2,
        alias: "string"
      }
    ],
    keyword: {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true
    },
    url: { pattern: /(\\url\{)[^}]+(?=\})/, lookbehind: true },
    headline: {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true,
      alias: "class-name"
    },
    function: { pattern: t8, alias: "selector" },
    punctuation: /[[\]{}&]/
  }, e2.languages.tex = e2.languages.latex, e2.languages.context = e2.languages.latex;
}(Prism), function(t8) {
  var e2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, n2 = [
    { pattern: /\b(?:false|true)\b/i, alias: "boolean" },
    {
      pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
      greedy: true,
      lookbehind: true
    },
    {
      pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
      greedy: true,
      lookbehind: true
    },
    /\b(?:null)\b/i,
    /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
  ], a = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, r2 = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, i = /[{}\[\](),:;]/, o2 = (t8.languages.php = {
    delimiter: {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    comment: e2,
    variable: /\$+(?:\w+\b|(?=\{))/,
    package: {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: { punctuation: /\\/ }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    keyword: [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      { pattern: /(\byield\s+)from\b/i, lookbehind: true },
      /\bclass\b/i,
      {
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      { pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i, greedy: true },
      {
        pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*\$)/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-declaration"],
        greedy: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
        alias: ["class-name-fully-qualified", "static-context"],
        greedy: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-hint"],
        greedy: true,
        lookbehind: true,
        inside: { punctuation: /\\/ }
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: ["class-name-fully-qualified", "return-type"],
        greedy: true,
        lookbehind: true,
        inside: { punctuation: /\\/ }
      }
    ],
    constant: n2,
    function: {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: { punctuation: /\\/ }
    },
    property: { pattern: /(->\s*)\w+/, lookbehind: true },
    number: a,
    operator: r2,
    punctuation: i
  }, {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: t8.languages.php
  }), o2 = [
    {
      pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
      alias: "nowdoc-string",
      greedy: true,
      inside: {
        delimiter: {
          pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: { punctuation: /^<<<'?|[';]$/ }
        }
      }
    },
    {
      pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        delimiter: {
          pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: { punctuation: /^<<<"?|[";]$/ }
        },
        interpolation: o2
      }
    },
    {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      alias: "backtick-quoted-string",
      greedy: true
    },
    {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      alias: "single-quoted-string",
      greedy: true
    },
    {
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      alias: "double-quoted-string",
      greedy: true,
      inside: { interpolation: o2 }
    }
  ];
  t8.languages.insertBefore("php", "variable", {
    string: o2,
    attribute: {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          inside: {
            comment: e2,
            string: o2,
            "attribute-class-name": [
              {
                pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                alias: "class-name",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                alias: ["class-name", "class-name-fully-qualified"],
                greedy: true,
                lookbehind: true,
                inside: { punctuation: /\\/ }
              }
            ],
            constant: n2,
            number: a,
            operator: r2,
            punctuation: i
          }
        },
        delimiter: { pattern: /^#\[|\]$/, alias: "punctuation" }
      }
    }
  }), t8.hooks.add("before-tokenize", function(e22) {
    /<\?/.test(e22.code) && t8.languages["markup-templating"].buildPlaceholders(
      e22,
      "php",
      /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g
    );
  }), t8.hooks.add("after-tokenize", function(e22) {
    t8.languages["markup-templating"].tokenizePlaceholders(e22, "php");
  });
}(Prism), function(t8) {
  t8.languages.latte = {
    comment: /^\{\*[\s\S]*/,
    "latte-tag": {
      pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
      lookbehind: true,
      alias: "important"
    },
    delimiter: { pattern: /^\{\/?|\}$/, alias: "punctuation" },
    php: {
      pattern: /\S(?:[\s\S]*\S)?/,
      alias: "language-php",
      inside: t8.languages.php
    }
  };
  var n2 = t8.languages.extend("markup", {});
  t8.languages.insertBefore(
    "inside",
    "attr-value",
    {
      "n-attr": {
        pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
        inside: {
          "attr-name": { pattern: /^[^\s=]+/, alias: "important" },
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              punctuation: [
                /^=/,
                { pattern: /^(\s*)["']|["']$/, lookbehind: true }
              ],
              php: { pattern: /\S(?:[\s\S]*\S)?/, inside: t8.languages.php }
            }
          }
        }
      }
    },
    n2.tag
  ), t8.hooks.add("before-tokenize", function(e2) {
    "latte" === e2.language && (t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "latte",
      /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g
    ), e2.grammar = n2);
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "latte");
  });
}(Prism), Prism.languages.scheme = {
  comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
  string: { pattern: /"(?:[^"\\]|\\.)*"/, greedy: true },
  symbol: { pattern: /'[^()\[\]#'\s]+/, greedy: true },
  char: {
    pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
    greedy: true
  },
  "lambda-parameter": [
    {
      pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
      lookbehind: true
    },
    {
      pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
      lookbehind: true
    }
  ],
  keyword: {
    pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
    lookbehind: true
  },
  builtin: {
    pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
    lookbehind: true
  },
  operator: {
    pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
    lookbehind: true
  },
  number: {
    pattern: RegExp(
      function(t8) {
        for (var e2 in t8)
          t8[e2] = t8[e2].replace(/<[\w\s]+>/g, function(e22) {
            return "(?:" + t8[e22].trim() + ")";
          });
        return t8[e2];
      }({
        "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
        "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
        "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
        "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
        "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
        "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
        "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
        "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
        "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
        "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
        "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
      }),
      "i"
    ),
    lookbehind: true
  },
  boolean: {
    pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
    lookbehind: true
  },
  function: {
    pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
    lookbehind: true
  },
  identifier: {
    pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
    lookbehind: true,
    greedy: true
  },
  punctuation: /[()\[\]']/
}, function(e2) {
  for (var t8 = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source, n2 = 0; n2 < 5; n2++)
    t8 = t8.replace(/<expr>/g, function() {
      return t8;
    });
  var t8 = t8.replace(/<expr>/g, /[^\s\S]/.source), a = e2.languages.lilypond = {
    comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
    "embedded-scheme": {
      pattern: RegExp(
        /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
          /<expr>/g,
          function() {
            return t8;
          }
        ),
        "m"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        scheme: {
          pattern: /^(#)[\s\S]+$/,
          lookbehind: true,
          alias: "language-scheme",
          inside: {
            "embedded-lilypond": {
              pattern: /#\{[\s\S]*?#\}/,
              greedy: true,
              inside: {
                punctuation: /^#\{|#\}$/,
                lilypond: {
                  pattern: /[\s\S]+/,
                  alias: "language-lilypond",
                  inside: null
                }
              }
            },
            rest: e2.languages.scheme
          }
        },
        punctuation: /#/
      }
    },
    string: { pattern: /"(?:[^"\\]|\\.)*"/, greedy: true },
    "class-name": { pattern: /(\\new\s+)[\w-]+/, lookbehind: true },
    keyword: { pattern: /\\[a-z][-\w]*/i, inside: { punctuation: /^\\/ } },
    operator: /[=|]|<<|>>/,
    punctuation: {
      pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
      lookbehind: true
    },
    number: /\b\d+(?:\/\d+)?\b/
  };
  a["embedded-scheme"].inside.scheme.inside["embedded-lilypond"].inside.lilypond.inside = a, e2.languages.ly = a;
}(Prism), Prism.languages.liquid = {
  comment: {
    pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
    lookbehind: true
  },
  delimiter: {
    pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
    alias: "punctuation"
  },
  string: { pattern: /"[^"]*"|'[^']*'/, greedy: true },
  keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
  object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
  function: [
    { pattern: /(\|\s*)\w+/, lookbehind: true, alias: "filter" },
    { pattern: /(\.\s*)(?:first|last|size)/, lookbehind: true }
  ],
  boolean: /\b(?:false|nil|true)\b/,
  range: { pattern: /\.\./, alias: "operator" },
  number: /\b\d+(?:\.\d+)?\b/,
  operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
  punctuation: /[.,\[\]()]/,
  empty: { pattern: /\bempty\b/, alias: "keyword" }
}, Prism.hooks.add("before-tokenize", function(e2) {
  var t8 = false;
  Prism.languages["markup-templating"].buildPlaceholders(
    e2,
    "liquid",
    /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g,
    function(e22) {
      e22 = /^\{%-?\s*(\w+)/.exec(e22);
      if (e22) {
        e22 = e22[1];
        if ("raw" === e22 && !t8) return t8 = true;
        if ("endraw" === e22) return !(t8 = false);
      }
      return !t8;
    }
  );
}), Prism.hooks.add("after-tokenize", function(e2) {
  Prism.languages["markup-templating"].tokenizePlaceholders(e2, "liquid");
}), function(e2) {
  function t8(e22) {
    return RegExp(/(\()/.source + "(?:" + e22 + ")" + /(?=[\s\)])/.source);
  }
  function n2(e22) {
    return RegExp(/([\s([])/.source + "(?:" + e22 + ")" + /(?=[\s)])/.source);
  }
  var a = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source, r2 = "&" + a, i = "(\\()", o2 = "(?=\\s)", s2 = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source, o2 = {
    heading: { pattern: /;;;.*/, alias: ["comment", "title"] },
    comment: /;.*/,
    string: {
      pattern: /"(?:[^"\\]|\\.)*"/,
      greedy: true,
      inside: {
        argument: /[-A-Z]+(?=[.,\s])/,
        symbol: RegExp("`" + a + "'")
      }
    },
    "quoted-symbol": {
      pattern: RegExp("#?'" + a),
      alias: ["variable", "symbol"]
    },
    "lisp-property": { pattern: RegExp(":" + a), alias: "property" },
    splice: { pattern: RegExp(",@?" + a), alias: ["symbol", "variable"] },
    keyword: [
      {
        pattern: RegExp(
          i + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + o2
        ),
        lookbehind: true
      },
      {
        pattern: RegExp(
          i + "(?:append|by|collect|concat|do|finally|for|in|return)" + o2
        ),
        lookbehind: true
      }
    ],
    declare: {
      pattern: t8(/declare/.source),
      lookbehind: true,
      alias: "keyword"
    },
    interactive: {
      pattern: t8(/interactive/.source),
      lookbehind: true,
      alias: "keyword"
    },
    boolean: { pattern: n2(/nil|t/.source), lookbehind: true },
    number: { pattern: n2(/[-+]?\d+(?:\.\d*)?/.source), lookbehind: true },
    defvar: {
      pattern: RegExp(i + "def(?:const|custom|group|var)\\s+" + a),
      lookbehind: true,
      inside: { keyword: /^def[a-z]+/, variable: RegExp(a) }
    },
    defun: {
      pattern: RegExp(
        i + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + a + /\s+\(/.source + s2 + /\)/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        keyword: /^(?:cl-)?def\S+/,
        arguments: null,
        function: { pattern: RegExp("(^\\s)" + a), lookbehind: true },
        punctuation: /[()]/
      }
    },
    lambda: {
      pattern: RegExp(
        i + "lambda\\s+\\(\\s*(?:&?" + a + "(?:\\s+&?" + a + ")*\\s*)?\\)"
      ),
      lookbehind: true,
      greedy: true,
      inside: { keyword: /^lambda/, arguments: null, punctuation: /[()]/ }
    },
    car: { pattern: RegExp(i + a), lookbehind: true },
    punctuation: [
      /(?:['`,]?\(|[)\[\]])/,
      { pattern: /(\s)\.(?=\s)/, lookbehind: true }
    ]
  }, r2 = {
    "lisp-marker": RegExp(r2),
    varform: {
      pattern: RegExp(
        /\(/.source + a + /\s+(?=\S)/.source + s2 + /\)/.source
      ),
      inside: o2
    },
    argument: {
      pattern: RegExp(/(^|[\s(])/.source + a),
      lookbehind: true,
      alias: "variable"
    },
    rest: o2
  }, l2 = "\\S+(?:\\s+\\S+)*", i = {
    pattern: RegExp(i + s2 + "(?=\\))"),
    lookbehind: true,
    inside: {
      "rest-vars": { pattern: RegExp("&(?:body|rest)\\s+" + l2), inside: r2 },
      "other-marker-vars": {
        pattern: RegExp("&(?:aux|optional)\\s+" + l2),
        inside: r2
      },
      keys: {
        pattern: RegExp("&key\\s+" + l2 + "(?:\\s+&allow-other-keys)?"),
        inside: r2
      },
      argument: { pattern: RegExp(a), alias: "variable" },
      punctuation: /[()]/
    }
  };
  o2.lambda.inside.arguments = i, o2.defun.inside.arguments = e2.util.clone(i), o2.defun.inside.arguments.inside.sublist = i, e2.languages.lisp = o2, e2.languages.elisp = o2, e2.languages.emacs = o2, e2.languages["emacs-lisp"] = o2;
}(Prism), Prism.languages.livescript = {
  comment: [
    { pattern: /(^|[^\\])\/\*[\s\S]*?\*\//, lookbehind: true },
    { pattern: /(^|[^\\])#.*/, lookbehind: true }
  ],
  "interpolated-string": {
    pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
    lookbehind: true,
    greedy: true,
    inside: {
      variable: {
        pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
        lookbehind: true
      },
      interpolation: {
        pattern: /(^|[^\\])#\{[^}]+\}/m,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^#\{|\}$/,
            alias: "variable"
          }
        }
      },
      string: /[\s\S]+/
    }
  },
  string: [
    { pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/, greedy: true },
    { pattern: /<\[[\s\S]*?\]>/, greedy: true },
    /\\[^\s,;\])}]+/
  ],
  regex: [
    {
      pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
      greedy: true,
      inside: { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true } }
    },
    {
      pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
      greedy: true
    }
  ],
  keyword: {
    pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
    lookbehind: true
  },
  "keyword-operator": {
    pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
    lookbehind: true,
    alias: "operator"
  },
  boolean: {
    pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
    lookbehind: true
  },
  argument: {
    pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
    lookbehind: true,
    alias: "variable"
  },
  number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
  identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
  operator: [
    { pattern: /( )\.(?= )/, lookbehind: true },
    /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
  ],
  punctuation: /[(){}\[\]|.,:;`]/
}, Prism.languages.livescript["interpolated-string"].inside.interpolation.inside.rest = Prism.languages.livescript, Prism.languages.llvm = {
  comment: /;.*/,
  string: { pattern: /"[^"]*"/, greedy: true },
  boolean: /\b(?:false|true)\b/,
  variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
  label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
  type: {
    pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
    alias: "class-name"
  },
  keyword: /\b[a-z_][a-z_0-9]*\b/,
  number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
  punctuation: /[{}[\];(),.!*=<>]/
}, Prism.languages.log = {
  string: {
    pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
    greedy: true
  },
  exception: {
    pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
    lookbehind: true,
    greedy: true,
    alias: ["javastacktrace", "language-javastacktrace"],
    inside: Prism.languages.javastacktrace || {
      keyword: /\bat\b/,
      function: /[a-z_][\w$]*(?=\()/,
      punctuation: /[.:()]/
    }
  },
  level: [
    {
      pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
      alias: ["error", "important"]
    },
    { pattern: /\b(?:WARN|WARNING|WRN)\b/, alias: ["warning", "important"] },
    {
      pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
      alias: ["info", "keyword"]
    },
    { pattern: /\b(?:DBG|DEBUG|FINE)\b/, alias: ["debug", "keyword"] },
    {
      pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
      alias: ["trace", "comment"]
    }
  ],
  property: {
    pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
    lookbehind: true
  },
  separator: {
    pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
    lookbehind: true,
    alias: "comment"
  },
  url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
  email: {
    pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
    lookbehind: true,
    alias: "url"
  },
  "ip-address": {
    pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
    alias: "constant"
  },
  "mac-address": {
    pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
    alias: "constant"
  },
  domain: {
    pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
    lookbehind: true,
    alias: "constant"
  },
  uuid: {
    pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
    alias: "constant"
  },
  hash: { pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i, alias: "constant" },
  "file-path": {
    pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
    lookbehind: true,
    greedy: true,
    alias: "string"
  },
  date: {
    pattern: RegExp(
      /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
      "i"
    ),
    alias: "number"
  },
  time: {
    pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
    alias: "number"
  },
  boolean: /\b(?:false|null|true)\b/i,
  number: {
    pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
    lookbehind: true
  },
  operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
  punctuation: /[\[\].,]/
}, Prism.languages.lolcode = {
  comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
  string: {
    pattern: /"(?::.|[^":])*"/,
    inside: {
      variable: /:\{[^}]+\}/,
      symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
    },
    greedy: true
  },
  number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
  symbol: {
    pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
    lookbehind: true,
    inside: { keyword: /A(?=\s)/ }
  },
  label: {
    pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
    lookbehind: true,
    alias: "string"
  },
  function: {
    pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
    lookbehind: true
  },
  keyword: [
    {
      pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
      lookbehind: true
    },
    /'Z(?=\s|,|$)/
  ],
  boolean: { pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/, lookbehind: true },
  variable: { pattern: /(^|\s)IT(?=\s|,|$)/, lookbehind: true },
  operator: {
    pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
    lookbehind: true
  },
  punctuation: /\.{3}|…|,|!/
}, Prism.languages.magma = {
  output: {
    pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
    lookbehind: true,
    greedy: true
  },
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
  string: {
    pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
  boolean: /\b(?:false|true)\b/,
  generator: { pattern: /\b[a-z_]\w*(?=\s*<)/i, alias: "class-name" },
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: {
    pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
    lookbehind: true
  },
  operator: /->|[-+*/^~!|#=]|:=|\.\./,
  punctuation: /[()[\]{}<>,;.:]/
}, Prism.languages.makefile = {
  comment: {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  target: {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: { variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/ }
  },
  variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  function: {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  operator: /(?:::|[?:+!])?=|[|@]/,
  punctuation: /[:;(){}]/
}, function(e2) {
  var t8 = /\bvoid\b|<org>|\b(?:complex|numeric|pointer(?:\s*\([^()]*\))?|real|string|(?:class|struct)\s+\w+|transmorphic)(?:\s*<org>)?/.source.replace(
    /<org>/g,
    /\b(?:(?:col|row)?vector|matrix|scalar)\b/.source
  );
  e2.languages.mata = {
    comment: {
      pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
      greedy: true
    },
    string: { pattern: /"[^"\r\n]*"|[‘`']".*?"[’`']/, greedy: true },
    "class-name": {
      pattern: /(\b(?:class|extends|struct)\s+)\w+(?=\s*(?:\{|\bextends\b))/,
      lookbehind: true
    },
    type: {
      pattern: RegExp(t8),
      alias: "class-name",
      inside: {
        punctuation: /[()]/,
        keyword: /\b(?:class|function|struct|void)\b/
      }
    },
    keyword: /\b(?:break|class|continue|do|else|end|extends|external|final|for|function|goto|if|pragma|private|protected|public|return|static|struct|unset|unused|version|virtual|while)\b/,
    constant: /\bNULL\b/,
    number: {
      pattern: /(^|[^\w.])(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|\d[a-f0-9]*(?:\.[a-f0-9]+)?x[+-]?\d+)i?(?![\w.])/i,
      lookbehind: true
    },
    missing: {
      pattern: /(^|[^\w.])(?:\.[a-z]?)(?![\w.])/,
      lookbehind: true,
      alias: "symbol"
    },
    function: /\b[a-z_]\w*(?=\s*\()/i,
    operator: /\.\.|\+\+|--|&&|\|\||:?(?:[!=<>]=|[+\-*/^<>&|:])|[!?=\\#’`']/,
    punctuation: /[()[\]{},;.]/
  };
}(Prism), Prism.languages.matlab = {
  comment: [/%\{[\s\S]*?\}%/, /%.+/],
  string: { pattern: /\B'(?:''|[^'\r\n])*'/, greedy: true },
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
  keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
  function: /\b(?!\d)\w+(?=\s*\()/,
  operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
  punctuation: /\.{3}|[.,;\[\](){}!]/
}, function() {
  var e2 = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
  Prism.languages.maxscript = {
    comment: { pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/, greedy: true },
    string: {
      pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
      lookbehind: true,
      greedy: true
    },
    path: {
      pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
      greedy: true,
      alias: "string"
    },
    "function-call": {
      pattern: RegExp(
        "((?:" + /^/.source + "|" + /[;=<>+\-*/^({\[]/.source + "|" + /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source + ")[ 	]*)(?!" + e2.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:(?!" + e2.source + ")" + /[a-z_]/.source + "|" + /\d|-\.?\d/.source + "|" + /[({'"$@#?]/.source + "))",
        "im"
      ),
      lookbehind: true,
      greedy: true,
      alias: "function"
    },
    "function-definition": {
      pattern: /(\b(?:fn|function)\s+)\w+\b/i,
      lookbehind: true,
      alias: "function"
    },
    argument: { pattern: /\b[a-z_]\w*(?=:)/i, alias: "attr-name" },
    keyword: e2,
    boolean: /\b(?:false|true)\b/,
    time: {
      pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
      lookbehind: true,
      alias: "number"
    },
    number: [
      {
        pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
        lookbehind: true
      },
      /\b(?:e|pi)\b/
    ],
    constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
    color: {
      pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
      alias: "constant"
    },
    operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
    punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
  };
}(), Prism.languages.mel = {
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
  code: {
    pattern: /`(?:\\.|[^\\`])*`/,
    greedy: true,
    alias: "italic",
    inside: {
      delimiter: { pattern: /^`|`$/, alias: "punctuation" },
      statement: { pattern: /[\s\S]+/, inside: null }
    }
  },
  string: { pattern: /"(?:\\.|[^\\"\r\n])*"/, greedy: true },
  variable: /\$\w+/,
  number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
  flag: { pattern: /-[^\d\W]\w*/, alias: "operator" },
  keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
  function: {
    pattern: /((?:^|[{;])[ \t]*)[a-z_]\w*\b(?!\s*(?:\.(?!\.)|[[{=]))|\b[a-z_]\w*(?=[ \t]*\()/im,
    lookbehind: true,
    greedy: true
  },
  "tensor-punctuation": { pattern: /<<|>>/, alias: "punctuation" },
  operator: /\+[+=]?|-[-=]?|&&|\|\||[<>]=?|[*\/!=]=?|[%^]/,
  punctuation: /[.,:;?\[\](){}]/
}, Prism.languages.mel.code.inside.statement.inside = Prism.languages.mel, Prism.languages.mermaid = {
  comment: { pattern: /%%.*/, greedy: true },
  style: {
    pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
    lookbehind: true,
    inside: {
      property: /\b\w[\w-]*(?=[ \t]*:)/,
      operator: /:/,
      punctuation: /,/
    }
  },
  "inter-arrow-label": {
    pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
    lookbehind: true,
    greedy: true,
    inside: {
      arrow: { pattern: /(?:\.+->?|--+[->]|==+[=>])$/, alias: "operator" },
      label: {
        pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
        lookbehind: true,
        alias: "property"
      },
      "arrow-head": { pattern: /^\S+/, alias: ["arrow", "operator"] }
    }
  },
  arrow: [
    {
      pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
      lookbehind: true,
      alias: "operator"
    },
    {
      pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
      lookbehind: true,
      alias: "operator"
    },
    {
      pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
      lookbehind: true,
      alias: "operator"
    },
    {
      pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
      lookbehind: true,
      alias: "operator"
    }
  ],
  label: {
    pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
    lookbehind: true,
    greedy: true,
    alias: "property"
  },
  text: {
    pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
    alias: "string"
  },
  string: { pattern: /"[^"\r\n]*"/, greedy: true },
  annotation: {
    pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
    alias: "important"
  },
  keyword: [
    {
      pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
      lookbehind: true,
      greedy: true
    },
    {
      pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
      lookbehind: true,
      greedy: true
    }
  ],
  entity: /#[a-z0-9]+;/,
  operator: { pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/, lookbehind: true },
  punctuation: /[(){};]/
}, Prism.languages.metafont = {
  comment: { pattern: /%.*/, greedy: true },
  string: { pattern: /"[^\r\n"]*"/, greedy: true },
  number: /\d*\.?\d+/,
  boolean: /\b(?:false|true)\b/,
  punctuation: [
    /[,;()]/,
    { pattern: /(^|[^{}])(?:\{|\})(?![{}])/, lookbehind: true },
    { pattern: /(^|[^[])\[(?!\[)/, lookbehind: true },
    { pattern: /(^|[^\]])\](?!\])/, lookbehind: true }
  ],
  constant: [
    { pattern: /(^|[^!?])\?\?\?(?![!?])/, lookbehind: true },
    { pattern: /(^|[^/*\\])(?:\\|\\\\)(?![/*\\])/, lookbehind: true },
    /\b(?:_|blankpicture|bp|cc|cm|dd|ditto|down|eps|epsilon|fullcircle|halfcircle|identity|in|infinity|left|mm|nullpen|nullpicture|origin|pc|penrazor|penspeck|pensquare|penstroke|proof|pt|quartercircle|relax|right|smoke|unitpixel|unitsquare|up)\b/
  ],
  quantity: {
    pattern: /\b(?:autorounding|blacker|boundarychar|charcode|chardp|chardx|chardy|charext|charht|charic|charwd|currentwindow|day|designsize|displaying|fillin|fontmaking|granularity|hppp|join_radius|month|o_correction|pausing|pen_(?:bot|lft|rt|top)|pixels_per_inch|proofing|showstopping|smoothing|time|tolerance|tracingcapsules|tracingchoices|tracingcommands|tracingedges|tracingequations|tracingmacros|tracingonline|tracingoutput|tracingpens|tracingrestores|tracingspecs|tracingstats|tracingtitles|turningcheck|vppp|warningcheck|xoffset|year|yoffset)\b/,
    alias: "keyword"
  },
  command: {
    pattern: /\b(?:addto|batchmode|charlist|cull|display|errhelp|errmessage|errorstopmode|everyjob|extensible|fontdimen|headerbyte|inner|interim|let|ligtable|message|newinternal|nonstopmode|numspecial|openwindow|outer|randomseed|save|scrollmode|shipout|show|showdependencies|showstats|showtoken|showvariable|special)\b/,
    alias: "builtin"
  },
  operator: [
    {
      pattern: /(^|[^>=<:|])(?:<|<=|=|=:|\|=:|\|=:>|=:\|>|=:\||\|=:\||\|=:\|>|\|=:\|>>|>|>=|:|:=|<>|::|\|\|:)(?![>=<:|])/,
      lookbehind: true
    },
    { pattern: /(^|[^+-])(?:\+|\+\+|-{1,3}|\+-\+)(?![+-])/, lookbehind: true },
    { pattern: /(^|[^/*\\])(?:\*|\*\*|\/)(?![/*\\])/, lookbehind: true },
    { pattern: /(^|[^.])(?:\.{2,3})(?!\.)/, lookbehind: true },
    { pattern: /(^|[^@#&$])&(?![@#&$])/, lookbehind: true },
    /\b(?:and|not|or)\b/
  ],
  macro: {
    pattern: /\b(?:abs|beginchar|bot|byte|capsule_def|ceiling|change_width|clear_pen_memory|clearit|clearpen|clearxy|counterclockwise|cullit|cutdraw|cutoff|decr|define_blacker_pixels|define_corrected_pixels|define_good_x_pixels|define_good_y_pixels|define_horizontal_corrected_pixels|define_pixels|define_whole_blacker_pixels|define_whole_pixels|define_whole_vertical_blacker_pixels|define_whole_vertical_pixels|dir|direction|directionpoint|div|dotprod|downto|draw|drawdot|endchar|erase|fill|filldraw|fix_units|flex|font_coding_scheme|font_extra_space|font_identifier|font_normal_shrink|font_normal_space|font_normal_stretch|font_quad|font_size|font_slant|font_x_height|gfcorners|gobble|gobbled|good\.(?:bot|lft|rt|top|x|y)|grayfont|hide|hround|imagerules|incr|interact|interpath|intersectionpoint|inverse|italcorr|killtext|labelfont|labels|lft|loggingall|lowres_fix|makegrid|makelabel(?:\.(?:bot|lft|rt|top)(?:\.nodot)?)?|max|min|mod|mode_def|mode_setup|nodisplays|notransforms|numtok|openit|penlabels|penpos|pickup|proofoffset|proofrule|proofrulethickness|range|reflectedabout|rotatedabout|rotatedaround|round|rt|savepen|screenchars|screenrule|screenstrokes|shipit|showit|slantfont|softjoin|solve|stop|superellipse|tensepath|thru|titlefont|top|tracingall|tracingnone|undraw|undrawdot|unfill|unfilldraw|upto|vround)\b/,
    alias: "function"
  },
  builtin: /\b(?:ASCII|angle|char|cosd|decimal|directiontime|floor|hex|intersectiontimes|jobname|known|length|makepath|makepen|mexp|mlog|normaldeviate|oct|odd|pencircle|penoffset|point|postcontrol|precontrol|reverse|rotated|sind|sqrt|str|subpath|substring|totalweight|turningnumber|uniformdeviate|unknown|xpart|xxpart|xypart|ypart|yxpart|yypart)\b/,
  keyword: /\b(?:also|at|atleast|begingroup|charexists|contour|controls|curl|cycle|def|delimiters|doublepath|dropping|dump|else|elseif|end|enddef|endfor|endgroup|endinput|exitif|exitunless|expandafter|fi|for|forever|forsuffixes|from|if|input|inwindow|keeping|kern|of|primarydef|quote|readstring|scaled|scantokens|secondarydef|shifted|skipto|slanted|step|tension|tertiarydef|to|transformed|until|vardef|withpen|withweight|xscaled|yscaled|zscaled)\b/,
  type: {
    pattern: /\b(?:boolean|expr|numeric|pair|path|pen|picture|primary|secondary|string|suffix|tertiary|text|transform)\b/,
    alias: "property"
  },
  variable: {
    pattern: /(^|[^@#&$])(?:@#|#@|#|@)(?![@#&$])|\b(?:aspect_ratio|currentpen|currentpicture|currenttransform|d|extra_beginchar|extra_endchar|extra_setup|h|localfont|mag|mode|screen_cols|screen_rows|w|whatever|x|y|z)\b/,
    lookbehind: true
  }
}, Prism.languages.mizar = {
  comment: /::.+/,
  keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
  parameter: { pattern: /\$(?:10|\d)/, alias: "variable" },
  variable: /\b\w+(?=:)/,
  number: /(?:\b|-)\d+\b/,
  operator: /\.\.\.|->|&|\.?=/,
  punctuation: /\(#|#\)|[,:;\[\](){}]/
}, function(e2) {
  var t8 = "(?:" + [
    "$eq",
    "$gt",
    "$gte",
    "$in",
    "$lt",
    "$lte",
    "$ne",
    "$nin",
    "$and",
    "$not",
    "$nor",
    "$or",
    "$exists",
    "$type",
    "$expr",
    "$jsonSchema",
    "$mod",
    "$regex",
    "$text",
    "$where",
    "$geoIntersects",
    "$geoWithin",
    "$near",
    "$nearSphere",
    "$all",
    "$elemMatch",
    "$size",
    "$bitsAllClear",
    "$bitsAllSet",
    "$bitsAnyClear",
    "$bitsAnySet",
    "$comment",
    "$elemMatch",
    "$meta",
    "$slice",
    "$currentDate",
    "$inc",
    "$min",
    "$max",
    "$mul",
    "$rename",
    "$set",
    "$setOnInsert",
    "$unset",
    "$addToSet",
    "$pop",
    "$pull",
    "$push",
    "$pullAll",
    "$each",
    "$position",
    "$slice",
    "$sort",
    "$bit",
    "$addFields",
    "$bucket",
    "$bucketAuto",
    "$collStats",
    "$count",
    "$currentOp",
    "$facet",
    "$geoNear",
    "$graphLookup",
    "$group",
    "$indexStats",
    "$limit",
    "$listLocalSessions",
    "$listSessions",
    "$lookup",
    "$match",
    "$merge",
    "$out",
    "$planCacheStats",
    "$project",
    "$redact",
    "$replaceRoot",
    "$replaceWith",
    "$sample",
    "$set",
    "$skip",
    "$sort",
    "$sortByCount",
    "$unionWith",
    "$unset",
    "$unwind",
    "$setWindowFields",
    "$abs",
    "$accumulator",
    "$acos",
    "$acosh",
    "$add",
    "$addToSet",
    "$allElementsTrue",
    "$and",
    "$anyElementTrue",
    "$arrayElemAt",
    "$arrayToObject",
    "$asin",
    "$asinh",
    "$atan",
    "$atan2",
    "$atanh",
    "$avg",
    "$binarySize",
    "$bsonSize",
    "$ceil",
    "$cmp",
    "$concat",
    "$concatArrays",
    "$cond",
    "$convert",
    "$cos",
    "$dateFromParts",
    "$dateToParts",
    "$dateFromString",
    "$dateToString",
    "$dayOfMonth",
    "$dayOfWeek",
    "$dayOfYear",
    "$degreesToRadians",
    "$divide",
    "$eq",
    "$exp",
    "$filter",
    "$first",
    "$floor",
    "$function",
    "$gt",
    "$gte",
    "$hour",
    "$ifNull",
    "$in",
    "$indexOfArray",
    "$indexOfBytes",
    "$indexOfCP",
    "$isArray",
    "$isNumber",
    "$isoDayOfWeek",
    "$isoWeek",
    "$isoWeekYear",
    "$last",
    "$last",
    "$let",
    "$literal",
    "$ln",
    "$log",
    "$log10",
    "$lt",
    "$lte",
    "$ltrim",
    "$map",
    "$max",
    "$mergeObjects",
    "$meta",
    "$min",
    "$millisecond",
    "$minute",
    "$mod",
    "$month",
    "$multiply",
    "$ne",
    "$not",
    "$objectToArray",
    "$or",
    "$pow",
    "$push",
    "$radiansToDegrees",
    "$range",
    "$reduce",
    "$regexFind",
    "$regexFindAll",
    "$regexMatch",
    "$replaceOne",
    "$replaceAll",
    "$reverseArray",
    "$round",
    "$rtrim",
    "$second",
    "$setDifference",
    "$setEquals",
    "$setIntersection",
    "$setIsSubset",
    "$setUnion",
    "$size",
    "$sin",
    "$slice",
    "$split",
    "$sqrt",
    "$stdDevPop",
    "$stdDevSamp",
    "$strcasecmp",
    "$strLenBytes",
    "$strLenCP",
    "$substr",
    "$substrBytes",
    "$substrCP",
    "$subtract",
    "$sum",
    "$switch",
    "$tan",
    "$toBool",
    "$toDate",
    "$toDecimal",
    "$toDouble",
    "$toInt",
    "$toLong",
    "$toObjectId",
    "$toString",
    "$toLower",
    "$toUpper",
    "$trim",
    "$trunc",
    "$type",
    "$week",
    "$year",
    "$zip",
    "$count",
    "$dateAdd",
    "$dateDiff",
    "$dateSubtract",
    "$dateTrunc",
    "$getField",
    "$rand",
    "$sampleRate",
    "$setField",
    "$unsetField",
    "$comment",
    "$explain",
    "$hint",
    "$max",
    "$maxTimeMS",
    "$min",
    "$orderby",
    "$query",
    "$returnKey",
    "$showDiskLoc",
    "$natural"
  ].map(function(e22) {
    return e22.replace("$", "\\$");
  }).join("|") + ")\\b";
  e2.languages.mongodb = e2.languages.extend("javascript", {}), e2.languages.insertBefore("mongodb", "string", {
    property: {
      pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
      greedy: true,
      inside: { keyword: RegExp(`^(['"])?` + t8 + "(?:\\1)?$") }
    }
  }), e2.languages.mongodb.string.inside = {
    url: {
      pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
      greedy: true
    },
    entity: {
      pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
      greedy: true
    }
  }, e2.languages.insertBefore("mongodb", "constant", {
    builtin: {
      pattern: RegExp(
        "\\b(?:" + [
          "ObjectId",
          "Code",
          "BinData",
          "DBRef",
          "Timestamp",
          "NumberLong",
          "NumberDecimal",
          "MaxKey",
          "MinKey",
          "RegExp",
          "ISODate",
          "UUID"
        ].join("|") + ")\\b"
      ),
      alias: "keyword"
    }
  });
}(Prism), Prism.languages.monkey = {
  comment: { pattern: /^#Rem\s[\s\S]*?^#End|'.+/im, greedy: true },
  string: { pattern: /"[^"\r\n]*"/, greedy: true },
  preprocessor: {
    pattern: /(^[ \t]*)#.+/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  },
  function: /\b\w+(?=\()/,
  "type-char": { pattern: /\b[?%#$]/, alias: "class-name" },
  number: {
    pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
    lookbehind: true
  },
  keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
  operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
  punctuation: /[.,:;()\[\]]/
}, Prism.languages.moonscript = {
  comment: /--.*/,
  string: [
    { pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/, greedy: true },
    {
      pattern: /"[^"]*"/,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /#\{[^{}]*\}/,
          inside: {
            moonscript: {
              pattern: /(^#\{)[\s\S]+(?=\})/,
              lookbehind: true,
              inside: null
            },
            "interpolation-punctuation": {
              pattern: /#\{|\}/,
              alias: "punctuation"
            }
          }
        }
      }
    }
  ],
  "class-name": [
    { pattern: /(\b(?:class|extends)[ \t]+)\w+/, lookbehind: true },
    /\b[A-Z]\w*/
  ],
  keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
  variable: /@@?\w*/,
  property: { pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/, lookbehind: true },
  function: {
    pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
    inside: { punctuation: /\./ }
  },
  boolean: /\b(?:false|true)\b/,
  number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
  operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
  punctuation: /[.,()[\]{}\\]/
}, Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism.languages.moonscript, Prism.languages.moon = Prism.languages.moonscript, Prism.languages.n1ql = {
  comment: { pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/, greedy: true },
  string: { pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/, greedy: true },
  identifier: { pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/, greedy: true },
  parameter: /\$[\w.]+/,
  keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  boolean: /\b(?:FALSE|TRUE)\b/i,
  number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
  punctuation: /[;[\](),.{}:]/
}, Prism.languages["nand2tetris-hdl"] = {
  comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
  keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
  number: /\b\d+\b/,
  operator: /=|\.\./,
  punctuation: /[{}[\];(),:]/
}, function(e2) {
  var t8 = /\{[^\r\n\[\]{}]*\}/, n2 = {
    "quoted-string": { pattern: /"(?:[^"\\]|\\.)*"/, alias: "operator" },
    "command-param-id": {
      pattern: /(\s)\w+:/,
      lookbehind: true,
      alias: "property"
    },
    "command-param-value": [
      { pattern: t8, alias: "selector" },
      {
        pattern: /([\t ])\S+/,
        lookbehind: true,
        greedy: true,
        alias: "operator"
      },
      { pattern: /\S(?:.*\S)?/, alias: "operator" }
    ]
  };
  function a(e22) {
    return "string" == typeof e22 ? e22 : Array.isArray(e22) ? e22.map(a).join("") : a(e22.content);
  }
  e2.languages.naniscript = {
    comment: { pattern: /^([\t ]*);.*/m, lookbehind: true },
    define: {
      pattern: /^>.+/m,
      alias: "tag",
      inside: {
        value: {
          pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
          lookbehind: true,
          alias: "operator"
        },
        key: { pattern: /(^>)\w+/, lookbehind: true }
      }
    },
    label: {
      pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
      lookbehind: true,
      alias: "regex"
    },
    command: {
      pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
      lookbehind: true,
      alias: "function",
      inside: {
        "command-name": /^@\w+/,
        expression: { pattern: t8, greedy: true, alias: "selector" },
        "command-params": { pattern: /\s*\S[\s\S]*/, inside: n2 }
      }
    },
    "generic-text": {
      pattern: /(^[ \t]*)[^#@>;\s].*/m,
      lookbehind: true,
      alias: "punctuation",
      inside: {
        "escaped-char": /\\[{}\[\]"]/,
        expression: { pattern: t8, greedy: true, alias: "selector" },
        "inline-command": {
          pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
          greedy: true,
          alias: "function",
          inside: {
            "command-params": {
              pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
              lookbehind: true,
              inside: n2
            },
            "command-param-name": {
              pattern: /^(\[[\t ]*)\w+/,
              lookbehind: true,
              alias: "name"
            },
            "start-stop-char": /[\[\]]/
          }
        }
      }
    }
  }, e2.languages.nani = e2.languages.naniscript, e2.hooks.add("after-tokenize", function(e22) {
    e22.tokens.forEach(function(e3) {
      var t22;
      "string" == typeof e3 || "generic-text" !== e3.type || function(e4) {
        for (var t32 = [], n22 = 0; n22 < e4.length; n22++) {
          var a2 = e4[n22], a2 = "[]{}".indexOf(a2);
          if (-1 !== a2) {
            if (a2 % 2 == 0) t32.push(a2 + 1);
            else if (t32.pop() !== a2) return;
          }
        }
        return 0 === t32.length;
      }(t22 = a(e3)) || (e3.type = "bad-line", e3.content = t22);
    });
  });
}(Prism), Prism.languages.nasm = {
  comment: /;.*$/m,
  string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
  label: {
    pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
    lookbehind: true,
    alias: "function"
  },
  keyword: [
    /\[?BITS (?:16|32|64)\]?/,
    { pattern: /(^\s*)section\s*[a-z.]+:?/im, lookbehind: true },
    /(?:extern|global)[^;\r\n]*/i,
    /(?:CPU|DEFAULT|FLOAT).*$/m
  ],
  register: {
    pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
    alias: "variable"
  },
  number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
  operator: /[\[\]*+\-\/%<>=&|$!]/
}, Prism.languages.neon = {
  comment: { pattern: /#.*/, greedy: true },
  datetime: {
    pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
    lookbehind: true,
    alias: "number"
  },
  key: {
    pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
    lookbehind: true,
    alias: "property"
  },
  number: {
    pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
    lookbehind: true
  },
  boolean: {
    pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
    lookbehind: true
  },
  null: {
    pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
    lookbehind: true,
    alias: "keyword"
  },
  string: {
    pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
    lookbehind: true,
    greedy: true
  },
  literal: {
    pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
    lookbehind: true,
    alias: "string"
  },
  punctuation: /[,:=[\]{}()-]/
}, Prism.languages.nevod = {
  comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
  string: {
    pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
    greedy: true,
    inside: { "string-attrs": /!$|!\*$|\*$/ }
  },
  namespace: {
    pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
    lookbehind: true
  },
  pattern: {
    pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
    lookbehind: true,
    inside: {
      "pattern-name": { pattern: /^#?[a-zA-Z0-9\-.]+/, alias: "class-name" },
      fields: {
        pattern: /\(.*\)/,
        inside: {
          "field-name": { pattern: /[a-zA-Z0-9\-.]+/, alias: "variable" },
          punctuation: /[,()]/,
          operator: { pattern: /~/, alias: "field-hidden-mark" }
        }
      }
    }
  },
  search: {
    pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
    alias: "function",
    lookbehind: true
  },
  keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
  "standard-pattern": {
    pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
    inside: {
      "standard-pattern-name": {
        pattern: /^[a-zA-Z0-9\-.]+/,
        alias: "builtin"
      },
      quantifier: {
        pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
        alias: "number"
      },
      "standard-pattern-attr": {
        pattern: /[a-zA-Z0-9\-.]+/,
        alias: "builtin"
      },
      punctuation: /[,()]/
    }
  },
  quantifier: {
    pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
    alias: "number"
  },
  operator: [
    { pattern: /=/, alias: "pattern-def" },
    { pattern: /&/, alias: "conjunction" },
    { pattern: /~/, alias: "exception" },
    { pattern: /\?/, alias: "optionality" },
    { pattern: /[[\]]/, alias: "repetition" },
    { pattern: /[{}]/, alias: "variation" },
    { pattern: /[+_]/, alias: "sequence" },
    { pattern: /\.{2,3}/, alias: "span" }
  ],
  "field-capture": [
    {
      pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
      lookbehind: true,
      inside: {
        "field-name": { pattern: /[a-zA-Z0-9\-.]+/, alias: "variable" },
        colon: /:/
      }
    },
    {
      pattern: /[a-zA-Z0-9\-.]+\s*:/,
      inside: {
        "field-name": { pattern: /[a-zA-Z0-9\-.]+/, alias: "variable" },
        colon: /:/
      }
    }
  ],
  punctuation: /[:;,()]/,
  name: /[a-zA-Z0-9\-.]+/
}, function() {
  var e2 = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
  Prism.languages.nginx = {
    comment: { pattern: /(^|[\s{};])#.*/, lookbehind: true, greedy: true },
    directive: {
      pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: {
        string: {
          pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
          lookbehind: true,
          greedy: true,
          inside: {
            escape: { pattern: /\\["'\\nrt]/, alias: "entity" },
            variable: e2
          }
        },
        comment: { pattern: /(\s)#.*/, lookbehind: true, greedy: true },
        keyword: { pattern: /^\S+/, greedy: true },
        boolean: { pattern: /(\s)(?:off|on)(?!\S)/, lookbehind: true },
        number: { pattern: /(\s)\d+[a-z]*(?!\S)/i, lookbehind: true },
        variable: e2
      }
    },
    punctuation: /[{};]/
  };
}(), Prism.languages.nim = {
  comment: { pattern: /#.*/, greedy: true },
  string: {
    pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
    greedy: true
  },
  char: { pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/, greedy: true },
  function: {
    pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
    greedy: true,
    inside: { operator: /\*$/ }
  },
  identifier: {
    pattern: /`[^`\r\n]+`/,
    greedy: true,
    inside: { punctuation: /`/ }
  },
  number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
  keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
  operator: {
    pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
    lookbehind: true
  },
  punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
}, Prism.languages.nix = {
  comment: { pattern: /\/\*[\s\S]*?\*\/|#.*/, greedy: true },
  string: {
    pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
        lookbehind: true,
        inside: null
      }
    }
  },
  url: [
    /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
    {
      pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
      lookbehind: true
    }
  ],
  antiquotation: { pattern: /\$(?=\{)/, alias: "important" },
  number: /\b\d+\b/,
  keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
  function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
  boolean: /\b(?:false|true)\b/,
  operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
  punctuation: /[{}()[\].,:;]/
}, Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix, Prism.languages.nsis = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
    lookbehind: true,
    greedy: true
  },
  string: { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  keyword: {
    pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|KnownFolderPath|LabelAddress|TempFileName|WinVer)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|RtlLanguage|ShellVarContextAll|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|Target|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
    lookbehind: true
  },
  property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
  constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
  variable: /\$\w[\w\.]*/,
  number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
  operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
  punctuation: /[{}[\];(),.:]/,
  important: {
    pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
    lookbehind: true
  }
}, Prism.languages.objectivec = Prism.languages.extend("c", {
  string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true },
  keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
}), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.ocaml = {
  comment: { pattern: /\(\*[\s\S]*?\*\)/, greedy: true },
  char: {
    pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
    greedy: true
  },
  string: [
    { pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/, greedy: true },
    { pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/, greedy: true }
  ],
  number: [
    /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
    /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
    /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
  ],
  directive: { pattern: /\B#\w+/, alias: "property" },
  label: { pattern: /\B~\w+/, alias: "property" },
  "type-variable": { pattern: /\B'\w+/, alias: "function" },
  variant: { pattern: /`\w+/, alias: "symbol" },
  keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
  boolean: /\b(?:false|true)\b/,
  "operator-like-punctuation": {
    pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
    alias: "punctuation"
  },
  operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
  punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
}, function() {
  var e2 = /\\(?:["'\\abefnrtv]|0[0-7]{2}|U[\dA-Fa-f]{6}|u[\dA-Fa-f]{4}|x[\dA-Fa-f]{2})/;
  Prism.languages.odin = {
    comment: [
      {
        pattern: /\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:\*(?!\/)|[^*])*(?:\*\/|$))*(?:\*\/|$)/,
        greedy: true
      },
      { pattern: /#![^\n\r]*/, greedy: true },
      { pattern: /\/\/[^\n\r]*/, greedy: true }
    ],
    char: {
      pattern: /'(?:\\(?:.|[0Uux][0-9A-Fa-f]{1,6})|[^\n\r'\\])'/,
      greedy: true,
      inside: { symbol: e2 }
    },
    string: [
      { pattern: /`[^`]*`/, greedy: true },
      { pattern: /"(?:\\.|[^\n\r"\\])*"/, greedy: true, inside: { symbol: e2 } }
    ],
    directive: { pattern: /#\w+/, alias: "property" },
    number: /\b0(?:b[01_]+|d[\d_]+|h_*(?:(?:(?:[\dA-Fa-f]_*){8}){1,2}|(?:[\dA-Fa-f]_*){4})|o[0-7_]+|x[\dA-F_a-f]+|z[\dAB_ab]+)\b|(?:\b\d+(?:\.(?!\.)\d*)?|\B\.\d+)(?:[Ee][+-]?\d*)?[ijk]?(?!\w)/,
    discard: { pattern: /\b_\b/, alias: "keyword" },
    "procedure-definition": {
      pattern: /\b\w+(?=[ \t]*(?::\s*){2}proc\b)/,
      alias: "function"
    },
    keyword: /\b(?:asm|auto_cast|bit_set|break|case|cast|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\b/,
    "procedure-name": { pattern: /\b\w+(?=[ \t]*\()/, alias: "function" },
    boolean: /\b(?:false|nil|true)\b/,
    "constant-parameter-sign": { pattern: /\$/, alias: "important" },
    undefined: { pattern: /---/, alias: "operator" },
    arrow: { pattern: /->/, alias: "punctuation" },
    operator: /\+\+|--|\.\.[<=]?|(?:&~|[-!*+/=~]|[%&<>|]{1,2})=?|[?^]/,
    punctuation: /[(),.:;@\[\]{}]/
  };
}(), function(e2) {
  e2.languages.opencl = e2.languages.extend("c", {
    keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
    boolean: /\b(?:false|true)\b/,
    "constant-opencl-kernel": {
      pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
      alias: "constant"
    }
  }), e2.languages.insertBefore("opencl", "class-name", {
    "builtin-type": {
      pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
      alias: "keyword"
    }
  });
  var t8 = {
    "type-opencl-host": {
      pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
      alias: "keyword"
    },
    "boolean-opencl-host": {
      pattern: /\bCL_(?:FALSE|TRUE)\b/,
      alias: "boolean"
    },
    "constant-opencl-host": {
      pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
      alias: "constant"
    },
    "function-opencl-host": {
      pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
      alias: "function"
    }
  };
  e2.languages.insertBefore("c", "keyword", t8), e2.languages.cpp && (t8["type-opencl-host-cpp"] = {
    pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
    alias: "keyword"
  }, e2.languages.insertBefore("cpp", "keyword", t8));
}(Prism), Prism.languages.openqasm = {
  comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
  string: { pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/, greedy: true },
  keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
  "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
  function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
  constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
  number: {
    pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
    lookbehind: true
  },
  operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
  punctuation: /[(){}\[\];,:.]/
}, Prism.languages.qasm = Prism.languages.openqasm, Prism.languages.oz = {
  comment: { pattern: /\/\*[\s\S]*?\*\/|%.*/, greedy: true },
  string: { pattern: /"(?:[^"\\]|\\[\s\S])*"/, greedy: true },
  atom: { pattern: /'(?:[^'\\]|\\[\s\S])*'/, greedy: true, alias: "builtin" },
  keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
  function: [
    /\b[a-z][A-Za-z\d]*(?=\()/,
    { pattern: /(\{)[A-Z][A-Za-z\d]*\b/, lookbehind: true }
  ],
  number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
  variable: /`(?:[^`\\]|\\.)+`/,
  "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
  operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
  punctuation: /[\[\](){}.:;?]/
}, Prism.languages.parigp = {
  comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
  string: { pattern: /"(?:[^"\\\r\n]|\\.)*"/, greedy: true },
  keyword: function() {
    var e2 = (e2 = [
      "breakpoint",
      "break",
      "dbg_down",
      "dbg_err",
      "dbg_up",
      "dbg_x",
      "forcomposite",
      "fordiv",
      "forell",
      "forpart",
      "forprime",
      "forstep",
      "forsubgroup",
      "forvec",
      "for",
      "iferr",
      "if",
      "local",
      "my",
      "next",
      "return",
      "until",
      "while"
    ]).map(function(e22) {
      return e22.split("").join(" *");
    }).join("|");
    return RegExp("\\b(?:" + e2 + ")\\b");
  }(),
  function: /\b\w(?:[\w ]*\w)?(?= *\()/,
  number: {
    pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
    lookbehind: true
  },
  operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
  punctuation: /[\[\]{}().,:;|]/
}, function(e2) {
  var t8 = e2.languages.parser = e2.languages.extend("markup", {
    keyword: {
      pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
      lookbehind: true
    },
    variable: {
      pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
      lookbehind: true,
      inside: { punctuation: /\.|:+/ }
    },
    function: {
      pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
      lookbehind: true,
      inside: {
        keyword: { pattern: /(^@)(?:GET_|SET_)/, lookbehind: true },
        punctuation: /\.|:+/
      }
    },
    escape: {
      pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
      alias: "builtin"
    },
    punctuation: /[\[\](){};]/
  }), t8 = e2.languages.insertBefore("parser", "keyword", {
    "parser-comment": {
      pattern: /(\s)#.*/,
      lookbehind: true,
      alias: "comment"
    },
    expression: {
      pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
      greedy: true,
      lookbehind: true,
      inside: {
        string: {
          pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
          lookbehind: true
        },
        keyword: t8.keyword,
        variable: t8.variable,
        function: t8.function,
        boolean: /\b(?:false|true)\b/,
        number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
        escape: t8.escape,
        operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
        punctuation: t8.punctuation
      }
    }
  });
  e2.languages.insertBefore(
    "inside",
    "punctuation",
    {
      expression: t8.expression,
      keyword: t8.keyword,
      variable: t8.variable,
      function: t8.function,
      escape: t8.escape,
      "parser-punctuation": { pattern: t8.punctuation, alias: "punctuation" }
    },
    t8.tag.inside["attr-value"]
  );
}(Prism), Prism.languages.pascal = {
  directive: {
    pattern: /\{\$[\s\S]*?\}/,
    greedy: true,
    alias: ["marco", "property"]
  },
  comment: { pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/, greedy: true },
  string: {
    pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
    greedy: true
  },
  asm: {
    pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
    lookbehind: true,
    greedy: true,
    inside: null
  },
  keyword: [
    {
      pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
      lookbehind: true
    },
    {
      pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
      lookbehind: true
    },
    {
      pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
      lookbehind: true
    },
    {
      pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
      lookbehind: true
    }
  ],
  number: [/(?:[&%]\d+|\$[a-f\d]+)/i, /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i],
  operator: [
    /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
    {
      pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
      lookbehind: true
    }
  ],
  punctuation: /\(\.|\.\)|[()\[\]:;,.]/
}, Prism.languages.pascal.asm.inside = Prism.languages.extend("pascal", {
  asm: void 0,
  keyword: void 0,
  operator: void 0
}), Prism.languages.objectpascal = Prism.languages.pascal, function(e2) {
  var t8 = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source, n2 = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
    /<braces>/g,
    function() {
      return t8;
    }
  ), a = e2.languages.pascaligo = {
    comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
    string: {
      pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
      greedy: true
    },
    "class-name": [
      {
        pattern: RegExp(
          /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
            /<type>/g,
            function() {
              return n2;
            }
          ),
          "i"
        ),
        lookbehind: true,
        inside: null
      },
      {
        pattern: RegExp(
          /<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
            return n2;
          }),
          "i"
        ),
        inside: null
      },
      {
        pattern: RegExp(
          /(:\s*)<type>/.source.replace(/<type>/g, function() {
            return n2;
          })
        ),
        lookbehind: true,
        inside: null
      }
    ],
    keyword: {
      pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
      lookbehind: true
    },
    boolean: { pattern: /(^|[^&])\b(?:False|True)\b/i, lookbehind: true },
    builtin: {
      pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
      lookbehind: true
    },
    function: /\b\w+(?=\s*\()/,
    number: [
      /%[01]+|&[0-7]+|\$[a-f\d]+/i,
      /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
    ],
    operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
    punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
  }, r2 = ["comment", "keyword", "builtin", "operator", "punctuation"].reduce(
    function(e22, t22) {
      return e22[t22] = a[t22], e22;
    },
    {}
  );
  a["class-name"].forEach(function(e22) {
    e22.inside = r2;
  });
}(Prism), Prism.languages.psl = {
  comment: { pattern: /#.*/, greedy: true },
  string: {
    pattern: /"(?:\\.|[^\\"])*"/,
    greedy: true,
    inside: { symbol: /\\[ntrbA-Z"\\]/ }
  },
  "heredoc-string": {
    pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
    alias: "string",
    greedy: true
  },
  keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
  constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
  boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
  variable: /\b(?:PslDebug|errno|exit_status)\b/,
  builtin: {
    pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
    alias: "builtin-function"
  },
  "foreach-variable": {
    pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
    lookbehind: true,
    greedy: true
  },
  function: /\b[_a-z]\w*\b(?=\s*\()/i,
  number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
  operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
  punctuation: /[(){}\[\];,]/
}, Prism.languages.pcaxis = {
  string: /"[^"]*"/,
  keyword: {
    pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
    lookbehind: true,
    greedy: true,
    inside: {
      keyword: /^[-A-Z\d]+/,
      language: {
        pattern: /^(\s*)\[[-\w]+\]/,
        lookbehind: true,
        inside: { punctuation: /^\[|\]$/, property: /[-\w]+/ }
      },
      "sub-key": {
        pattern: /^(\s*)\S[\s\S]*/,
        lookbehind: true,
        inside: {
          parameter: { pattern: /"[^"]*"/, alias: "property" },
          punctuation: /^\(|\)$|,/
        }
      }
    }
  },
  operator: /=/,
  tlist: {
    pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
    greedy: true,
    inside: {
      function: /^TLIST/,
      property: { pattern: /^(\s*\(\s*)\w+/, lookbehind: true },
      string: /"[^"]*"/,
      punctuation: /[(),]/,
      operator: /-/
    }
  },
  punctuation: /[;,]/,
  number: { pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/, lookbehind: true },
  boolean: /NO|YES/
}, Prism.languages.px = Prism.languages.pcaxis, Prism.languages.peoplecode = {
  comment: RegExp(
    [
      /\/\*[\s\S]*?\*\//.source,
      /\bREM[^;]*;/.source,
      /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
      /\/\+[\s\S]*?\+\//.source
    ].join("|")
  ),
  string: {
    pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
    greedy: true
  },
  variable: /%\w+/,
  "function-definition": {
    pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
    lookbehind: true,
    alias: "function"
  },
  "class-name": {
    pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
    lookbehind: true,
    inside: { punctuation: /:/ }
  },
  keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
  "operator-keyword": { pattern: /\b(?:and|not|or)\b/i, alias: "operator" },
  function: /[_a-z]\w*(?=\s*\()/i,
  boolean: /\b(?:false|true)\b/i,
  number: /\b\d+(?:\.\d+)?\b/,
  operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
  punctuation: /[:.;,()[\]]/
}, Prism.languages.pcode = Prism.languages.peoplecode, function(e2) {
  var t8 = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  e2.languages.perl = {
    comment: [
      { pattern: /(^\s*)=\w[\s\S]*?=cut.*/m, lookbehind: true, greedy: true },
      { pattern: /(^|[^\\$])#.*/, lookbehind: true, greedy: true }
    ],
    string: [
      {
        pattern: RegExp(
          /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            t8
          ].join("|") + ")"
        ),
        greedy: true
      },
      { pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/, greedy: true },
      { pattern: /'(?:[^'\\\r\n]|\\.)*'/, greedy: true }
    ],
    regex: [
      {
        pattern: RegExp(
          /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            t8
          ].join("|") + ")" + /[msixpodualngc]*/.source
        ),
        greedy: true
      },
      {
        pattern: RegExp(
          /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
            t8 + /\s*/.source + t8
          ].join("|") + ")" + /[msixpodualngcer]*/.source
        ),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    variable: [
      /[&*$@%]\{\^[A-Z]+\}/,
      /[&*$@%]\^[A-Z_]/,
      /[&*$@%]#?(?=\{)/,
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      /[&*$@%]\d+/,
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    filehandle: { pattern: /<(?![<=])\S*?>|\b_\b/, alias: "symbol" },
    "v-string": {
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    function: { pattern: /(\bsub[ \t]+)\w+/, lookbehind: true },
    keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    punctuation: /[{}[\];(),:]/
  };
}(Prism), function(e2) {
  var t8 = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
  e2.languages.phpdoc = e2.languages.extend("javadoclike", {
    parameter: {
      pattern: RegExp(
        "(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + t8 + "\\s+)?)\\$\\w+"
      ),
      lookbehind: true
    }
  }), e2.languages.insertBefore("phpdoc", "keyword", {
    "class-name": [
      {
        pattern: RegExp(
          "(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + t8
        ),
        lookbehind: true,
        inside: {
          keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
          punctuation: /[|\\[\]()]/
        }
      }
    ]
  }), e2.languages.javadoclike.addSupport("php", e2.languages.phpdoc);
}(Prism), Prism.languages.insertBefore("php", "variable", {
  this: { pattern: /\$this\b/, alias: "keyword" },
  global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
  scope: {
    pattern: /\b[\w\\]+::/,
    inside: { keyword: /\b(?:parent|self|static)\b/, punctuation: /::|\\/ }
  }
}), function(e2) {
  var t8 = /\$\w+|%[a-z]+%/, n2 = /\[[^[\]]*\]/.source, a = /(?:[drlu]|do|down|le|left|ri|right|up)/.source, a = "(?:-+" + a + "-+|\\.+" + a + "\\.+|-+(?:" + n2 + "-*)?|" + n2 + "-+|\\.+(?:" + n2 + "\\.*)?|" + n2 + "\\.+)", n2 = /(?:>{1,2}|\/{1,2}|\\{1,2}|\|>|[#*^+{xo])/.source;
  e2.languages["plant-uml"] = {
    comment: {
      pattern: /(^[ \t]*)(?:'.*|\/'[\s\S]*?'\/)/m,
      lookbehind: true,
      greedy: true
    },
    preprocessor: {
      pattern: /(^[ \t]*)!.*/m,
      lookbehind: true,
      greedy: true,
      alias: "property",
      inside: { variable: t8 }
    },
    delimiter: {
      pattern: /(^[ \t]*)@(?:end|start)uml\b/m,
      lookbehind: true,
      greedy: true,
      alias: "punctuation"
    },
    arrow: {
      pattern: RegExp(
        /(^|[^-.<>?|\\[\]ox])/.source + (/[[?]?[ox]?/.source + "(?:" + a + n2 + "|" + /(?:<{1,2}|\/{1,2}|\\{1,2}|<\||[#*^+}xo])/.source + a + "(?:" + n2 + ")?)" + /[ox]?[\]?]?/.source) + /(?![-.<>?|\\\]ox])/.source
      ),
      lookbehind: true,
      greedy: true,
      alias: "operator",
      inside: {
        expression: {
          pattern: /(\[)[^[\]]+(?=\])/,
          lookbehind: true,
          inside: null
        },
        punctuation: /\[(?=$|\])|^\]/
      }
    },
    string: { pattern: /"[^"]*"/, greedy: true },
    text: {
      pattern: /(\[[ \t]*[\r\n]+(?![\r\n]))[^\]]*(?=\])/,
      lookbehind: true,
      greedy: true,
      alias: "string"
    },
    keyword: [
      {
        pattern: /^([ \t]*)(?:abstract\s+class|end\s+(?:box|fork|group|merge|note|ref|split|title)|(?:fork|split)(?:\s+again)?|activate|actor|agent|alt|annotation|artifact|autoactivate|autonumber|backward|binary|boundary|box|break|caption|card|case|circle|class|clock|cloud|collections|component|concise|control|create|critical|database|deactivate|destroy|detach|diamond|else|elseif|end|end[hr]note|endif|endswitch|endwhile|entity|enum|file|folder|footer|frame|group|[hr]?note|header|hexagon|hide|if|interface|label|legend|loop|map|namespace|network|newpage|node|nwdiag|object|opt|package|page|par|participant|person|queue|rectangle|ref|remove|repeat|restore|return|robust|scale|set|show|skinparam|stack|start|state|stop|storage|switch|title|together|usecase|usecase\/|while)(?=\s|$)/m,
        lookbehind: true,
        greedy: true
      },
      /\b(?:elseif|equals|not|while)(?=\s*\()/,
      /\b(?:as|is|then)\b/
    ],
    divider: { pattern: /^==.+==$/m, greedy: true, alias: "important" },
    time: {
      pattern: /@(?:\d+(?:[:/]\d+){2}|[+-]?\d+|:[a-z]\w*(?:[+-]\d+)?)\b/i,
      greedy: true,
      alias: "number"
    },
    color: { pattern: /#(?:[a-z_]+|[a-fA-F0-9]+)\b/, alias: "symbol" },
    variable: t8,
    punctuation: /[:,;()[\]{}]|\.{3}/
  }, e2.languages["plant-uml"].arrow.inside.expression.inside = e2.languages["plant-uml"], e2.languages.plantuml = e2.languages["plant-uml"];
}(Prism), Prism.languages.plsql = Prism.languages.extend("sql", {
  comment: { pattern: /\/\*[\s\S]*?\*\/|--.*/, greedy: true },
  keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
  operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
}), Prism.languages.insertBefore("plsql", "operator", {
  label: { pattern: /<<\s*\w+\s*>>/, alias: "symbol" }
}), Prism.languages.powerquery = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true,
    greedy: true
  },
  "quoted-identifier": { pattern: /#"(?:[^"\r\n]|"")*"(?!")/, greedy: true },
  string: { pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/, greedy: true },
  constant: [
    /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
    /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
    /\bOccurrence\.(?:All|First|Last)\b/,
    /\bOrder\.(?:Ascending|Descending)\b/,
    /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
    /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
    /\bQuoteStyle\.(?:Csv|None)\b/,
    /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
    /\bGroupKind\.(?:Global|Local)\b/,
    /\bExtraValues\.(?:Error|Ignore|List)\b/,
    /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
    /\bJoinSide\.(?:Left|Right)\b/,
    /\bPrecision\.(?:Decimal|Double)\b/,
    /\bRelativePosition\.From(?:End|Start)\b/,
    /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
    /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
    /\bnull\b/
  ],
  boolean: /\b(?:false|true)\b/,
  keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
  function: { pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i, lookbehind: true },
  "data-type": {
    pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
    alias: "class-name"
  },
  number: {
    pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
    lookbehind: true
  },
  operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
  punctuation: /[,;\[\](){}]/
}, Prism.languages.pq = Prism.languages.powerquery, Prism.languages.mscript = Prism.languages.powerquery, function() {
  var e2 = Prism.languages.powershell = {
    comment: [
      { pattern: /(^|[^`])<#[\s\S]*?#>/, lookbehind: true },
      { pattern: /(^|[^`])#.*/, lookbehind: true }
    ],
    string: [
      { pattern: /"(?:`[\s\S]|[^`"])*"/, greedy: true, inside: null },
      { pattern: /'(?:[^']|'')*'/, greedy: true }
    ],
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    punctuation: /[|{}[\];(),.]/
  };
  e2.string[0].inside = {
    function: {
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: e2
    },
    boolean: e2.boolean,
    variable: e2.variable
  };
}(), Prism.languages.processing = Prism.languages.extend("clike", {
  keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
  function: /\b\w+(?=\s*\()/,
  operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
}), Prism.languages.insertBefore("processing", "number", {
  constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
  type: {
    pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
    alias: "class-name"
  }
}), Prism.languages.prolog = {
  comment: { pattern: /\/\*[\s\S]*?\*\/|%.*/, greedy: true },
  string: {
    pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
    greedy: true
  },
  builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
  function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
  number: /\b\d+(?:\.\d*)?/,
  operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
  punctuation: /[(){}\[\],]/
}, function(e2) {
  var t8 = ["on", "ignoring", "group_right", "group_left", "by", "without"], n2 = [
    "sum",
    "min",
    "max",
    "avg",
    "group",
    "stddev",
    "stdvar",
    "count",
    "count_values",
    "bottomk",
    "topk",
    "quantile"
  ].concat(t8, ["offset"]);
  e2.languages.promql = {
    comment: { pattern: /(^[ \t]*)#.*/m, lookbehind: true },
    "vector-match": {
      pattern: new RegExp("((?:" + t8.join("|") + ")\\s*)\\([^)]*\\)"),
      lookbehind: true,
      inside: {
        "label-key": { pattern: /\b[^,]+\b/, alias: "attr-name" },
        punctuation: /[(),]/
      }
    },
    "context-labels": {
      pattern: /\{[^{}]*\}/,
      inside: {
        "label-key": {
          pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
          alias: "attr-name"
        },
        "label-value": {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: true,
          alias: "attr-value"
        },
        punctuation: /\{|\}|=~?|![=~]|,/
      }
    },
    "context-range": [
      {
        pattern: /\[[\w\s:]+\]/,
        inside: {
          punctuation: /\[|\]|:/,
          "range-duration": {
            pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
            alias: "number"
          }
        }
      },
      {
        pattern: /(\boffset\s+)\w+/,
        lookbehind: true,
        inside: {
          "range-duration": {
            pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
            alias: "number"
          }
        }
      }
    ],
    keyword: new RegExp("\\b(?:" + n2.join("|") + ")\\b", "i"),
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
    operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
    punctuation: /[{};()`,.[\]]/
  };
}(Prism), Prism.languages.properties = {
  comment: /^[ \t]*[#!].*$/m,
  value: {
    pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
    lookbehind: true,
    alias: "attr-value"
  },
  key: {
    pattern: /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
    alias: "attr-name"
  },
  punctuation: /[=:]/
}, function(e2) {
  var t8 = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
  e2.languages.protobuf = e2.languages.extend("clike", {
    "class-name": [
      {
        pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
        lookbehind: true
      },
      {
        pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
        lookbehind: true
      }
    ],
    keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
    function: /\b[a-z_]\w*(?=\s*\()/i
  }), e2.languages.insertBefore("protobuf", "operator", {
    map: {
      pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
      alias: "class-name",
      inside: { punctuation: /[<>.,]/, builtin: t8 }
    },
    builtin: t8,
    "positional-class-name": {
      pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
      alias: "class-name",
      inside: { punctuation: /\./ }
    },
    annotation: { pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i, lookbehind: true }
  });
}(Prism), function(e2) {
  var t8 = { pattern: /(\b\d+)(?:%|[a-z]+)/, lookbehind: true }, n2 = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true }, t8 = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    url: { pattern: /\burl\((["']?).*?\1\)/i, greedy: true },
    string: {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    interpolation: null,
    func: null,
    important: /\B!(?:important|optional)\b/i,
    keyword: {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    hexcode: /#[\da-f]{3,6}/i,
    color: [
      /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
      {
        pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
        inside: {
          unit: t8,
          number: n2,
          function: /[\w-]+(?=\()/,
          punctuation: /[(),]/
        }
      }
    ],
    entity: /\\[\da-f]{1,8}/i,
    unit: t8,
    boolean: /\b(?:false|true)\b/,
    operator: [
      /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
    ],
    number: n2,
    punctuation: /[{}()\[\];:,]/
  };
  t8.interpolation = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: "variable",
    inside: {
      delimiter: { pattern: /^\{|\}$/, alias: "punctuation" },
      rest: t8
    }
  }, t8.func = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: { function: /^[^(]+/, rest: t8 }
  }, e2.languages.stylus = {
    "atrule-declaration": {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: { atrule: /^@[\w-]+/, rest: t8 }
    },
    "variable-declaration": {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: { variable: /^\S+/, rest: t8 }
    },
    statement: {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: { keyword: /^\S+/, rest: t8 }
    },
    "property-declaration": {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        property: {
          pattern: /^[^\s:]+/,
          inside: { interpolation: t8.interpolation }
        },
        rest: t8
      }
    },
    selector: {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        interpolation: t8.interpolation,
        comment: t8.comment,
        punctuation: /[{},]/
      }
    },
    func: t8.func,
    string: t8.string,
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    interpolation: t8.interpolation,
    punctuation: /[{}()\[\];:.]/
  };
}(Prism), Prism.languages.twig = {
  comment: /^\{#[\s\S]*?#\}$/,
  "tag-name": { pattern: /(^\{%-?\s*)\w+/, lookbehind: true, alias: "keyword" },
  delimiter: { pattern: /^\{[{%]-?|-?[%}]\}$/, alias: "punctuation" },
  string: {
    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    inside: { punctuation: /^['"]|['"]$/ }
  },
  keyword: /\b(?:even|if|odd)\b/,
  boolean: /\b(?:false|null|true)\b/,
  number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
  operator: [
    {
      pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
      lookbehind: true
    },
    /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
  ],
  punctuation: /[()\[\]{}:.,]/
}, Prism.hooks.add("before-tokenize", function(e2) {
  "twig" === e2.language && Prism.languages["markup-templating"].buildPlaceholders(
    e2,
    "twig",
    /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g
  );
}), Prism.hooks.add("after-tokenize", function(e2) {
  Prism.languages["markup-templating"].tokenizePlaceholders(e2, "twig");
}), function(e2) {
  e2.languages.pug = {
    comment: {
      pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
      lookbehind: true
    },
    "multiline-script": {
      pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
      lookbehind: true,
      inside: e2.languages.javascript
    },
    filter: {
      pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
      lookbehind: true,
      inside: {
        "filter-name": { pattern: /^:[\w-]+/, alias: "variable" },
        text: /\S[\s\S]*/
      }
    },
    "multiline-plain-text": {
      pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
      lookbehind: true
    },
    markup: {
      pattern: /(^[\t ]*)<.+/m,
      lookbehind: true,
      inside: e2.languages.markup
    },
    doctype: { pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/, lookbehind: true },
    "flow-control": {
      pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
      lookbehind: true,
      inside: {
        each: {
          pattern: /^each .+? in\b/,
          inside: { keyword: /\b(?:each|in)\b/, punctuation: /,/ }
        },
        branch: {
          pattern: /^(?:case|default|else|if|unless|when|while)\b/,
          alias: "keyword"
        },
        rest: e2.languages.javascript
      }
    },
    keyword: {
      pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
      lookbehind: true
    },
    mixin: [
      {
        pattern: /(^[\t ]*)mixin .+/m,
        lookbehind: true,
        inside: {
          keyword: /^mixin/,
          function: /\w+(?=\s*\(|\s*$)/,
          punctuation: /[(),.]/
        }
      },
      {
        pattern: /(^[\t ]*)\+.+/m,
        lookbehind: true,
        inside: {
          name: { pattern: /^\+\w+/, alias: "function" },
          rest: e2.languages.javascript
        }
      }
    ],
    script: {
      pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
      lookbehind: true,
      inside: e2.languages.javascript
    },
    "plain-text": {
      pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
      lookbehind: true
    },
    tag: {
      pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
      lookbehind: true,
      inside: {
        attributes: [
          { pattern: /&[^(]+\([^)]+\)/, inside: e2.languages.javascript },
          {
            pattern: /\([^)]+\)/,
            inside: {
              "attr-value": {
                pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                lookbehind: true,
                inside: e2.languages.javascript
              },
              "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
              punctuation: /[!=(),]+/
            }
          }
        ],
        punctuation: /:/,
        "attr-id": /#[\w\-]+/,
        "attr-class": /\.[\w\-]+/
      }
    },
    code: [
      {
        pattern: /(^[\t ]*(?:-|!?=)).+/m,
        lookbehind: true,
        inside: e2.languages.javascript
      }
    ],
    punctuation: /[.\-!=|]+/
  };
  for (var t8 = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source, n2 = [
    { filter: "atpl", language: "twig" },
    { filter: "coffee", language: "coffeescript" },
    "ejs",
    "handlebars",
    "less",
    "livescript",
    "markdown",
    { filter: "sass", language: "scss" },
    "stylus"
  ], a = {}, r2 = 0, i = n2.length; r2 < i; r2++) {
    var o2 = n2[r2];
    e2.languages[(o2 = "string" == typeof o2 ? { filter: o2, language: o2 } : o2).language] && (a["filter-" + o2.filter] = {
      pattern: RegExp(
        t8.replace("<filter_name>", function() {
          return o2.filter;
        }),
        "m"
      ),
      lookbehind: true,
      inside: {
        "filter-name": { pattern: /^:[\w-]+/, alias: "variable" },
        text: {
          pattern: /\S[\s\S]*/,
          alias: [o2.language, "language-" + o2.language],
          inside: e2.languages[o2.language]
        }
      }
    });
  }
  e2.languages.insertBefore("pug", "filter", a);
}(Prism), function(e2) {
  e2.languages.puppet = {
    heredoc: [
      {
        pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
        lookbehind: true,
        alias: "string",
        inside: { punctuation: /(?=\S).*\S(?= *$)/ }
      },
      {
        pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
        lookbehind: true,
        greedy: true,
        alias: "string",
        inside: { punctuation: /(?=\S).*\S(?= *$)/ }
      },
      {
        pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
        alias: "string",
        inside: { punctuation: { pattern: /(\().+?(?=\))/, lookbehind: true } }
      }
    ],
    "multiline-comment": {
      pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
      lookbehind: true,
      greedy: true,
      alias: "comment"
    },
    regex: {
      pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "extended-regex": {
          pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
          inside: { comment: /#.*/ }
        }
      }
    },
    comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true },
    string: {
      pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
      greedy: true,
      inside: { "double-quoted": { pattern: /^"[\s\S]*"$/, inside: {} } }
    },
    variable: {
      pattern: /\$(?:::)?\w+(?:::\w+)*/,
      inside: { punctuation: /::/ }
    },
    "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
    function: [
      { pattern: /(\.)(?!\d)\w+/, lookbehind: true },
      /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
    ],
    number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
    boolean: /\b(?:false|true)\b/,
    keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
    datatype: {
      pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
      alias: "symbol"
    },
    operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
    punctuation: /[\[\]{}().,;]|:+/
  };
  var t8 = [
    {
      pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
      lookbehind: true,
      inside: {
        "short-variable": {
          pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
          lookbehind: true,
          alias: "variable",
          inside: { punctuation: /::/ }
        },
        delimiter: { pattern: /^\$/, alias: "variable" },
        rest: e2.languages.puppet
      }
    },
    {
      pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
      lookbehind: true,
      alias: "variable",
      inside: { punctuation: /::/ }
    }
  ];
  e2.languages.puppet.heredoc[0].inside.interpolation = t8, e2.languages.puppet.string.inside["double-quoted"].inside.interpolation = t8;
}(Prism), function(a) {
  a.languages.pure = {
    comment: [
      { pattern: /(^|[^\\])\/\*[\s\S]*?\*\//, lookbehind: true },
      { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true },
      /#!.+/
    ],
    "inline-lang": {
      pattern: /%<[\s\S]+?%>/,
      greedy: true,
      inside: {
        lang: {
          pattern: /(^%< *)-\*-.+?-\*-/,
          lookbehind: true,
          alias: "comment"
        },
        delimiter: { pattern: /^%<.*|%>$/, alias: "punctuation" }
      }
    },
    string: { pattern: /"(?:\\.|[^"\\\r\n])*"/, greedy: true },
    number: {
      pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
      lookbehind: true
    },
    keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
    function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
    special: { pattern: /\b__[a-z]+__\b/i, alias: "builtin" },
    operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
    punctuation: /[(){}\[\];,|]/
  };
  var r2 = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
  ["c", { lang: "c++", alias: "cpp" }, "fortran"].forEach(function(e2) {
    var t8, n2 = e2;
    "string" != typeof e2 && (n2 = e2.alias, e2 = e2.lang), a.languages[n2] && ((t8 = {})["inline-lang-" + n2] = {
      pattern: RegExp(
        r2.replace("<lang>", e2.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")),
        "i"
      ),
      inside: a.util.clone(a.languages.pure["inline-lang"].inside)
    }, t8["inline-lang-" + n2].inside.rest = a.util.clone(a.languages[n2]), a.languages.insertBefore("pure", "inline-lang", t8));
  }), a.languages.c && (a.languages.pure["inline-lang"].inside.rest = a.util.clone(
    a.languages.c
  ));
}(Prism), Prism.languages.purebasic = Prism.languages.extend("clike", {
  comment: /;.*/,
  keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
  function: /\b\w+(?:\.\w+)?\s*(?=\()/,
  number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
  operator: /(?:@\*?|\?|\*)\w+\$?|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
}), Prism.languages.insertBefore("purebasic", "keyword", {
  tag: /#\w+\$?/,
  asm: {
    pattern: /(^[\t ]*)!.*/m,
    lookbehind: true,
    alias: "tag",
    inside: {
      comment: /;.*/,
      string: { pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
      "label-reference-anonymous": {
        pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
        lookbehind: true,
        alias: "fasm-label"
      },
      "label-reference-addressed": {
        pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
        lookbehind: true,
        alias: "fasm-label"
      },
      keyword: [
        /\b(?:extern|global)\b[^;\r\n]*/i,
        /\b(?:CPU|DEFAULT|FLOAT)\b.*/
      ],
      function: {
        pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
        lookbehind: true
      },
      "function-inline": {
        pattern: /(:\s*)[\da-z]+(?=\s)/i,
        lookbehind: true,
        alias: "function"
      },
      label: {
        pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
        lookbehind: true,
        alias: "fasm-label"
      },
      register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
      number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
      operator: /[\[\]*+\-/%<>=&|$!,.:]/
    }
  }
}), delete Prism.languages.purebasic["class-name"], delete Prism.languages.purebasic.boolean, Prism.languages.pbfasm = Prism.languages.purebasic, Prism.languages.purescript = Prism.languages.extend("haskell", {
  keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
  "import-statement": {
    pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
    lookbehind: true,
    inside: { keyword: /\b(?:as|hiding|import)\b/, punctuation: /\./ }
  },
  builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
  operator: [
    Prism.languages.haskell.operator[0],
    Prism.languages.haskell.operator[2],
    /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
  ]
}), Prism.languages.purs = Prism.languages.purescript, Prism.languages.python = {
  comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      string: /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  string: {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  function: {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true },
  decorator: {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: { punctuation: /\./ }
  },
  keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, function(e2) {
  function a(e22, n22) {
    return e22.replace(/<<(\d+)>>/g, function(e3, t22) {
      return "(?:" + n22[+t22] + ")";
    });
  }
  function t8(e22, t22, n22) {
    return RegExp(a(e22, t22), n22 || "");
  }
  var n2 = RegExp(
    "\\b(?:" + "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within".trim().replace(/ /g, "|") + ")\\b"
  ), r2 = a(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [/\b[A-Za-z_]\w*\b/.source]), i = { keyword: n2, punctuation: /[<>()?,.:[\]]/ }, o2 = /"(?:\\.|[^\\"])*"/.source, r2 = (e2.languages.qsharp = e2.languages.extend("clike", {
    comment: /\/\/.*/,
    string: [
      {
        pattern: t8(/(^|[^$\\])<<0>>/.source, [o2]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        pattern: t8(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
          r2
        ]),
        lookbehind: true,
        inside: i
      },
      {
        pattern: t8(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [r2]),
        lookbehind: true,
        inside: i
      }
    ],
    keyword: n2,
    number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
    operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
    punctuation: /::|[{}[\];(),.:]/
  }), e2.languages.insertBefore("qsharp", "number", {
    range: { pattern: /\.\./, alias: "operator" }
  }), function(e22, t22) {
    for (var n22 = 0; n22 < t22; n22++)
      e22 = e22.replace(/<<self>>/g, function() {
        return "(?:" + e22 + ")";
      });
    return e22.replace(/<<self>>/g, "[^\\s\\S]");
  }(a(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [o2]), 2));
  e2.languages.insertBefore("qsharp", "string", {
    "interpolation-string": {
      pattern: t8(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [r2]),
      greedy: true,
      inside: {
        interpolation: {
          pattern: t8(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [r2]),
          lookbehind: true,
          inside: {
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-qsharp",
              inside: e2.languages.qsharp
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  });
}(Prism), Prism.languages.qs = Prism.languages.qsharp, Prism.languages.q = {
  string: /"(?:\\.|[^"\\\r\n])*"/,
  comment: [
    { pattern: /([\t )\]}])\/.*/, lookbehind: true, greedy: true },
    {
      pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m, greedy: true },
    { pattern: /^#!.+/m, greedy: true }
  ],
  symbol: /`(?::\S+|[\w.]*)/,
  datetime: {
    pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
    alias: "number"
  },
  number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
  keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
  adverb: { pattern: /['\/\\]:?|\beach\b/, alias: "function" },
  verb: {
    pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
    alias: "operator"
  },
  punctuation: /[(){}\[\];.]/
}, function(e2) {
  for (var t8 = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source, n2 = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source, a = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
    return t8;
  }).replace(/<comment>/g, function() {
    return n2;
  }), r2 = 0; r2 < 2; r2++)
    a = a.replace(/<expr>/g, function() {
      return a;
    });
  a = a.replace(/<expr>/g, "[^\\s\\S]"), e2.languages.qml = {
    comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
    "javascript-function": {
      pattern: RegExp(
        /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
          /<js>/g,
          function() {
            return a;
          }
        ),
        "m"
      ),
      lookbehind: true,
      greedy: true,
      alias: "language-javascript",
      inside: e2.languages.javascript
    },
    "class-name": {
      pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
      lookbehind: true
    },
    property: [
      {
        pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
        lookbehind: true
      },
      {
        pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
        lookbehind: true,
        inside: { keyword: /^property/, property: /\w+(?:\.\w+)*/ }
      }
    ],
    "javascript-expression": {
      pattern: RegExp(
        /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
          /<js>/g,
          function() {
            return a;
          }
        ),
        "m"
      ),
      lookbehind: true,
      greedy: true,
      alias: "language-javascript",
      inside: e2.languages.javascript
    },
    string: { pattern: /"(?:\\.|[^\\"\r\n])*"/, greedy: true },
    keyword: /\b(?:as|import|on)\b/,
    punctuation: /[{}[\]:;,]/
  };
}(Prism), Prism.languages.qore = Prism.languages.extend("clike", {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
    lookbehind: true
  },
  string: { pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/, greedy: true },
  keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
  boolean: /\b(?:false|true)\b/i,
  function: /\$?\b(?!\d)\w+(?=\()/,
  number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
  operator: {
    pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
    lookbehind: true
  },
  variable: /\$(?!\d)\w+\b/
}), Prism.languages.r = {
  comment: /#.*/,
  string: { pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  "percent-operator": { pattern: /%[^%\s]*%/, alias: "operator" },
  boolean: /\b(?:FALSE|TRUE)\b/,
  ellipsis: /\.\.(?:\.|\d+)/,
  number: [
    /\b(?:Inf|NaN)\b/,
    /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
  ],
  keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  punctuation: /[(){}\[\],;]/
}, Prism.languages.racket = Prism.languages.extend("scheme", {
  "lambda-parameter": {
    pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
    lookbehind: true
  }
}), Prism.languages.insertBefore("racket", "string", {
  lang: { pattern: /^#lang.+/m, greedy: true, alias: "keyword" }
}), Prism.languages.rkt = Prism.languages.racket, function(e2) {
  var a = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source, r2 = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
  function t8(e22, t22) {
    for (var n22 = 0; n22 < t22; n22++)
      e22 = e22.replace(/<self>/g, function() {
        return "(?:" + e22 + ")";
      });
    return e22.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + r2 + ")").replace(/<comment>/g, "(?:" + a + ")");
  }
  var n2 = t8(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2), i = t8(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 1), o2 = t8(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2), s2 = t8(/<(?:[^<>'"@/]|<comment>|<self>)*>/.source, 1), s2 = /@/.source + /(?:await\b\s*)?/.source + "(?:" + /(?!await\b)\w+\b/.source + "|" + n2 + ")(?:" + /[?!]?\.\w+\b/.source + "|(?:" + s2 + ")?" + n2 + "|" + i + ")*" + /(?![?!\.(\[]|<(?!\/))/.source, i = "(?:" + /"[^"@]*"|'[^'@]*'|[^\s'"@>=]+(?=[\s>])/.source + `|["'][^"'@]*(?:(?:` + (/@(?![\w()])/.source + "|" + s2) + `)[^"'@]*)+["'])`, l2 = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*<tagAttrValue>|(?=[\s/>])))+)?/.source.replace(
    /<tagAttrValue>/,
    i
  ), d2 = /(?!\d)[^\s>\/=$<%]+/.source + l2 + /\s*\/?>/.source, l2 = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + l2 + /\s*>/.source + "(?:" + /[^<]/.source + "|" + /<\/?(?!\1\b)/.source + d2 + "|" + t8(
    /<\1/.source + l2 + /\s*>/.source + "(?:" + /[^<]/.source + "|" + /<\/?(?!\1\b)/.source + d2 + "|<self>)*" + /<\/\1\s*>/.source,
    2
  ) + ")*" + /<\/\1\s*>/.source + "|" + /</.source + d2 + ")";
  e2.languages.cshtml = e2.languages.extend("markup", {});
  l2 = {
    pattern: /\S[\s\S]*/,
    alias: "language-csharp",
    inside: e2.languages.insertBefore(
      "csharp",
      "string",
      {
        html: { pattern: RegExp(l2), greedy: true, inside: e2.languages.cshtml }
      },
      { csharp: e2.languages.extend("csharp", {}) }
    )
  }, s2 = {
    pattern: RegExp(/(^|[^@])/.source + s2),
    lookbehind: true,
    greedy: true,
    alias: "variable",
    inside: { keyword: /^@/, csharp: l2 }
  };
  e2.languages.cshtml.tag.pattern = RegExp(/<\/?/.source + d2), e2.languages.cshtml.tag.inside["attr-value"].pattern = RegExp(
    /=\s*/.source + i
  ), e2.languages.insertBefore(
    "inside",
    "punctuation",
    { value: s2 },
    e2.languages.cshtml.tag.inside["attr-value"]
  ), e2.languages.insertBefore("cshtml", "prolog", {
    "razor-comment": {
      pattern: /@\*[\s\S]*?\*@/,
      greedy: true,
      alias: "comment"
    },
    block: {
      pattern: RegExp(
        /(^|[^@])@/.source + "(?:" + [
          o2,
          /(?:code|functions)\s*/.source + o2,
          /(?:for|foreach|lock|switch|using|while)\s*/.source + n2 + /\s*/.source + o2,
          /do\s*/.source + o2 + /\s*while\s*/.source + n2 + /(?:\s*;)?/.source,
          /try\s*/.source + o2 + /\s*catch\s*/.source + n2 + /\s*/.source + o2 + /\s*finally\s*/.source + o2,
          /if\s*/.source + n2 + /\s*/.source + o2 + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + n2 + ")?" + /\s*/.source + o2 + ")*",
          /helper\s+\w+\s*/.source + n2 + /\s*/.source + o2
        ].join("|") + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: { keyword: /^@\w*/, csharp: l2 }
    },
    directive: {
      pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
      lookbehind: true,
      greedy: true,
      inside: { keyword: /^@\w+/, csharp: l2 }
    },
    value: s2,
    "delegate-operator": {
      pattern: /(^|[^@])@(?=<)/,
      lookbehind: true,
      alias: "operator"
    }
  }), e2.languages.razor = e2.languages.cshtml;
}(Prism), function(i) {
  var e2 = i.util.clone(i.languages.javascript), n2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function t8(e22, t22) {
    return e22 = e22.replace(/<S>/g, function() {
      return n2;
    }).replace(/<BRACES>/g, function() {
      return a;
    }).replace(/<SPREAD>/g, function() {
      return r2;
    }), RegExp(e22, t22);
  }
  r2 = t8(r2).source, i.languages.jsx = i.languages.extend("markup", e2), i.languages.jsx.tag.pattern = t8(
    /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
  ), i.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, i.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, i.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, i.languages.jsx.tag.inside.comment = e2.comment, i.languages.insertBefore(
    "inside",
    "attr-name",
    { spread: { pattern: t8(/<SPREAD>/.source), inside: i.languages.jsx } },
    i.languages.jsx.tag
  ), i.languages.insertBefore(
    "inside",
    "special-attr",
    {
      script: {
        pattern: t8(/=<BRACES>/.source),
        alias: "language-javascript",
        inside: {
          "script-punctuation": {
            pattern: /^=(?=\{)/,
            alias: "punctuation"
          },
          rest: i.languages.jsx
        }
      }
    },
    i.languages.jsx.tag
  );
  function o2(e22) {
    for (var t22 = [], n22 = 0; n22 < e22.length; n22++) {
      var a2 = e22[n22], r22 = false;
      "string" != typeof a2 && ("tag" === a2.type && a2.content[0] && "tag" === a2.content[0].type ? "</" === a2.content[0].content[0].content ? 0 < t22.length && t22[t22.length - 1].tagName === s2(a2.content[0].content[1]) && t22.pop() : "/>" !== a2.content[a2.content.length - 1].content && t22.push({ tagName: s2(a2.content[0].content[1]), openedBraces: 0 }) : 0 < t22.length && "punctuation" === a2.type && "{" === a2.content ? t22[t22.length - 1].openedBraces++ : 0 < t22.length && 0 < t22[t22.length - 1].openedBraces && "punctuation" === a2.type && "}" === a2.content ? t22[t22.length - 1].openedBraces-- : r22 = true), (r22 || "string" == typeof a2) && 0 < t22.length && 0 === t22[t22.length - 1].openedBraces && (r22 = s2(a2), n22 < e22.length - 1 && ("string" == typeof e22[n22 + 1] || "plain-text" === e22[n22 + 1].type) && (r22 += s2(e22[n22 + 1]), e22.splice(n22 + 1, 1)), 0 < n22 && ("string" == typeof e22[n22 - 1] || "plain-text" === e22[n22 - 1].type) && (r22 = s2(e22[n22 - 1]) + r22, e22.splice(n22 - 1, 1), n22--), e22[n22] = new i.Token("plain-text", r22, null, r22)), a2.content && "string" != typeof a2.content && o2(a2.content);
    }
  }
  var s2 = function(e22) {
    return e22 ? "string" == typeof e22 ? e22 : "string" == typeof e22.content ? e22.content : e22.content.map(s2).join("") : "";
  };
  i.hooks.add("after-tokenize", function(e22) {
    "jsx" !== e22.language && "tsx" !== e22.language || o2(e22.tokens);
  });
}(Prism), function(e2) {
  var t8 = e2.util.clone(e2.languages.typescript), t8 = (e2.languages.tsx = e2.languages.extend("jsx", t8), delete e2.languages.tsx.parameter, delete e2.languages.tsx["literal-property"], e2.languages.tsx.tag);
  t8.pattern = RegExp(
    /(^|[^\w$]|(?=<\/))/.source + "(?:" + t8.pattern.source + ")",
    t8.pattern.flags
  ), t8.lookbehind = true;
}(Prism), Prism.languages.reason = Prism.languages.extend("clike", {
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true },
  "class-name": /\b[A-Z]\w*/,
  keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
  operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
}), Prism.languages.insertBefore("reason", "class-name", {
  char: {
    pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
    greedy: true
  },
  constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
  label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" }
}), delete Prism.languages.reason.function, Prism.languages.rego = {
  comment: /#.*/,
  property: {
    pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
    lookbehind: true,
    greedy: true
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
  boolean: /\b(?:false|true)\b/,
  function: {
    pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
    inside: { namespace: /\b\w+\b(?=\s*\.)/, punctuation: /\./ }
  },
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
  punctuation: /[,;.\[\]{}()]/
}, Prism.languages.renpy = {
  comment: { pattern: /(^|[^\\])#.+/, lookbehind: true },
  string: {
    pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
    greedy: true
  },
  function: /\b[a-z_]\w*(?=\()/i,
  property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
  tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
  keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
  boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
  number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
  operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.rpy = Prism.languages.renpy, Prism.languages.rescript = {
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true },
  char: { pattern: /'(?:[^\r\n\\]|\\(?:.|\w+))'/, greedy: true },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true },
  "class-name": /\b[A-Z]\w*|@[a-z.]*|#[A-Za-z]\w*|#\d/,
  function: { pattern: /[a-zA-Z]\w*(?=\()|(\.)[a-z]\w*/, lookbehind: true },
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  boolean: /\b(?:false|true)\b/,
  "attr-value": /[A-Za-z]\w*(?==)/,
  constant: { pattern: /(\btype\s+)[a-z]\w*/, lookbehind: true },
  tag: {
    pattern: /(<)[a-z]\w*|(?:<\/)[a-z]\w*/,
    lookbehind: true,
    inside: { operator: /<|>|\// }
  },
  keyword: /\b(?:and|as|assert|begin|bool|class|constraint|do|done|downto|else|end|exception|external|float|for|fun|function|if|in|include|inherit|initializer|int|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|string|switch|then|to|try|type|when|while|with)\b/,
  operator: /\.{3}|:[:=]?|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/,
  punctuation: /[(){}[\],;.]/
}, Prism.languages.insertBefore("rescript", "string", {
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": { pattern: /^`|`$/, alias: "string" },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "tag" },
          rest: Prism.languages.rescript
        }
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.res = Prism.languages.rescript, Prism.languages.rest = {
  table: [
    {
      pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
      lookbehind: true,
      inside: { punctuation: /\||(?:\+[=-]+)+\+/ }
    },
    {
      pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
      lookbehind: true,
      inside: { punctuation: /[=-]+/ }
    }
  ],
  "substitution-def": {
    pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
    lookbehind: true,
    inside: {
      substitution: {
        pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
        alias: "attr-value",
        inside: { punctuation: /^\||\|$/ }
      },
      directive: {
        pattern: /( )(?! )[^:]+::/,
        lookbehind: true,
        alias: "function",
        inside: { punctuation: /::$/ }
      }
    }
  },
  "link-target": [
    {
      pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
      lookbehind: true,
      alias: "string",
      inside: { punctuation: /^\[|\]$/ }
    },
    {
      pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
      lookbehind: true,
      alias: "string",
      inside: { punctuation: /^_|:$/ }
    }
  ],
  directive: {
    pattern: /(^[\t ]*\.\. )[^:]+::/m,
    lookbehind: true,
    alias: "function",
    inside: { punctuation: /::$/ }
  },
  comment: {
    pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
    lookbehind: true
  },
  title: [
    {
      pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
      inside: {
        punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
        important: /.+/
      }
    },
    {
      pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
      lookbehind: true,
      inside: {
        punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
        important: /.+/
      }
    }
  ],
  hr: {
    pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
    lookbehind: true,
    alias: "punctuation"
  },
  field: {
    pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
    lookbehind: true,
    alias: "attr-name"
  },
  "command-line-option": {
    pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
    lookbehind: true,
    alias: "symbol"
  },
  "literal-block": {
    pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
    inside: {
      "literal-block-punctuation": { pattern: /^::/, alias: "punctuation" }
    }
  },
  "quoted-literal-block": {
    pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
    inside: {
      "literal-block-punctuation": {
        pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
        alias: "punctuation"
      }
    }
  },
  "list-bullet": {
    pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
    lookbehind: true,
    alias: "punctuation"
  },
  "doctest-block": {
    pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
    lookbehind: true,
    inside: { punctuation: /^>>>/ }
  },
  inline: [
    {
      pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
      lookbehind: true,
      inside: {
        bold: { pattern: /(^\*\*).+(?=\*\*$)/, lookbehind: true },
        italic: { pattern: /(^\*).+(?=\*$)/, lookbehind: true },
        "inline-literal": {
          pattern: /(^``).+(?=``$)/,
          lookbehind: true,
          alias: "symbol"
        },
        role: {
          pattern: /^:[^:]+:|:[^:]+:$/,
          alias: "function",
          inside: { punctuation: /^:|:$/ }
        },
        "interpreted-text": {
          pattern: /(^`).+(?=`$)/,
          lookbehind: true,
          alias: "attr-value"
        },
        substitution: {
          pattern: /(^\|).+(?=\|$)/,
          lookbehind: true,
          alias: "attr-value"
        },
        punctuation: /\*\*?|``?|\|/
      }
    }
  ],
  link: [
    {
      pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
      alias: "string",
      inside: { punctuation: /^\[|\]_$/ }
    },
    {
      pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
      alias: "string",
      inside: { punctuation: /^_?`|`$|`?_?_$/ }
    }
  ],
  punctuation: {
    pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
    lookbehind: true
  }
}, Prism.languages.rip = {
  comment: { pattern: /#.*/, greedy: true },
  char: { pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/, greedy: true },
  string: { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: true },
  regex: {
    pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
    lookbehind: true,
    greedy: true
  },
  keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
  builtin: /@|\bSystem\b/,
  boolean: /\b(?:false|true)\b/,
  date: /\b\d{4}-\d{2}-\d{2}\b/,
  time: /\b\d{2}:\d{2}:\d{2}\b/,
  datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
  symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
  number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
  punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
  reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
}, Prism.languages.roboconf = {
  comment: /#.*/,
  keyword: {
    pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
    lookbehind: true
  },
  component: { pattern: /[\w-]+(?=[ \t]*\{)/, alias: "variable" },
  property: /[\w.-]+(?=[ \t]*:)/,
  value: {
    pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
    lookbehind: true,
    alias: "attr-value"
  },
  optional: { pattern: /\(optional\)/, alias: "builtin" },
  wildcard: { pattern: /(\.)\*/, lookbehind: true, alias: "operator" },
  punctuation: /[{},.;:=]/
}, function(e2) {
  var r2 = { pattern: /(^[ \t]*| {2}|\t)#.*/m, lookbehind: true, greedy: true }, i = {
    pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
    lookbehind: true,
    inside: { punctuation: /^[$@&%]\{|\}$/ }
  };
  function t8(e22, t22) {
    var n22, a2 = {
      "section-header": { pattern: /^ ?\*{3}.+?\*{3}/, alias: "keyword" }
    };
    for (n22 in t22) a2[n22] = t22[n22];
    return a2.tag = {
      pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
      lookbehind: true,
      inside: { punctuation: /\[|\]/ }
    }, a2.variable = i, a2.comment = r2, {
      pattern: RegExp(
        /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
          /<name>/g,
          function() {
            return e22;
          }
        ),
        "im"
      ),
      alias: "section",
      inside: a2
    };
  }
  var n2 = {
    pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
    lookbehind: true,
    alias: "string"
  }, a = {
    pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
    lookbehind: true,
    alias: "function",
    inside: { variable: i }
  }, o2 = {
    pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
    lookbehind: true,
    inside: { variable: i }
  };
  e2.languages.robotframework = {
    settings: t8("Settings", {
      documentation: {
        pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
        lookbehind: true,
        alias: "string"
      },
      property: {
        pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: true
      }
    }),
    variables: t8("Variables"),
    "test-cases": t8("Test Cases", {
      "test-name": a,
      documentation: n2,
      property: o2
    }),
    keywords: t8("Keywords", {
      "keyword-name": a,
      documentation: n2,
      property: o2
    }),
    tasks: t8("Tasks", { "task-name": a, documentation: n2, property: o2 }),
    comment: r2
  }, e2.languages.robot = e2.languages.robotframework;
}(Prism), function(e2) {
  for (var t8 = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n2 = 0; n2 < 2; n2++)
    t8 = t8.replace(/<self>/g, function() {
      return t8;
    });
  t8 = t8.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e2.languages.rust = {
    comment: [
      {
        pattern: RegExp(/(^|[^\\])/.source + t8),
        lookbehind: true,
        greedy: true
      },
      { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
    ],
    string: {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    char: {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    attribute: {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: { string: null }
    },
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" },
        rest: null
      }
    },
    "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    variable: /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: true,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: true,
        alias: "namespace",
        inside: { punctuation: /::/ }
      }
    ],
    keyword: [
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    macro: { pattern: /\b\w+!/, alias: "property" },
    constant: /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    namespace: {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: { punctuation: /::/ }
    },
    number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    boolean: /\b(?:false|true)\b/,
    punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  }, e2.languages.rust["closure-params"].inside.rest = e2.languages.rust, e2.languages.rust.attribute.inside.string = e2.languages.rust.string;
}(Prism), function(e2) {
  var t8 = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source, n2 = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i, a = { pattern: RegExp(t8 + "[bx]"), alias: "number" }, r2 = { pattern: /&[a-z_]\w*/i }, i = {
    pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
    lookbehind: true,
    alias: "keyword"
  }, o2 = {
    pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
    alias: "keyword",
    lookbehind: true
  }, s2 = [
    /\/\*[\s\S]*?\*\//,
    { pattern: /(^[ \t]*|;\s*)\*[^;]*;/m, lookbehind: true }
  ], l2 = { pattern: RegExp(t8), greedy: true }, d2 = /[$%@.(){}\[\];,\\]/, c2 = { pattern: /%?\b\w+(?=\()/, alias: "keyword" }, u = {
    function: c2,
    "arg-value": { pattern: /(=\s*)[A-Z\.]+/i, lookbehind: true },
    operator: /=/,
    "macro-variable": r2,
    arg: { pattern: /[A-Z]+/i, alias: "keyword" },
    number: n2,
    "numeric-constant": a,
    punctuation: d2,
    string: l2
  }, p = {
    pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
    inside: {
      keyword: /^(?:format|put)(?==)/i,
      equals: /=/,
      format: { pattern: /(?:\w|\$\d)+\.\d?/, alias: "number" }
    }
  }, m = {
    pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
    inside: {
      keyword: /^(?:format|put)/i,
      format: { pattern: /[\w$]+\.\d?/, alias: "number" }
    }
  }, g2 = {
    pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
    lookbehind: true,
    alias: "keyword"
  }, b3 = {
    pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
    lookbehind: true,
    alias: "keyword"
  }, E2 = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source, f = {
    pattern: RegExp(
      /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
        /<act>/g,
        function() {
          return E2;
        }
      ),
      "i"
    ),
    lookbehind: true,
    inside: {
      keyword: RegExp(
        /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
          return E2;
        }),
        "i"
      ),
      action: { pattern: /(?:action)/i, alias: "keyword" },
      comment: s2,
      function: c2,
      "arg-value": u["arg-value"],
      operator: u.operator,
      argument: u.arg,
      number: n2,
      "numeric-constant": a,
      punctuation: d2,
      string: l2
    }
  }, h7 = {
    pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
    lookbehind: true
  };
  e2.languages.sas = {
    datalines: {
      pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
      lookbehind: true,
      alias: "string",
      inside: {
        keyword: { pattern: /^(?:cards|(?:data)?lines)/i },
        punctuation: /;/
      }
    },
    "proc-sql": {
      pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
      lookbehind: true,
      inside: {
        sql: {
          pattern: RegExp(
            /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
              /<str>/g,
              function() {
                return t8;
              }
            ),
            "im"
          ),
          alias: "language-sql",
          inside: e2.languages.sql
        },
        "global-statements": g2,
        "sql-statements": {
          pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
          lookbehind: true,
          alias: "keyword"
        },
        number: n2,
        "numeric-constant": a,
        punctuation: d2,
        string: l2
      }
    },
    "proc-groovy": {
      pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
      lookbehind: true,
      inside: {
        comment: s2,
        groovy: {
          pattern: RegExp(
            /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
              /<str>/g,
              function() {
                return t8;
              }
            ),
            "im"
          ),
          lookbehind: true,
          alias: "language-groovy",
          inside: e2.languages.groovy
        },
        keyword: h7,
        "submit-statement": b3,
        "global-statements": g2,
        number: n2,
        "numeric-constant": a,
        punctuation: d2,
        string: l2
      }
    },
    "proc-lua": {
      pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
      lookbehind: true,
      inside: {
        comment: s2,
        lua: {
          pattern: RegExp(
            /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
              /<str>/g,
              function() {
                return t8;
              }
            ),
            "im"
          ),
          lookbehind: true,
          alias: "language-lua",
          inside: e2.languages.lua
        },
        keyword: h7,
        "submit-statement": b3,
        "global-statements": g2,
        number: n2,
        "numeric-constant": a,
        punctuation: d2,
        string: l2
      }
    },
    "proc-cas": {
      pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
      lookbehind: true,
      inside: {
        comment: s2,
        "statement-var": {
          pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
          lookbehind: true,
          inside: {
            statement: {
              pattern: /^saveresult\s+\S+/i,
              inside: { keyword: /^(?:saveresult)/i }
            },
            rest: u
          }
        },
        "cas-actions": f,
        statement: {
          pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
          lookbehind: true,
          inside: u
        },
        step: o2,
        keyword: h7,
        function: c2,
        format: p,
        altformat: m,
        "global-statements": g2,
        number: n2,
        "numeric-constant": a,
        punctuation: d2,
        string: l2
      }
    },
    "proc-args": {
      pattern: RegExp(
        /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
          /<str>/g,
          function() {
            return t8;
          }
        ),
        "im"
      ),
      lookbehind: true,
      inside: u
    },
    "macro-keyword": i,
    "macro-variable": r2,
    "macro-string-functions": {
      pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
      lookbehind: true,
      inside: {
        function: {
          pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
          alias: "keyword"
        },
        "macro-keyword": i,
        "macro-variable": r2,
        "escaped-char": { pattern: /%['"()<>=¬^~;,#]/ },
        punctuation: d2
      }
    },
    "macro-declaration": {
      pattern: /^%macro[^;]+(?=;)/im,
      inside: { keyword: /%macro/i }
    },
    "macro-end": {
      pattern: /^%mend[^;]+(?=;)/im,
      inside: { keyword: /%mend/i }
    },
    macro: { pattern: /%_\w+(?=\()/, alias: "keyword" },
    input: {
      pattern: /\binput\s[-\w\s/*.$&]+;/i,
      inside: {
        input: { alias: "keyword", pattern: /^input/i },
        comment: s2,
        number: n2,
        "numeric-constant": a
      }
    },
    "options-args": {
      pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
      lookbehind: true,
      inside: u
    },
    "cas-actions": f,
    comment: s2,
    function: c2,
    format: p,
    altformat: m,
    "numeric-constant": a,
    datetime: { pattern: RegExp(t8 + "(?:dt?|t)"), alias: "number" },
    string: l2,
    step: o2,
    keyword: h7,
    "operator-keyword": {
      pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
      alias: "operator"
    },
    number: n2,
    operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
    punctuation: d2
  };
}(Prism), function(e2) {
  e2.languages.sass = e2.languages.extend("css", {
    comment: {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  }), e2.languages.insertBefore("sass", "atrule", {
    "atrule-line": {
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: { atrule: /(?:@[\w-]+|[+=])/ }
    }
  }), delete e2.languages.sass.atrule;
  var t8 = /\$[-\w]+|#\{\$[-\w]+\}/, n2 = [
    /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
    { pattern: /(\s)-(?=\s)/, lookbehind: true }
  ];
  e2.languages.insertBefore("sass", "property", {
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: { punctuation: /:/, variable: t8, operator: n2 }
    },
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        property: [
          /[^:\s]+(?=\s*:)/,
          { pattern: /(:)[^:\s]+/, lookbehind: true }
        ],
        punctuation: /:/,
        variable: t8,
        operator: n2,
        important: e2.languages.sass.important
      }
    }
  }), delete e2.languages.sass.property, delete e2.languages.sass.important, e2.languages.insertBefore("sass", "punctuation", {
    selector: {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
}(Prism), function(e2) {
  var t8 = [
    /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
    /'[^']*'/.source,
    /\$'(?:[^'\\]|\\[\s\S])*'/.source,
    /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
  ].join("|");
  e2.languages["shell-session"] = {
    command: {
      pattern: RegExp(
        /^/.source + "(?:" + /[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source + ")?" + /[$#%](?=\s)/.source + /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
          /<<str>>/g,
          function() {
            return t8;
          }
        ),
        "m"
      ),
      greedy: true,
      inside: {
        info: {
          pattern: /^[^#$%]+/,
          alias: "punctuation",
          inside: {
            user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
            punctuation: /:/,
            path: /[\s\S]+/
          }
        },
        bash: {
          pattern: /(^[$#%]\s*)\S[\s\S]*/,
          lookbehind: true,
          alias: "language-bash",
          inside: e2.languages.bash
        },
        "shell-symbol": { pattern: /^[$#%]/, alias: "important" }
      }
    },
    output: /.(?:.*(?:[\r\n]|.$))*/
  }, e2.languages["sh-session"] = e2.languages.shellsession = e2.languages["shell-session"];
}(Prism), Prism.languages.smali = {
  comment: /#.*/,
  string: {
    pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
    greedy: true
  },
  "class-name": {
    pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
    lookbehind: true,
    inside: {
      "class-name": {
        pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
        lookbehind: true
      },
      namespace: {
        pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
        lookbehind: true,
        inside: { punctuation: /\// }
      },
      builtin: /^L/
    }
  },
  builtin: [
    { pattern: /([();\[])[BCDFIJSVZ]+/, lookbehind: true },
    { pattern: /([\w$>]:)[BCDFIJSVZ]/, lookbehind: true }
  ],
  keyword: [
    { pattern: /(\.end\s+)[\w-]+/, lookbehind: true },
    { pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/, lookbehind: true },
    {
      pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
      lookbehind: true
    }
  ],
  function: { pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/, lookbehind: true },
  field: { pattern: /[\w$]+(?=:)/, alias: "variable" },
  register: {
    pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
    lookbehind: true,
    alias: "variable"
  },
  boolean: { pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/, lookbehind: true },
  number: {
    pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
    lookbehind: true
  },
  label: { pattern: /(:)\w+/, lookbehind: true, alias: "property" },
  operator: /->|\.\.|[\[=]/,
  punctuation: /[{}(),;:]/
}, Prism.languages.smalltalk = {
  comment: { pattern: /"(?:""|[^"])*"/, greedy: true },
  char: { pattern: /\$./, greedy: true },
  string: { pattern: /'(?:''|[^'])*'/, greedy: true },
  symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
  "block-arguments": {
    pattern: /(\[\s*):[^\[|]*\|/,
    lookbehind: true,
    inside: { variable: /:[\da-z]+/i, punctuation: /\|/ }
  },
  "temporary-variables": {
    pattern: /\|[^|]+\|/,
    inside: { variable: /[\da-z]+/i, punctuation: /\|/ }
  },
  keyword: /\b(?:new|nil|self|super)\b/,
  boolean: /\b(?:false|true)\b/,
  number: [
    /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
    /\b\d+(?:\.\d+)?(?:e-?\d+)?/
  ],
  operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
  punctuation: /[.;:?\[\](){}]/
}, function(n2) {
  n2.languages.smarty = {
    comment: { pattern: /^\{\*[\s\S]*?\*\}/, greedy: true },
    "embedded-php": {
      pattern: /^\{php\}[\s\S]*?\{\/php\}/,
      greedy: true,
      inside: {
        smarty: { pattern: /^\{php\}|\{\/php\}$/, inside: null },
        php: {
          pattern: /[\s\S]+/,
          alias: "language-php",
          inside: n2.languages.php
        }
      }
    },
    string: [
      {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /\{[^{}]*\}|`[^`]*`/,
            inside: {
              "interpolation-punctuation": {
                pattern: /^[{`]|[`}]$/,
                alias: "punctuation"
              },
              expression: { pattern: /[\s\S]+/, inside: null }
            }
          },
          variable: /\$\w+/
        }
      },
      { pattern: /'(?:\\.|[^'\\\r\n])*'/, greedy: true }
    ],
    keyword: {
      pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
      lookbehind: true,
      greedy: true
    },
    delimiter: { pattern: /^\{\/?|\}$/, greedy: true, alias: "punctuation" },
    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
    variable: [
      /\$(?!\d)\w+/,
      /#(?!\d)\w+#/,
      { pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/, lookbehind: true },
      { pattern: /(\[)(?!\d)\w+(?=\])/, lookbehind: true }
    ],
    function: {
      pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
      lookbehind: true
    },
    "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
    boolean: /\b(?:false|no|off|on|true|yes)\b/,
    punctuation: /[\[\](){}.,:`]|->/,
    operator: [
      /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
      /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
      /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
    ]
  }, n2.languages.smarty["embedded-php"].inside.smarty.inside = n2.languages.smarty, n2.languages.smarty.string[0].inside.interpolation.inside.expression.inside = n2.languages.smarty;
  var e2 = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/, a = RegExp(
    /\{\*[\s\S]*?\*\}/.source + "|" + /\{php\}[\s\S]*?\{\/php\}/.source + "|" + /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
      /<str>/g,
      function() {
        return e2.source;
      }
    ),
    "g"
  );
  n2.hooks.add("before-tokenize", function(e22) {
    var t8 = false;
    n2.languages["markup-templating"].buildPlaceholders(
      e22,
      "smarty",
      a,
      function(e3) {
        return !(t8 = "{/literal}" !== e3 && t8) && ("{literal}" === e3 && (t8 = true), true);
      }
    );
  }), n2.hooks.add("after-tokenize", function(e22) {
    n2.languages["markup-templating"].tokenizePlaceholders(e22, "smarty");
  });
}(Prism), function(e2) {
  var t8 = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
  e2.languages.sml = {
    comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
    string: { pattern: /#?"(?:[^"\\]|\\.)*"/, greedy: true },
    "class-name": [
      {
        pattern: RegExp(
          /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
            return /\s*(?:[*,]|->)/.source;
          }).replace(/<TERMINAL>/g, function() {
            return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
          }).replace(/<LONG-ID>/g, function() {
            return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
          }).replace(/<KEYWORD>/g, function() {
            return t8.source;
          }),
          "i"
        ),
        lookbehind: true,
        greedy: true,
        inside: null
      },
      {
        pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
        lookbehind: true
      }
    ],
    function: {
      pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
      lookbehind: true
    },
    keyword: t8,
    variable: { pattern: /(^|[^\w'])'[\w']*/, lookbehind: true },
    number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
    word: { pattern: /\b0w(?:\d+|x[\da-f]+)\b/i, alias: "constant" },
    boolean: /\b(?:false|true)\b/i,
    operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
    punctuation: /[(){}\[\].:,;]/
  }, e2.languages.sml["class-name"][0].inside = e2.languages.sml, e2.languages.smlnj = e2.languages.sml;
}(Prism), Prism.languages.solidity = Prism.languages.extend("clike", {
  "class-name": {
    pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
    lookbehind: true
  },
  keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
  operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
}), Prism.languages.insertBefore("solidity", "keyword", {
  builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
}), Prism.languages.insertBefore("solidity", "number", {
  version: {
    pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
    lookbehind: true,
    alias: "number"
  }
}), Prism.languages.sol = Prism.languages.solidity, function(e2) {
  var t8 = {
    pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
    alias: "constant",
    inside: { punctuation: /[{}]/ }
  };
  e2.languages["solution-file"] = {
    comment: { pattern: /#.*/, greedy: true },
    string: {
      pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
      greedy: true,
      inside: { guid: t8 }
    },
    object: {
      pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
      lookbehind: true,
      greedy: true,
      alias: "keyword"
    },
    property: {
      pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
      lookbehind: true,
      inside: { guid: t8 }
    },
    guid: t8,
    number: /\b\d+(?:\.\d+)*\b/,
    boolean: /\b(?:FALSE|TRUE)\b/,
    operator: /=/,
    punctuation: /[(),]/
  }, e2.languages.sln = e2.languages["solution-file"];
}(Prism), function(n2) {
  var e2 = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, t8 = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
  n2.languages.soy = {
    comment: [
      /\/\*[\s\S]*?\*\//,
      { pattern: /(\s)\/\/.*/, lookbehind: true, greedy: true }
    ],
    "command-arg": {
      pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
      lookbehind: true,
      alias: "string",
      inside: { punctuation: /\./ }
    },
    parameter: {
      pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
      lookbehind: true,
      alias: "variable"
    },
    keyword: [
      {
        pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
        lookbehind: true
      },
      /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
    ],
    delimiter: { pattern: /^\{+\/?|\/?\}+$/, alias: "punctuation" },
    property: /\w+(?==)/,
    variable: {
      pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
      inside: {
        string: { pattern: e2, greedy: true },
        number: t8,
        punctuation: /[\[\].?]/
      }
    },
    string: { pattern: e2, greedy: true },
    function: [/\w+(?=\()/, { pattern: /(\|[^\S\r\n]*)\w+/, lookbehind: true }],
    boolean: /\b(?:false|true)\b/,
    number: t8,
    operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
    punctuation: /[{}()\[\]|.,:]/
  }, n2.hooks.add("before-tokenize", function(e22) {
    var t22 = false;
    n2.languages["markup-templating"].buildPlaceholders(
      e22,
      "soy",
      /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g,
      function(e3) {
        return !(t22 = "{/literal}" !== e3 && t22) && ("{literal}" === e3 && (t22 = true), true);
      }
    );
  }), n2.hooks.add("after-tokenize", function(e22) {
    n2.languages["markup-templating"].tokenizePlaceholders(e22, "soy");
  });
}(Prism), Prism.languages.turtle = {
  comment: { pattern: /#.*/, greedy: true },
  "multiline-string": {
    pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
    greedy: true,
    alias: "string",
    inside: { comment: /#.*/ }
  },
  string: {
    pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
    greedy: true
  },
  url: {
    pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
    greedy: true,
    inside: { punctuation: /[<>]/ }
  },
  function: {
    pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
    inside: {
      "local-name": { pattern: /([^:]*:)[\s\S]+/, lookbehind: true },
      prefix: { pattern: /[\s\S]+/, inside: { punctuation: /:/ } }
    }
  },
  number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
  punctuation: /[{}.,;()[\]]|\^\^/,
  boolean: /\b(?:false|true)\b/,
  keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
  tag: { pattern: /@[a-z]+(?:-[a-z\d]+)*/i, inside: { punctuation: /@/ } }
}, Prism.languages.trig = Prism.languages.turtle, Prism.languages.sparql = Prism.languages.extend("turtle", {
  boolean: /\b(?:false|true)\b/i,
  variable: { pattern: /[?$]\w+/, greedy: true }
}), Prism.languages.insertBefore("sparql", "punctuation", {
  keyword: [
    /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
    /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
    /\b(?:BASE|GRAPH|PREFIX)\b/i
  ]
}), Prism.languages.rq = Prism.languages.sparql, Prism.languages["splunk-spl"] = {
  comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
  string: { pattern: /"(?:\\.|[^\\"])*"/, greedy: true },
  keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
  "operator-word": {
    pattern: /\b(?:and|as|by|not|or|xor)\b/i,
    alias: "operator"
  },
  function: /\b\w+(?=\s*\()/,
  property: /\b\w+(?=\s*=(?!=))/,
  date: {
    pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
    alias: "number"
  },
  number: /\b\d+(?:\.\d+)?\b/,
  boolean: /\b(?:f|false|t|true)\b/i,
  operator: /[<>=]=?|[-+*/%|]/,
  punctuation: /[()[\],]/
}, Prism.languages.sqf = Prism.languages.extend("clike", {
  string: { pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/, greedy: true },
  keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
  boolean: /\b(?:false|true)\b/i,
  function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
  number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
  operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
  "magic-variable": {
    pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
    alias: "keyword"
  },
  constant: /\bDIK(?:_[a-z\d]+)+\b/i
}), Prism.languages.insertBefore("sqf", "string", {
  macro: {
    pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      directive: { pattern: /#[a-z]+\b/i, alias: "keyword" },
      comment: Prism.languages.sqf.comment
    }
  }
}), delete Prism.languages.sqf["class-name"], Prism.languages.squirrel = Prism.languages.extend("clike", {
  comment: [
    Prism.languages.clike.comment[0],
    { pattern: /(^|[^\\:])(?:\/\/|#).*/, lookbehind: true, greedy: true }
  ],
  string: {
    pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
    lookbehind: true,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
    lookbehind: true,
    inside: { punctuation: /\./ }
  },
  keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
  number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
  operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
  punctuation: /[(){}\[\],;.]/
}), Prism.languages.insertBefore("squirrel", "string", {
  char: {
    pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
    lookbehind: true,
    greedy: true
  }
}), Prism.languages.insertBefore("squirrel", "operator", {
  "attribute-punctuation": { pattern: /<\/|\/>/, alias: "important" },
  lambda: { pattern: /@(?=\()/, alias: "operator" }
}), function(e2) {
  var t8 = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
  e2.languages.stan = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
    string: { pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/, greedy: true },
    directive: {
      pattern: /^([ \t]*)#include\b.*/m,
      lookbehind: true,
      alias: "property"
    },
    "function-arg": {
      pattern: RegExp(
        "(" + t8.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source
      ),
      lookbehind: true,
      alias: "function"
    },
    constraint: {
      pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
      lookbehind: true,
      inside: {
        expression: {
          pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
          lookbehind: true,
          inside: null
        },
        property: /\b[a-z]\w*(?=\s*=)/i,
        operator: /=/,
        punctuation: /^<|>$|,/
      }
    },
    keyword: [
      {
        pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
        alias: "program-block"
      },
      /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
      t8
    ],
    function: /\b[a-z]\w*(?=\s*\()/i,
    number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    boolean: /\b(?:false|true)\b/,
    operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
    punctuation: /[()\[\]{},;]/
  }, e2.languages.stan.constraint.inside.expression.inside = e2.languages.stan;
}(Prism), Prism.languages.stata = {
  comment: [
    { pattern: /(^[ \t]*)\*.*/m, lookbehind: true, greedy: true },
    { pattern: /(^|\s)\/\/.*|\/\*[\s\S]*?\*\//, lookbehind: true, greedy: true }
  ],
  "string-literal": {
    pattern: /"[^"\r\n]*"|[‘`']".*?"[’`']/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /\$\{[^{}]*\}|[‘`']\w[^’`'\r\n]*[’`']/,
        inside: {
          punctuation: /^\$\{|\}$/,
          expression: { pattern: /[\s\S]+/, inside: null }
        }
      },
      string: /[\s\S]+/
    }
  },
  mata: {
    pattern: /(^[ \t]*mata[ \t]*:)[\s\S]+?(?=^end\b)/m,
    lookbehind: true,
    greedy: true,
    alias: "language-mata",
    inside: Prism.languages.mata
  },
  java: {
    pattern: /(^[ \t]*java[ \t]*:)[\s\S]+?(?=^end\b)/m,
    lookbehind: true,
    greedy: true,
    alias: "language-java",
    inside: Prism.languages.java
  },
  python: {
    pattern: /(^[ \t]*python[ \t]*:)[\s\S]+?(?=^end\b)/m,
    lookbehind: true,
    greedy: true,
    alias: "language-python",
    inside: Prism.languages.python
  },
  command: {
    pattern: /(^[ \t]*(?:\.[ \t]+)?(?:(?:bayes|bootstrap|by|bysort|capture|collect|fmm|fp|frame|jackknife|mfp|mi|nestreg|noisily|permute|quietly|rolling|simulate|statsby|stepwise|svy|version|xi)\b[^:\r\n]*:[ \t]*|(?:capture|noisily|quietly|version)[ \t]+)?)[a-zA-Z]\w*/m,
    lookbehind: true,
    greedy: true,
    alias: "keyword"
  },
  variable: /\$\w+|[‘`']\w[^’`'\r\n]*[’`']/,
  keyword: /\b(?:bayes|bootstrap|by|bysort|capture|clear|collect|fmm|fp|frame|if|in|jackknife|mi[ \t]+estimate|mfp|nestreg|noisily|of|permute|quietly|rolling|simulate|sort|statsby|stepwise|svy|varlist|version|xi)\b/,
  boolean: /\b(?:off|on)\b/,
  number: /\b\d+(?:\.\d+)?\b|\B\.\d+/,
  function: /\b[a-z_]\w*(?=\()/i,
  operator: /\+\+|--|##?|[<>!=~]=?|[+\-*^&|/]/,
  punctuation: /[(){}[\],:]/
}, Prism.languages.stata["string-literal"].inside.interpolation.inside.expression.inside = Prism.languages.stata, Prism.languages.iecst = {
  comment: [
    {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
      lookbehind: true,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  keyword: [
    /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
    /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
  ],
  "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
  address: { pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/, alias: "symbol" },
  number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/,
  operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  punctuation: /[()[\].,;]/
}, Prism.languages.supercollider = {
  comment: {
    pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
    greedy: true
  },
  string: {
    pattern: /(^|[^\\])"(?:[^"\\]|\\[\s\S])*"/,
    lookbehind: true,
    greedy: true
  },
  char: { pattern: /\$(?:[^\\\r\n]|\\.)/, greedy: true },
  symbol: {
    pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'|\\\w+/,
    lookbehind: true,
    greedy: true
  },
  keyword: /\b(?:_|arg|classvar|const|nil|var|while)\b/,
  boolean: /\b(?:false|true)\b/,
  label: { pattern: /\b[a-z_]\w*(?=\s*:)/, alias: "property" },
  number: /\b(?:inf|pi|0x[0-9a-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(?:pi)?|\d+r[0-9a-zA-Z]+(?:\.[0-9a-zA-Z]+)?|\d+[sb]{1,4}\d*)\b/,
  "class-name": /\b[A-Z]\w*\b/,
  operator: /\.{2,3}|#(?![[{])|&&|[!=]==?|\+>>|\+{1,3}|-[->]|=>|>>|\?\?|@\|?@|\|(?:@|[!=]=)?\||!\?|<[!=>]|\*{1,2}|<{2,3}\*?|[-!%&/<>?@|=`]/,
  punctuation: /[{}()[\].:,;]|#[[{]/
}, Prism.languages.sclang = Prism.languages.supercollider, Prism.languages.swift = {
  comment: {
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        string: /[\s\S]+/
      }
    }
  ],
  directive: {
    pattern: RegExp(
      /#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/
    }
  },
  literal: {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": { pattern: /#\w+\b/, alias: "property" },
  attribute: { pattern: /@\w+/, alias: "atrule" },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  label: {
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: { pattern: /\bnil\b/, alias: "constant" },
  "short-argument": /\$\d+\b/,
  omit: { pattern: /\b_\b/, alias: "keyword" },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/
}, Prism.languages.swift["string-literal"].forEach(function(e2) {
  e2.inside.interpolation.inside = Prism.languages.swift;
}), function(e2) {
  var t8 = { pattern: /^[;#].*/m, greedy: true }, n2 = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
  e2.languages.systemd = {
    comment: t8,
    section: {
      pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
      greedy: true,
      inside: {
        punctuation: /^\[|\]$/,
        "section-name": { pattern: /[\s\S]+/, alias: "selector" }
      }
    },
    key: { pattern: /^[^\s=]+(?=[ \t]*=)/m, greedy: true, alias: "attr-name" },
    value: {
      pattern: RegExp(
        /(=[ \t]*(?!\s))/.source + "(?:" + n2 + '|(?=[^"\r\n]))(?:' + /[^\s\\]/.source + '|[ 	]+(?:(?![ 	"])|' + n2 + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source + ")*"
      ),
      lookbehind: true,
      greedy: true,
      alias: "attr-value",
      inside: {
        comment: t8,
        quoted: {
          pattern: RegExp(/(^|\s)/.source + n2),
          lookbehind: true,
          greedy: true
        },
        punctuation: /\\$/m,
        boolean: { pattern: /^(?:false|no|off|on|true|yes)$/, greedy: true }
      }
    },
    punctuation: /=/
  };
}(Prism), function(n2) {
  function a(e2, t8, n22) {
    return {
      pattern: RegExp("<#" + e2 + "[\\s\\S]*?#>"),
      alias: "block",
      inside: {
        delimiter: {
          pattern: RegExp("^<#" + e2 + "|#>$"),
          alias: "important"
        },
        content: { pattern: /[\s\S]+/, inside: t8, alias: n22 }
      }
    };
  }
  n2.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
    value: function(e2) {
      var t8 = n2.languages[e2], e2 = "language-" + e2;
      return {
        block: {
          pattern: /<#[\s\S]+?#>/,
          inside: {
            directive: a("@", {
              "attr-value": {
                pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                inside: { punctuation: /^=|^["']|["']$/ }
              },
              keyword: /\b\w+(?=\s)/,
              "attr-name": /\b\w+/
            }),
            expression: a("=", t8, e2),
            "class-feature": a("\\+", t8, e2),
            standard: a("", t8, e2)
          }
        }
      };
    }
  });
}(Prism), Prism.languages.t4 = Prism.languages["t4-cs"] = Prism.languages["t4-templating"].createT4("csharp"), Prism.languages.vbnet = Prism.languages.extend("basic", {
  comment: [
    { pattern: /(?:!|REM\b).+/i, inside: { keyword: /^REM/i } },
    { pattern: /(^|[^\\:])'.*/, lookbehind: true, greedy: true }
  ],
  string: {
    pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
    lookbehind: true,
    greedy: true
  },
  keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
  punctuation: /[,;:(){}]/
}), Prism.languages["t4-vb"] = Prism.languages["t4-templating"].createT4("vbnet"), Prism.languages.tap = {
  fail: /not ok[^#{\n\r]*/,
  pass: /ok[^#{\n\r]*/,
  pragma: /pragma [+-][a-z]+/,
  bailout: /bail out!.*/i,
  version: /TAP version \d+/i,
  plan: /\b\d+\.\.\d+(?: +#.*)?/,
  subtest: { pattern: /# Subtest(?:: .*)?/, greedy: true },
  punctuation: /[{}]/,
  directive: /#.*/,
  yamlish: {
    pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
    lookbehind: true,
    inside: Prism.languages.yaml,
    alias: "language-yaml"
  }
}, Prism.languages.tcl = {
  comment: { pattern: /(^|[^\\])#.*/, lookbehind: true },
  string: { pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/, greedy: true },
  variable: [
    { pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/, lookbehind: true },
    { pattern: /(\$)\{[^}]+\}/, lookbehind: true },
    {
      pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
      lookbehind: true
    }
  ],
  function: { pattern: /(^[\t ]*proc[ \t]+)\S+/m, lookbehind: true },
  builtin: [
    {
      pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
      lookbehind: true
    },
    /\b(?:else|elseif)\b/
  ],
  scope: {
    pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
    lookbehind: true,
    alias: "constant"
  },
  keyword: {
    pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
    lookbehind: true
  },
  operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
  punctuation: /[{}()\[\]]/
}, function(t8) {
  t8.languages.tt2 = t8.languages.extend("clike", {
    comment: /#.*|\[%#[\s\S]*?%\]/,
    keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
    punctuation: /[[\]{},()]/
  }), t8.languages.insertBefore("tt2", "number", {
    operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
    variable: { pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i }
  }), t8.languages.insertBefore("tt2", "keyword", {
    delimiter: { pattern: /^(?:\[%|%%)-?|-?%\]$/, alias: "punctuation" }
  }), t8.languages.insertBefore("tt2", "string", {
    "single-quoted-string": {
      pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
      greedy: true,
      alias: "string"
    },
    "double-quoted-string": {
      pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
      greedy: true,
      alias: "string",
      inside: {
        variable: { pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i }
      }
    }
  }), delete t8.languages.tt2.string, t8.hooks.add("before-tokenize", function(e2) {
    t8.languages["markup-templating"].buildPlaceholders(
      e2,
      "tt2",
      /\[%[\s\S]+?%\]/g
    );
  }), t8.hooks.add("after-tokenize", function(e2) {
    t8.languages["markup-templating"].tokenizePlaceholders(e2, "tt2");
  });
}(Prism), function(e2) {
  var t8 = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
  function n2(e22) {
    return e22.replace(/__/g, function() {
      return t8;
    });
  }
  e2.languages.toml = {
    comment: { pattern: /#.*/, greedy: true },
    table: {
      pattern: RegExp(
        n2(/(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source),
        "m"
      ),
      lookbehind: true,
      greedy: true,
      alias: "class-name"
    },
    key: {
      pattern: RegExp(
        n2(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
        "m"
      ),
      lookbehind: true,
      greedy: true,
      alias: "property"
    },
    string: {
      pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
      greedy: true
    },
    date: [
      {
        pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
        alias: "number"
      },
      { pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/, alias: "number" }
    ],
    number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
    boolean: /\b(?:false|true)\b/,
    punctuation: /[.,=[\]{}]/
  };
}(Prism), function(e2) {
  e2.languages.tremor = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    "interpolated-string": null,
    extractor: {
      pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
      greedy: true,
      inside: {
        regex: { pattern: /(^re)\|[\s\S]+/, lookbehind: true },
        function: /^\w+/,
        value: /\|[\s\S]+/
      }
    },
    identifier: { pattern: /`[^`]*`/, greedy: true },
    function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
    keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
    boolean: /\b(?:false|null|true)\b/i,
    number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
    "pattern-punctuation": { pattern: /%(?=[({[])/, alias: "punctuation" },
    operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
    punctuation: /::|[;\[\]()\{\},.:]/
  };
  var t8 = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
  e2.languages.tremor["interpolated-string"] = {
    pattern: RegExp(
      /(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + t8 + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + t8 + ')*")'
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      interpolation: {
        pattern: RegExp(t8),
        inside: {
          punctuation: /^#\{|\}$/,
          expression: { pattern: /[\s\S]+/, inside: e2.languages.tremor }
        }
      },
      string: /[\s\S]+/
    }
  }, e2.languages.troy = e2.languages.tremor, e2.languages.trickle = e2.languages.tremor;
}(Prism), function(e2) {
  var t8 = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
  e2.languages.typoscript = {
    comment: [
      { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true },
      {
        pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
        lookbehind: true,
        greedy: true
      },
      { pattern: /(^|[^"'])#.*/, lookbehind: true, greedy: true }
    ],
    function: [
      {
        pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
        inside: {
          string: {
            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
            inside: { keyword: t8 }
          },
          keyword: { pattern: /INCLUDE_TYPOSCRIPT/ }
        }
      },
      {
        pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
        inside: { string: /"[^"\r\n]*"|'[^'\r\n]*'/ }
      }
    ],
    string: {
      pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
      lookbehind: true,
      inside: {
        function: /\{\$.*\}/,
        keyword: t8,
        number: /^\d+$/,
        punctuation: /[,|:]/
      }
    },
    keyword: t8,
    number: { pattern: /\b\d+\s*[.{=]/, inside: { operator: /[.{=]/ } },
    tag: { pattern: /\.?[-\w\\]+\.?/, inside: { punctuation: /\./ } },
    punctuation: /[{}[\];(),.:|]/,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
  }, e2.languages.tsconfig = e2.languages.typoscript;
}(Prism), Prism.languages.unrealscript = {
  comment: /\/\/.*|\/\*[\s\S]*?\*\//,
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  category: {
    pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
    lookbehind: true,
    greedy: true,
    alias: "property"
  },
  metadata: {
    pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
    lookbehind: true,
    greedy: true,
    inside: {
      property: /\b\w+(?=\s*=)/,
      operator: /=/,
      punctuation: /[<>|]/
    }
  },
  macro: { pattern: /`\w+/, alias: "property" },
  "class-name": {
    pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
    lookbehind: true
  },
  keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  boolean: /\b(?:false|true)\b/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
  punctuation: /[()[\]{};,.]/
}, Prism.languages.uc = Prism.languages.uscript = Prism.languages.unrealscript, Prism.languages.uorazor = {
  "comment-hash": { pattern: /#.*/, alias: "comment", greedy: true },
  "comment-slash": { pattern: /\/\/.*/, alias: "comment", greedy: true },
  string: {
    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    inside: { punctuation: /^['"]|['"]$/ },
    greedy: true
  },
  "source-layers": {
    pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
    alias: "function"
  },
  "source-commands": {
    pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
    alias: "function"
  },
  "tag-name": { pattern: /(^\{%-?\s*)\w+/, lookbehind: true, alias: "keyword" },
  delimiter: { pattern: /^\{[{%]-?|-?[%}]\}$/, alias: "punctuation" },
  function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
  keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
  boolean: /\b(?:false|null|true)\b/,
  number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
  operator: [
    {
      pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
      lookbehind: true
    },
    /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
  ],
  punctuation: /[()\[\]{}:.,]/
}, function(e2) {
  var t8 = { pattern: /[\s\S]+/, inside: null };
  e2.languages.v = e2.languages.extend("clike", {
    string: {
      pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      alias: "quoted-string",
      greedy: true,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
          lookbehind: true,
          inside: {
            "interpolation-variable": {
              pattern: /^\$\w[\s\S]*$/,
              alias: "variable"
            },
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            "interpolation-expression": t8
          }
        }
      }
    },
    "class-name": {
      pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
      lookbehind: true
    },
    keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
    number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
    operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
    builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
  }), t8.inside = e2.languages.v, e2.languages.insertBefore("v", "string", {
    char: { pattern: /`(?:\\`|\\?[^`]{1,2})`/, alias: "rune" }
  }), e2.languages.insertBefore("v", "operator", {
    attribute: {
      pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
      lookbehind: true,
      alias: "annotation",
      inside: { punctuation: /[\[\]]/, keyword: /\w+/ }
    },
    generic: {
      pattern: /<\w+>(?=\s*[\)\{])/,
      inside: { punctuation: /[<>]/, "class-name": /\w+/ }
    }
  }), e2.languages.insertBefore("v", "function", {
    "generic-function": {
      pattern: /\b\w+\s*<\w+>(?=\()/,
      inside: {
        function: /^\w+/,
        generic: { pattern: /<\w+>/, inside: e2.languages.v.generic.inside }
      }
    }
  });
}(Prism), Prism.languages.vala = Prism.languages.extend("clike", {
  "class-name": [
    {
      pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
      inside: { punctuation: /\./ }
    },
    {
      pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
      lookbehind: true,
      inside: { punctuation: /\./ }
    },
    {
      pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
      lookbehind: true,
      inside: { punctuation: /\./ }
    },
    {
      pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
      lookbehind: true,
      inside: { punctuation: /\./ }
    }
  ],
  keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
  function: /\b\w+(?=\s*\()/,
  number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
  operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
  punctuation: /[{}[\];(),.:]/,
  constant: /\b[A-Z0-9_]+\b/
}), Prism.languages.insertBefore("vala", "string", {
  "raw-string": { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string" },
  "template-string": {
    pattern: /@"[\s\S]*?"/,
    greedy: true,
    inside: {
      interpolation: {
        pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
        inside: {
          delimiter: { pattern: /^\$\(?|\)$/, alias: "punctuation" },
          rest: Prism.languages.vala
        }
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.insertBefore("vala", "keyword", {
  regex: {
    pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\//,
      "regex-flags": /^[a-z]+$/
    }
  }
}), function(e2) {
  e2.languages.velocity = e2.languages.extend("markup", {});
  var t8 = {
    variable: {
      pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
      lookbehind: true,
      inside: {}
    },
    string: { pattern: /"[^"]*"|'[^']*'/, greedy: true },
    number: /\b\d+\b/,
    boolean: /\b(?:false|true)\b/,
    operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
    punctuation: /[(){}[\]:,.]/
  };
  t8.variable.inside = {
    string: t8.string,
    function: { pattern: /([^\w-])[a-z][\w-]*(?=\()/, lookbehind: true },
    number: t8.number,
    boolean: t8.boolean,
    punctuation: t8.punctuation
  }, e2.languages.insertBefore("velocity", "comment", {
    unparsed: {
      pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
      lookbehind: true,
      greedy: true,
      inside: { punctuation: /^#\[\[|\]\]#$/ }
    },
    "velocity-comment": [
      {
        pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
        lookbehind: true,
        greedy: true,
        alias: "comment"
      },
      {
        pattern: /(^|[^\\])##.*/,
        lookbehind: true,
        greedy: true,
        alias: "comment"
      }
    ],
    directive: {
      pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
      lookbehind: true,
      inside: {
        keyword: {
          pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
          inside: { punctuation: /[{}]/ }
        },
        rest: t8
      }
    },
    variable: t8.variable
  }), e2.languages.velocity.tag.inside["attr-value"].inside.rest = e2.languages.velocity;
}(Prism), Prism.languages.verilog = {
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true },
  "kernel-function": { pattern: /\B\$\w+\b/, alias: "property" },
  constant: /\B`\w+\b/,
  function: /\b\w+(?=\()/,
  keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
  important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
  number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
  operator: /[-+{}^~%*\/?=!<>&|]+/,
  punctuation: /[[\];(),.:]/
}, Prism.languages.vhdl = {
  comment: /--.+/,
  "vhdl-vectors": {
    pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
    alias: "number"
  },
  "quoted-function": { pattern: /"\S+?"(?=\()/, alias: "function" },
  string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
  attribute: { pattern: /\b'\w+/, alias: "attr-name" },
  keyword: /\b(?:access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|private|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|view|wait|when|while|with)\b/i,
  boolean: /\b(?:false|true)\b/i,
  function: /\w+(?=\()/,
  number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
  operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.vim = {
  string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
  comment: /".*/,
  function: /\b\w+(?=\()/,
  keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
  builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
  number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
  operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
  punctuation: /[{}[\](),;:]/
}, Prism.languages["visual-basic"] = {
  comment: {
    pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
    inside: { keyword: /^REM/i }
  },
  directive: {
    pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
    alias: "property",
    greedy: true
  },
  string: { pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i, greedy: true },
  date: {
    pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
    alias: "number"
  },
  number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
  boolean: /\b(?:False|Nothing|True)\b/i,
  keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
  operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
  punctuation: /[{}().,:?]/
}, Prism.languages.vb = Prism.languages["visual-basic"], Prism.languages.vba = Prism.languages["visual-basic"], Prism.languages.warpscript = {
  comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
  string: {
    pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
    greedy: true
  },
  variable: /\$\S+/,
  macro: { pattern: /@\S+/, alias: "property" },
  keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
  number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
  boolean: /\b(?:F|T|false|true)\b/,
  punctuation: /<%|%>|[{}[\]()]/,
  operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
}, Prism.languages.wasm = {
  comment: [/\(;[\s\S]*?;\)/, { pattern: /;;.*/, greedy: true }],
  string: { pattern: /"(?:\\[\s\S]|[^"\\])*"/, greedy: true },
  keyword: [
    { pattern: /\b(?:align|offset)=/, inside: { operator: /=/ } },
    {
      pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
      inside: { punctuation: /\./ }
    },
    /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
  ],
  variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
  number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
  punctuation: /[()]/
}, function(e2) {
  var t8, n2 = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source, a = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + n2 + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source, r2 = {};
  for (t8 in e2.languages["web-idl"] = {
    comment: { pattern: /\/\/.*|\/\*[\s\S]*?\*\//, greedy: true },
    string: { pattern: /"[^"]*"/, greedy: true },
    namespace: {
      pattern: RegExp(/(\bnamespace\s+)/.source + n2),
      lookbehind: true
    },
    "class-name": [
      {
        pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
        lookbehind: true,
        inside: r2
      },
      {
        pattern: RegExp(
          /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + a
        ),
        lookbehind: true,
        inside: r2
      },
      {
        pattern: RegExp(
          "(" + /\bcallback\s+/.source + n2 + /\s*=\s*/.source + ")" + a
        ),
        lookbehind: true,
        inside: r2
      },
      {
        pattern: RegExp(/(\btypedef\b\s*)/.source + a),
        lookbehind: true,
        inside: r2
      },
      {
        pattern: RegExp(
          /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + n2
        ),
        lookbehind: true
      },
      { pattern: RegExp(/(:\s*)/.source + n2), lookbehind: true },
      RegExp(n2 + /(?=\s+(?:implements|includes)\b)/.source),
      {
        pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + n2),
        lookbehind: true
      },
      {
        pattern: RegExp(
          a + "(?=" + /\s*(?:\.{3}\s*)?/.source + n2 + /\s*[(),;=]/.source + ")"
        ),
        inside: r2
      }
    ],
    builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
    keyword: [
      /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
      /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
    ],
    boolean: /\b(?:false|true)\b/,
    number: {
      pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
      lookbehind: true
    },
    operator: /\.{3}|[=:?<>-]/,
    punctuation: /[(){}[\].,;]/
  }, e2.languages["web-idl"])
    "class-name" !== t8 && (r2[t8] = e2.languages["web-idl"][t8]);
  e2.languages.webidl = e2.languages["web-idl"];
}(Prism), Prism.languages.wgsl = {
  comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true },
  "builtin-attribute": {
    pattern: /(@)builtin\(.*?\)/,
    lookbehind: true,
    inside: {
      attribute: { pattern: /^builtin/, alias: "attr-name" },
      punctuation: /[(),]/,
      "built-in-values": {
        pattern: /\b(?:frag_depth|front_facing|global_invocation_id|instance_index|local_invocation_id|local_invocation_index|num_workgroups|position|sample_index|sample_mask|vertex_index|workgroup_id)\b/,
        alias: "attr-value"
      }
    }
  },
  attributes: {
    pattern: /(@)(?:align|binding|compute|const|fragment|group|id|interpolate|invariant|location|size|vertex|workgroup_size)/i,
    lookbehind: true,
    alias: "attr-name"
  },
  functions: {
    pattern: /\b(fn\s+)[_a-zA-Z]\w*(?=[(<])/,
    lookbehind: true,
    alias: "function"
  },
  keyword: /\b(?:bitcast|break|case|const|continue|continuing|default|discard|else|enable|fallthrough|fn|for|function|if|let|loop|private|return|storage|struct|switch|type|uniform|var|while|workgroup)\b/,
  builtin: /\b(?:abs|acos|acosh|all|any|array|asin|asinh|atan|atan2|atanh|atomic|atomicAdd|atomicAnd|atomicCompareExchangeWeak|atomicExchange|atomicLoad|atomicMax|atomicMin|atomicOr|atomicStore|atomicSub|atomicXor|bool|ceil|clamp|cos|cosh|countLeadingZeros|countOneBits|countTrailingZeros|cross|degrees|determinant|distance|dot|dpdx|dpdxCoarse|dpdxFine|dpdy|dpdyCoarse|dpdyFine|exp|exp2|extractBits|f32|f64|faceForward|firstLeadingBit|floor|fma|fract|frexp|fwidth|fwidthCoarse|fwidthFine|i32|i64|insertBits|inverseSqrt|ldexp|length|log|log2|mat[2-4]x[2-4]|max|min|mix|modf|normalize|override|pack2x16float|pack2x16snorm|pack2x16unorm|pack4x8snorm|pack4x8unorm|pow|ptr|quantizeToF16|radians|reflect|refract|reverseBits|round|sampler|sampler_comparison|select|shiftLeft|shiftRight|sign|sin|sinh|smoothstep|sqrt|staticAssert|step|storageBarrier|tan|tanh|textureDimensions|textureGather|textureGatherCompare|textureLoad|textureNumLayers|textureNumLevels|textureNumSamples|textureSample|textureSampleBias|textureSampleCompare|textureSampleCompareLevel|textureSampleGrad|textureSampleLevel|textureStore|texture_1d|texture_2d|texture_2d_array|texture_3d|texture_cube|texture_cube_array|texture_depth_2d|texture_depth_2d_array|texture_depth_cube|texture_depth_cube_array|texture_depth_multisampled_2d|texture_multisampled_2d|texture_storage_1d|texture_storage_2d|texture_storage_2d_array|texture_storage_3d|transpose|trunc|u32|u64|unpack2x16float|unpack2x16snorm|unpack2x16unorm|unpack4x8snorm|unpack4x8unorm|vec[2-4]|workgroupBarrier)\b/,
  "function-calls": { pattern: /\b[_a-z]\w*(?=\()/i, alias: "function" },
  "class-name": /\b(?:[A-Z][A-Za-z0-9]*)\b/,
  "bool-literal": { pattern: /\b(?:false|true)\b/, alias: "boolean" },
  "hex-int-literal": {
    pattern: /\b0[xX][0-9a-fA-F]+[iu]?\b(?![.pP])/,
    alias: "number"
  },
  "hex-float-literal": {
    pattern: /\b0[xX][0-9a-fA-F]*(?:\.[0-9a-fA-F]*)?(?:[pP][+-]?\d+[fh]?)?/,
    alias: "number"
  },
  "decimal-float-literal": [
    { pattern: /\d*\.\d+(?:[eE](?:\+|-)?\d+)?[fh]?/, alias: "number" },
    { pattern: /\d+\.\d*(?:[eE](?:\+|-)?\d+)?[fh]?/, alias: "number" },
    { pattern: /\d+[eE](?:\+|-)?\d+[fh]?/, alias: "number" },
    { pattern: /\b\d+[fh]\b/, alias: "number" }
  ],
  "int-literal": { pattern: /\b\d+[iu]?\b/, alias: "number" },
  operator: [
    { pattern: /(?:\^|~|\|(?!\|)|\|\||&&|<<|>>|!)(?!=)/ },
    { pattern: /&(?![&=])/ },
    { pattern: /(?:\+=|-=|\*=|\/=|%=|\^=|&=|\|=|<<=|>>=)/ },
    { pattern: /(^|[^<>=!])=(?![=>])/, lookbehind: true },
    { pattern: /(?:==|!=|<=|\+\+|--|(^|[^=])>=)/, lookbehind: true },
    { pattern: /(?:(?:[+%]|(?:\*(?!\w)))(?!=))|(?:-(?!>))|(?:\/(?!\/))/ },
    { pattern: /->/ }
  ],
  punctuation: /[@(){}[\],;<>:.]/
}, Prism.languages.wiki = Prism.languages.extend("markup", {
  "block-comment": {
    pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
    lookbehind: true,
    alias: "comment"
  },
  heading: {
    pattern: /^(=+)[^=\r\n].*?\1/m,
    inside: { punctuation: /^=+|=+$/, important: /.+/ }
  },
  emphasis: {
    pattern: /('{2,5}).+?\1/,
    inside: {
      "bold-italic": {
        pattern: /(''''').+?(?=\1)/,
        lookbehind: true,
        alias: ["bold", "italic"]
      },
      bold: { pattern: /(''')[^'](?:.*?[^'])?(?=\1)/, lookbehind: true },
      italic: { pattern: /('')[^'](?:.*?[^'])?(?=\1)/, lookbehind: true },
      punctuation: /^''+|''+$/
    }
  },
  hr: { pattern: /^-{4,}/m, alias: "punctuation" },
  url: [
    /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
    /\[\[.+?\]\]|\[.+?\]/
  ],
  variable: [/__[A-Z]+__/, /\{{3}.+?\}{3}/, /\{\{.+?\}\}/],
  symbol: [/^#redirect/im, /~{3,5}/],
  "table-tag": {
    pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
    lookbehind: true,
    inside: {
      "table-bar": { pattern: /\|$/, alias: "punctuation" },
      rest: Prism.languages.markup.tag.inside
    }
  },
  punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
}), Prism.languages.insertBefore("wiki", "tag", {
  nowiki: {
    pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
    inside: {
      tag: {
        pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
        inside: Prism.languages.markup.tag.inside
      }
    }
  }
}), Prism.languages.wolfram = {
  comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
  string: { pattern: /"(?:\\.|[^"\\\r\n])*"/, greedy: true },
  keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
  context: { pattern: /\b\w+`+\w*/, alias: "class-name" },
  blank: { pattern: /\b\w+_\b/, alias: "regex" },
  "global-variable": { pattern: /\$\w+/, alias: "variable" },
  boolean: /\b(?:False|True)\b/,
  number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
  operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/
}, Prism.languages.mathematica = Prism.languages.wolfram, Prism.languages.wl = Prism.languages.wolfram, Prism.languages.nb = Prism.languages.wolfram, Prism.languages.wren = {
  comment: [
    {
      pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
      greedy: true
    },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }
  ],
  "triple-quoted-string": {
    pattern: /"""[\s\S]*?"""/,
    greedy: true,
    alias: "string"
  },
  "string-literal": null,
  hashbang: { pattern: /^#!\/.+/, greedy: true, alias: "comment" },
  attribute: { pattern: /#!?[ \t\u3000]*\w+/, alias: "keyword" },
  "class-name": [
    { pattern: /(\bclass\s+)\w+/, lookbehind: true },
    /\b[A-Z][a-z\d_]*\b/
  ],
  constant: /\b[A-Z][A-Z\d_]*\b/,
  null: { pattern: /\bnull\b/, alias: "keyword" },
  keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
  boolean: /\b(?:false|true)\b/,
  number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
  function: /\b[a-z_]\w*(?=\s*[({])/i,
  operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
  punctuation: /[\[\](){}.,;]/
}, Prism.languages.wren["string-literal"] = {
  pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
  lookbehind: true,
  greedy: true,
  inside: {
    interpolation: {
      pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
      lookbehind: true,
      inside: {
        expression: {
          pattern: /^(%\()[\s\S]+(?=\)$)/,
          lookbehind: true,
          inside: Prism.languages.wren
        },
        "interpolation-punctuation": {
          pattern: /^%\(|\)$/,
          alias: "punctuation"
        }
      }
    },
    string: /[\s\S]+/
  }
}, function(e2) {
  e2.languages.xeora = e2.languages.extend("markup", {
    constant: {
      pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
      inside: { punctuation: { pattern: /\$/ } }
    },
    variable: {
      pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
      inside: {
        punctuation: { pattern: /[$.]/ },
        operator: { pattern: /#+|[-+*~=^@]/ }
      }
    },
    "function-inline": {
      pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
      inside: {
        variable: {
          pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
          inside: {
            punctuation: { pattern: /[,.|]/ },
            operator: { pattern: /#+|[-+*~=^@]/ }
          }
        },
        punctuation: { pattern: /\$\w:|[$:?.,|]/ }
      },
      alias: "function"
    },
    "function-block": {
      pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
      inside: { punctuation: { pattern: /[$:{}?.,|]/ } },
      alias: "function"
    },
    "directive-inline": {
      pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
      inside: {
        punctuation: {
          pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
          inside: { tag: { pattern: /#\d/ } }
        }
      },
      alias: "function"
    },
    "directive-block-open": {
      pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
      inside: {
        punctuation: {
          pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
          inside: { tag: { pattern: /#\d/ } }
        },
        attribute: {
          pattern: /![A-Z]+$/,
          inside: { punctuation: { pattern: /!/ } },
          alias: "keyword"
        }
      },
      alias: "function"
    },
    "directive-block-separator": {
      pattern: /\}:[-\w.]+:\{/,
      inside: { punctuation: { pattern: /[:{}]/ } },
      alias: "function"
    },
    "directive-block-close": {
      pattern: /\}:[-\w.]+\$/,
      inside: { punctuation: { pattern: /[:{}$]/ } },
      alias: "function"
    }
  }), e2.languages.insertBefore(
    "inside",
    "punctuation",
    { variable: e2.languages.xeora["function-inline"].inside.variable },
    e2.languages.xeora["function-block"]
  ), e2.languages.xeoracube = e2.languages.xeora;
}(Prism), function(n2) {
  function e2(e22, t22) {
    n2.languages[e22] && n2.languages.insertBefore(e22, "comment", { "doc-comment": t22 });
  }
  var t8 = n2.languages.markup.tag, a = {
    pattern: /\/\/\/.*/,
    greedy: true,
    alias: "comment",
    inside: { tag: t8 }
  }, t8 = {
    pattern: /'''.*/,
    greedy: true,
    alias: "comment",
    inside: { tag: t8 }
  };
  e2("csharp", a), e2("fsharp", a), e2("vbnet", t8);
}(Prism), Prism.languages.xojo = {
  comment: { pattern: /(?:'|\/\/|Rem\b).+/i, greedy: true },
  string: { pattern: /"(?:""|[^"])*"/, greedy: true },
  number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
  directive: {
    pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
    alias: "property"
  },
  keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
  operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
  punctuation: /[.,;:()]/
}, function(i) {
  i.languages.xquery = i.languages.extend("markup", {
    "xquery-comment": {
      pattern: /\(:[\s\S]*?:\)/,
      greedy: true,
      alias: "comment"
    },
    string: { pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/, greedy: true },
    extension: { pattern: /\(#.+?#\)/, alias: "symbol" },
    variable: /\$[-\w:]+/,
    axis: {
      pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
      lookbehind: true,
      alias: "operator"
    },
    "keyword-operator": {
      pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
      lookbehind: true,
      alias: "operator"
    },
    keyword: {
      pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
      lookbehind: true
    },
    function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
    "xquery-element": {
      pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
      lookbehind: true,
      alias: "tag"
    },
    "xquery-attribute": {
      pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
      lookbehind: true,
      alias: "attr-name"
    },
    builtin: {
      pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
      lookbehind: true
    },
    number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
    operator: [
      /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
      { pattern: /(\s)-(?=\s)/, lookbehind: true }
    ],
    punctuation: /[[\](){},;:/]/
  }), i.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, i.languages.xquery.tag.inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/, i.languages.xquery.tag.inside["attr-value"].inside.punctuation = /^="|"$/, i.languages.xquery.tag.inside["attr-value"].inside.expression = {
    pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
    inside: i.languages.xquery,
    alias: "language-xquery"
  };
  function o2(e2) {
    for (var t8 = [], n2 = 0; n2 < e2.length; n2++) {
      var a = e2[n2], r2 = false;
      "string" != typeof a && ("tag" === a.type && a.content[0] && "tag" === a.content[0].type ? "</" === a.content[0].content[0].content ? 0 < t8.length && t8[t8.length - 1].tagName === s2(a.content[0].content[1]) && t8.pop() : "/>" !== a.content[a.content.length - 1].content && t8.push({ tagName: s2(a.content[0].content[1]), openedBraces: 0 }) : !(0 < t8.length && "punctuation" === a.type && "{" === a.content) || e2[n2 + 1] && "punctuation" === e2[n2 + 1].type && "{" === e2[n2 + 1].content || e2[n2 - 1] && "plain-text" === e2[n2 - 1].type && "{" === e2[n2 - 1].content ? 0 < t8.length && 0 < t8[t8.length - 1].openedBraces && "punctuation" === a.type && "}" === a.content ? t8[t8.length - 1].openedBraces-- : "comment" !== a.type && (r2 = true) : t8[t8.length - 1].openedBraces++), (r2 || "string" == typeof a) && 0 < t8.length && 0 === t8[t8.length - 1].openedBraces && (r2 = s2(a), n2 < e2.length - 1 && ("string" == typeof e2[n2 + 1] || "plain-text" === e2[n2 + 1].type) && (r2 += s2(e2[n2 + 1]), e2.splice(n2 + 1, 1)), 0 < n2 && ("string" == typeof e2[n2 - 1] || "plain-text" === e2[n2 - 1].type) && (r2 = s2(e2[n2 - 1]) + r2, e2.splice(n2 - 1, 1), n2--), /^\s+$/.test(r2) ? e2[n2] = r2 : e2[n2] = new i.Token("plain-text", r2, null, r2)), a.content && "string" != typeof a.content && o2(a.content);
    }
  }
  var s2 = function(e2) {
    return "string" == typeof e2 ? e2 : "string" == typeof e2.content ? e2.content : e2.content.map(s2).join("");
  };
  i.hooks.add("after-tokenize", function(e2) {
    "xquery" === e2.language && o2(e2.tokens);
  });
}(Prism), Prism.languages.yang = {
  comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
  string: { pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/, greedy: true },
  keyword: { pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i, lookbehind: true },
  namespace: { pattern: /(\s)[a-z_][\w.-]*(?=:)/i, lookbehind: true },
  boolean: /\b(?:false|true)\b/,
  operator: /\+/,
  punctuation: /[{};:]/
}, function(t8) {
  function e2(e22) {
    return function() {
      return e22;
    };
  }
  var n2 = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/, a = "\\b(?!" + n2.source + ")(?!\\d)\\w+\\b", r2 = /align\s*\((?:[^()]|\([^()]*\))*\)/.source, a = "(?!\\s)(?:!?\\s*(?:" + /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
    /<ALIGN>/g,
    e2(r2)
  ) + "\\s*)*" + /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
    /<ID>/g,
    e2(a)
  ) + ")+";
  t8.languages.zig = {
    comment: [{ pattern: /\/\/[/!].*/, alias: "doc-comment" }, /\/{2}.*/],
    string: [
      {
        pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
        lookbehind: true,
        greedy: true
      }
    ],
    char: {
      pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
      lookbehind: true,
      greedy: true
    },
    builtin: /\B@(?!\d)\w+(?=\s*\()/,
    label: {
      pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
      lookbehind: true
    },
    "class-name": [
      /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
      {
        pattern: RegExp(
          /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, e2(a)).replace(/<ALIGN>/g, e2(r2))
        ),
        lookbehind: true,
        inside: null
      },
      {
        pattern: RegExp(
          /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, e2(a)).replace(/<ALIGN>/g, e2(r2))
        ),
        lookbehind: true,
        inside: null
      }
    ],
    "builtin-type": {
      pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
      alias: "keyword"
    },
    keyword: n2,
    function: /\b(?!\d)\w+(?=\s*\()/,
    number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
    boolean: /\b(?:false|true)\b/,
    operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
    punctuation: /[.:,;(){}[\]]/
  }, t8.languages.zig["class-name"].forEach(function(e22) {
    null === e22.inside && (e22.inside = t8.languages.zig);
  });
}(Prism);
var stylesForToken = (token2, theme) => {
  let styles2 = __spreadValues3({}, theme[token2.type]);
  const aliases = Array.isArray(token2.alias) ? token2.alias : [token2.alias];
  for (const alias of aliases) {
    styles2 = __spreadValues3(__spreadValues3({}, styles2), theme[alias]);
  }
  return styles2;
};
var CodeBlockLine = ({
  token: token2,
  theme,
  inheritedStyles
}) => {
  if (token2 instanceof Prism.Token) {
    const styleForToken = __spreadValues3(__spreadValues3({}, inheritedStyles), stylesForToken(token2, theme));
    if (token2.content instanceof Prism.Token) {
      return (0, import_jsx_runtime3.jsx)("span", { style: styleForToken, children: (0, import_jsx_runtime3.jsx)(CodeBlockLine, { theme, token: token2.content }) });
    }
    if (typeof token2.content === "string") {
      return (0, import_jsx_runtime3.jsx)("span", { style: styleForToken, children: token2.content });
    }
    return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: token2.content.map((subToken, i) => (0, import_jsx_runtime3.jsx)(
      CodeBlockLine,
      {
        inheritedStyles: styleForToken,
        theme,
        token: subToken
      },
      i
    )) });
  }
  return (0, import_jsx_runtime3.jsx)("span", { style: inheritedStyles, children: token2 });
};
var CodeBlock = React3.forwardRef(
  (_a22, ref) => {
    var _b = _a22, { code, fontFamily, lineNumbers, theme, language } = _b, rest = __objRest3(_b, ["code", "fontFamily", "lineNumbers", "theme", "language"]);
    const languageGrammar = Prism.languages[language];
    if (typeof languageGrammar === "undefined") {
      throw new Error(
        `CodeBlock: There is no language defined on Prism called ${language}`
      );
    }
    const lines = code.split(/\r\n|\r|\n/gm);
    const tokensPerLine = lines.map(
      (line) => Prism.tokenize(line, languageGrammar)
    );
    return (0, import_jsx_runtime3.jsx)(
      "pre",
      __spreadProps3(__spreadValues3({}, rest), {
        ref,
        style: __spreadValues3(__spreadProps3(__spreadValues3({}, theme.base), { width: "100%" }), rest.style),
        children: (0, import_jsx_runtime3.jsx)("code", { children: tokensPerLine.map((tokensForLine, lineIndex) => (0, import_jsx_runtime3.jsxs)("p", { style: { margin: 0, minHeight: "1em" }, children: [
          lineNumbers ? (0, import_jsx_runtime3.jsx)(
            "span",
            {
              style: {
                width: "2em",
                display: "inline-block",
                fontFamily
              },
              children: lineIndex + 1
            }
          ) : null,
          tokensForLine.map((token2, i) => (0, import_jsx_runtime3.jsx)(
            CodeBlockLine,
            {
              inheritedStyles: { fontFamily },
              theme,
              token: token2
            },
            i
          ))
        ] }, lineIndex)) })
      })
    );
  }
);
CodeBlock.displayName = "CodeBlock";
var xonokai = {
  base: {
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    whiteSpace: "pre-wrap",
    wordWrap: "normal",
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    fontSize: "14px",
    color: "#76d9e6",
    textShadow: "none",
    background: "#2a2a2a",
    padding: "15px",
    borderRadius: "4px",
    border: "1px solid #e1e1e8",
    overflow: "auto",
    position: "relative"
  },
  namespace: {
    opacity: ".7"
  },
  comment: {
    color: "#6f705e"
  },
  prolog: {
    color: "#6f705e"
  },
  doctype: {
    color: "#6f705e"
  },
  cdata: {
    color: "#6f705e"
  },
  operator: {
    color: "#a77afe"
  },
  boolean: {
    color: "#a77afe"
  },
  number: {
    color: "#a77afe"
  },
  "attr-name": {
    color: "#e6d06c"
  },
  string: {
    color: "#e6d06c"
  },
  entity: {
    color: "#e6d06c",
    cursor: "help"
  },
  url: {
    color: "#e6d06c"
  },
  selector: {
    color: "#a6e22d"
  },
  inserted: {
    color: "#a6e22d"
  },
  atrule: {
    color: "#ef3b7d"
  },
  "attr-value": {
    color: "#ef3b7d"
  },
  keyword: {
    color: "#ef3b7d"
  },
  important: {
    color: "#ef3b7d",
    fontWeight: "bold"
  },
  deleted: {
    color: "#ef3b7d"
  },
  regex: {
    color: "#76d9e6"
  },
  statement: {
    color: "#76d9e6",
    fontWeight: "bold"
  },
  placeholder: {
    color: "#fff"
  },
  variable: {
    color: "#fff"
  },
  bold: {
    fontWeight: "bold"
  },
  punctuation: {
    color: "#bebec5"
  },
  italic: {
    fontStyle: "italic"
  }
};
var vscDarkPlus = {
  base: {
    color: "#d4d4d4",
    fontSize: "13px",
    textShadow: "none",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    background: "#1e1e1e"
  },
  "doctype .token.doctype-tag": {
    color: "#569CD6"
  },
  "doctype .token.name": {
    color: "#9cdcfe"
  },
  comment: {
    color: "#6a9955"
  },
  prolog: {
    color: "#6a9955"
  },
  punctuation: {
    color: "#d4d4d4"
  },
  property: {
    color: "#9cdcfe"
  },
  tag: {
    color: "#569cd6"
  },
  boolean: {
    color: "#569cd6"
  },
  number: {
    color: "#b5cea8"
  },
  constant: {
    color: "#9cdcfe"
  },
  symbol: {
    color: "#b5cea8"
  },
  inserted: {
    color: "#b5cea8"
  },
  unit: {
    color: "#b5cea8"
  },
  selector: {
    color: "#d7ba7d"
  },
  "attr-name": {
    color: "#9cdcfe"
  },
  string: {
    color: "#ce9178"
  },
  char: {
    color: "#ce9178"
  },
  builtin: {
    color: "#ce9178"
  },
  deleted: {
    color: "#ce9178"
  },
  operator: {
    color: "#d4d4d4"
  },
  entity: {
    color: "#569cd6"
  },
  "operator.arrow": {
    color: "#569CD6"
  },
  atrule: {
    color: "#ce9178"
  },
  "atrule .token.rule": {
    color: "#c586c0"
  },
  "atrule .token.url": {
    color: "#9cdcfe"
  },
  "atrule .token.url .token.function": {
    color: "#dcdcaa"
  },
  "atrule .token.url .token.punctuation": {
    color: "#d4d4d4"
  },
  keyword: {
    color: "#569CD6"
  },
  "keyword.module": {
    color: "#c586c0"
  },
  "keyword.control-flow": {
    color: "#c586c0"
  },
  function: {
    color: "#dcdcaa"
  },
  "function .token.maybe-class-name": {
    color: "#dcdcaa"
  },
  regex: {
    color: "#d16969"
  },
  important: {
    color: "#569cd6"
  },
  italic: {
    fontStyle: "italic"
  },
  "class-name": {
    color: "#4ec9b0"
  },
  "maybe-class-name": {
    color: "#4ec9b0"
  },
  console: {
    color: "#9cdcfe"
  },
  parameter: {
    color: "#9cdcfe"
  },
  interpolation: {
    color: "#9cdcfe"
  },
  "punctuation.interpolation-punctuation": {
    color: "#569cd6"
  },
  variable: {
    color: "#9cdcfe"
  },
  "imports .token.maybe-class-name": {
    color: "#9cdcfe"
  },
  "exports .token.maybe-class-name": {
    color: "#9cdcfe"
  },
  escape: {
    color: "#d7ba7d"
  },
  "tag .token.punctuation": {
    color: "#808080"
  },
  cdata: {
    color: "#808080"
  },
  "attr-value": {
    color: "#ce9178"
  },
  "attr-value .token.punctuation": {
    color: "#ce9178"
  },
  "attr-value .token.punctuation.attr-equals": {
    color: "#d4d4d4"
  },
  namespace: {
    color: "#4ec9b0"
  }
};
var duotoneForest = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#2a2d2a",
    color: "#687d68",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#535f53"
  },
  prolog: {
    color: "#535f53"
  },
  doctype: {
    color: "#535f53"
  },
  cdata: {
    color: "#535f53"
  },
  punctuation: {
    color: "#535f53"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#a2b34d"
  },
  operator: {
    color: "#a2b34d"
  },
  number: {
    color: "#a2b34d"
  },
  property: {
    color: "#687d68"
  },
  function: {
    color: "#687d68"
  },
  "tag-id": {
    color: "#f0fff0"
  },
  selector: {
    color: "#f0fff0"
  },
  "atrule-id": {
    color: "#f0fff0"
  },
  "attr-name": {
    color: "#b3d6b3"
  },
  boolean: {
    color: "#e5fb79"
  },
  string: {
    color: "#e5fb79"
  },
  entity: {
    color: "#e5fb79",
    cursor: "help"
  },
  url: {
    color: "#e5fb79"
  },
  "attr-value": {
    color: "#e5fb79"
  },
  keyword: {
    color: "#e5fb79"
  },
  control: {
    color: "#e5fb79"
  },
  directive: {
    color: "#e5fb79"
  },
  unit: {
    color: "#e5fb79"
  },
  statement: {
    color: "#e5fb79"
  },
  regex: {
    color: "#e5fb79"
  },
  atrule: {
    color: "#e5fb79"
  },
  placeholder: {
    color: "#e5fb79"
  },
  variable: {
    color: "#e5fb79"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #f0fff0",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#b3d6b3"
  },
  bold: {
    fontWeight: "bold"
  }
};
var holiTheme = {
  base: {},
  comment: {
    color: "#446e69"
  },
  prolog: {
    color: "#446e69"
  },
  doctype: {
    color: "#446e69"
  },
  cdata: {
    color: "#446e69"
  },
  punctuation: {
    color: "#d6b007"
  },
  property: {
    color: "#d6e7ff"
  },
  tag: {
    color: "#d6e7ff"
  },
  boolean: {
    color: "#d6e7ff"
  },
  number: {
    color: "#d6e7ff"
  },
  constant: {
    color: "#d6e7ff"
  },
  symbol: {
    color: "#d6e7ff"
  },
  deleted: {
    color: "#d6e7ff"
  },
  selector: {
    color: "#e60067"
  },
  "attr-name": {
    color: "#e60067"
  },
  builtin: {
    color: "#e60067"
  },
  inserted: {
    color: "#e60067"
  },
  string: {
    color: "#49c6ec"
  },
  char: {
    color: "#49c6ec"
  },
  operator: {
    color: "#ec8e01",
    background: "transparent"
  },
  entity: {
    color: "#ec8e01",
    background: "transparent"
  },
  url: {
    color: "#ec8e01",
    background: "transparent"
  },
  atrule: {
    color: "#0fe468"
  },
  "attr-value": {
    color: "#0fe468"
  },
  keyword: {
    color: "#0fe468"
  },
  function: {
    color: "#78f3e9"
  },
  "class-name": {
    color: "#78f3e9"
  },
  regex: {
    color: "#d6e7ff"
  },
  important: {
    color: "#d6e7ff"
  },
  variable: {
    color: "#d6e7ff"
  }
};
var cb = {
  base: {
    color: "#fff",
    textShadow: "0 1px 1px #000",
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    wordSpacing: "normal",
    whiteSpace: "pre",
    wordWrap: "normal",
    lineHeight: "1.4",
    background: "#222",
    border: "0",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "15px",
    margin: "1em 0",
    overflow: "auto",
    MozBorderRadius: "8px",
    WebkitBorderRadius: "8px",
    borderRadius: "8px"
  },
  comment: {
    color: "#797979"
  },
  prolog: {
    color: "#797979"
  },
  doctype: {
    color: "#797979"
  },
  cdata: {
    color: "#797979"
  },
  selector: {
    color: "#fff"
  },
  operator: {
    color: "#fff"
  },
  punctuation: {
    color: "#fff"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#ffd893"
  },
  boolean: {
    color: "#ffd893"
  },
  atrule: {
    color: "#B0C975"
  },
  "attr-value": {
    color: "#B0C975"
  },
  hex: {
    color: "#B0C975"
  },
  string: {
    color: "#B0C975"
  },
  property: {
    color: "#c27628"
  },
  entity: {
    color: "#c27628",
    cursor: "help"
  },
  url: {
    color: "#c27628"
  },
  "attr-name": {
    color: "#c27628"
  },
  keyword: {
    color: "#c27628"
  },
  regex: {
    color: "#9B71C6"
  },
  function: {
    color: "#e5a638"
  },
  constant: {
    color: "#e5a638"
  },
  variable: {
    color: "#fdfba8"
  },
  number: {
    color: "#8799B0"
  },
  important: {
    color: "#E45734"
  },
  deliminator: {
    color: "#E45734"
  }
};
var vs = {
  base: {
    color: "#393A34",
    fontFamily: '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    fontSize: ".9em",
    lineHeight: "1.2em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    border: "1px solid #dddddd",
    backgroundColor: "white"
  },
  comment: {
    color: "#008000",
    fontStyle: "italic"
  },
  prolog: {
    color: "#008000",
    fontStyle: "italic"
  },
  doctype: {
    color: "#008000",
    fontStyle: "italic"
  },
  cdata: {
    color: "#008000",
    fontStyle: "italic"
  },
  namespace: {
    opacity: ".7"
  },
  string: {
    color: "#A31515"
  },
  punctuation: {
    color: "#393A34"
  },
  operator: {
    color: "#393A34"
  },
  url: {
    color: "#36acaa"
  },
  symbol: {
    color: "#36acaa"
  },
  number: {
    color: "#36acaa"
  },
  boolean: {
    color: "#36acaa"
  },
  variable: {
    color: "#36acaa"
  },
  constant: {
    color: "#36acaa"
  },
  inserted: {
    color: "#36acaa"
  },
  atrule: {
    color: "#0000ff"
  },
  keyword: {
    color: "#0000ff"
  },
  "attr-value": {
    color: "#0000ff"
  },
  function: {
    color: "#393A34"
  },
  deleted: {
    color: "#9a050f"
  },
  selector: {
    color: "#800000"
  },
  important: {
    color: "#e90",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  "class-name": {
    color: "#2B91AF"
  },
  tag: {
    color: "#800000"
  },
  "attr-name": {
    color: "#ff0000"
  },
  property: {
    color: "#ff0000"
  },
  regex: {
    color: "#ff0000"
  },
  entity: {
    color: "#ff0000"
  },
  "directive.tag .tag": {
    background: "#ffff00",
    color: "#393A34"
  }
};
var materialDark = {
  base: {
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    color: "#eee",
    background: "#2f2f2f",
    fontFamily: "Roboto Mono, monospace",
    fontSize: "1em",
    lineHeight: "1.5em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    overflow: "auto",
    position: "relative",
    margin: "0.5em 0",
    padding: "1.25em 1em"
  },
  atrule: {
    color: "#c792ea"
  },
  "attr-name": {
    color: "#ffcb6b"
  },
  "attr-value": {
    color: "#a5e844"
  },
  attribute: {
    color: "#a5e844"
  },
  boolean: {
    color: "#c792ea"
  },
  builtin: {
    color: "#ffcb6b"
  },
  cdata: {
    color: "#80cbc4"
  },
  char: {
    color: "#80cbc4"
  },
  class: {
    color: "#ffcb6b"
  },
  "class-name": {
    color: "#f2ff00"
  },
  comment: {
    color: "#616161"
  },
  constant: {
    color: "#c792ea"
  },
  deleted: {
    color: "#ff6666"
  },
  doctype: {
    color: "#616161"
  },
  entity: {
    color: "#ff6666"
  },
  function: {
    color: "#c792ea"
  },
  hexcode: {
    color: "#f2ff00"
  },
  id: {
    color: "#c792ea",
    fontWeight: "bold"
  },
  important: {
    color: "#c792ea",
    fontWeight: "bold"
  },
  inserted: {
    color: "#80cbc4"
  },
  keyword: {
    color: "#c792ea"
  },
  number: {
    color: "#fd9170"
  },
  operator: {
    color: "#89ddff"
  },
  prolog: {
    color: "#616161"
  },
  property: {
    color: "#80cbc4"
  },
  "pseudo-class": {
    color: "#a5e844"
  },
  "pseudo-element": {
    color: "#a5e844"
  },
  punctuation: {
    color: "#89ddff"
  },
  regex: {
    color: "#f2ff00"
  },
  selector: {
    color: "#ff6666"
  },
  string: {
    color: "#a5e844"
  },
  symbol: {
    color: "#c792ea"
  },
  tag: {
    color: "#ff6666"
  },
  unit: {
    color: "#fd9170"
  },
  url: {
    color: "#ff6666"
  },
  variable: {
    color: "#ff6666"
  }
};
var dracula = {
  base: {
    color: "#f8f8f2",
    background: "#282a36",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "#6272a4"
  },
  prolog: {
    color: "#6272a4"
  },
  doctype: {
    color: "#6272a4"
  },
  cdata: {
    color: "#6272a4"
  },
  punctuation: {
    color: "#f8f8f2"
  },
  property: {
    color: "#ff79c6"
  },
  tag: {
    color: "#ff79c6"
  },
  constant: {
    color: "#ff79c6"
  },
  symbol: {
    color: "#ff79c6"
  },
  deleted: {
    color: "#ff79c6"
  },
  boolean: {
    color: "#bd93f9"
  },
  number: {
    color: "#bd93f9"
  },
  selector: {
    color: "#50fa7b"
  },
  "attr-name": {
    color: "#50fa7b"
  },
  string: {
    color: "#50fa7b"
  },
  char: {
    color: "#50fa7b"
  },
  builtin: {
    color: "#50fa7b"
  },
  inserted: {
    color: "#50fa7b"
  },
  operator: {
    color: "#f8f8f2"
  },
  entity: {
    color: "#f8f8f2",
    cursor: "help"
  },
  url: {
    color: "#f8f8f2"
  },
  variable: {
    color: "#f8f8f2"
  },
  atrule: {
    color: "#f1fa8c"
  },
  "attr-value": {
    color: "#f1fa8c"
  },
  function: {
    color: "#f1fa8c"
  },
  "class-name": {
    color: "#f1fa8c"
  },
  keyword: {
    color: "#8be9fd"
  },
  regex: {
    color: "#ffb86c"
  },
  important: {
    color: "#ffb86c",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var shadesOfPurple = {
  base: {},
  "": {
    fontWeight: "400"
  },
  comment: {
    color: "#b362ff"
  },
  prolog: {
    color: "#b362ff"
  },
  cdata: {
    color: "#b362ff"
  },
  delimiter: {
    color: "#ff9d00"
  },
  keyword: {
    color: "#ff9d00"
  },
  selector: {
    color: "#ff9d00"
  },
  important: {
    color: "#ff9d00"
  },
  atrule: {
    color: "#ff9d00"
  },
  operator: {
    color: "rgb(255, 180, 84)",
    background: "none"
  },
  "attr-name": {
    color: "rgb(255, 180, 84)"
  },
  punctuation: {
    color: "#ffffff"
  },
  boolean: {
    color: "rgb(255, 98, 140)"
  },
  tag: {
    color: "rgb(255, 157, 0)"
  },
  "tag .punctuation": {
    color: "rgb(255, 157, 0)"
  },
  doctype: {
    color: "rgb(255, 157, 0)"
  },
  builtin: {
    color: "rgb(255, 157, 0)"
  },
  entity: {
    color: "#6897bb",
    background: "none"
  },
  symbol: {
    color: "#6897bb"
  },
  number: {
    color: "#ff628c"
  },
  property: {
    color: "#ff628c"
  },
  constant: {
    color: "#ff628c"
  },
  variable: {
    color: "#ff628c"
  },
  string: {
    color: "#a5ff90"
  },
  char: {
    color: "#a5ff90"
  },
  "attr-value": {
    color: "#a5c261"
  },
  "attr-value .punctuation": {
    color: "#a5c261"
  },
  "attr-value .punctuation:first-child": {
    color: "#a9b7c6"
  },
  url: {
    color: "#287bde",
    textDecoration: "underline",
    background: "none"
  },
  function: {
    color: "rgb(250, 208, 0)"
  },
  regex: {
    background: "#364135"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  inserted: {
    background: "#00ff00"
  },
  deleted: {
    background: "#ff000d"
  },
  "class-name": {
    color: "#fb94ff"
  }
};
var gruvboxDark = {
  base: {
    color: "#ebdbb2",
    fontFamily: 'Consolas, Monaco, "Andale Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    background: "#1d2021"
  },
  comment: {
    color: "#a89984"
  },
  prolog: {
    color: "#a89984"
  },
  cdata: {
    color: "#a89984"
  },
  delimiter: {
    color: "#fb4934"
  },
  boolean: {
    color: "#fb4934"
  },
  keyword: {
    color: "#fb4934"
  },
  selector: {
    color: "#fb4934"
  },
  important: {
    color: "#fb4934"
  },
  atrule: {
    color: "#fb4934"
  },
  operator: {
    color: "#a89984"
  },
  punctuation: {
    color: "#a89984"
  },
  "attr-name": {
    color: "#a89984"
  },
  tag: {
    color: "#fabd2f"
  },
  "tag .punctuation": {
    color: "#fabd2f"
  },
  doctype: {
    color: "#fabd2f"
  },
  builtin: {
    color: "#fabd2f"
  },
  entity: {
    color: "#d3869b"
  },
  number: {
    color: "#d3869b"
  },
  symbol: {
    color: "#d3869b"
  },
  property: {
    color: "#fb4934"
  },
  constant: {
    color: "#fb4934"
  },
  variable: {
    color: "#fb4934"
  },
  string: {
    color: "#b8bb26"
  },
  char: {
    color: "#b8bb26"
  },
  "attr-value": {
    color: "#a89984"
  },
  "attr-value .punctuation": {
    color: "#a89984"
  },
  url: {
    color: "#b8bb26",
    textDecoration: "underline"
  },
  function: {
    color: "#fabd2f"
  },
  regex: {
    background: "#b8bb26"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  inserted: {
    background: "#a89984"
  },
  deleted: {
    background: "#fb4934"
  }
};
var baseAteliersulphurpoolLight = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#f5f7ff",
    color: "#5e6687",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#898ea4"
  },
  prolog: {
    color: "#898ea4"
  },
  doctype: {
    color: "#898ea4"
  },
  cdata: {
    color: "#898ea4"
  },
  punctuation: {
    color: "#5e6687"
  },
  namespace: {
    opacity: ".7"
  },
  operator: {
    color: "#c76b29"
  },
  boolean: {
    color: "#c76b29"
  },
  number: {
    color: "#c76b29"
  },
  property: {
    color: "#c08b30"
  },
  tag: {
    color: "#3d8fd1"
  },
  string: {
    color: "#22a2c9"
  },
  selector: {
    color: "#6679cc"
  },
  "attr-name": {
    color: "#c76b29"
  },
  entity: {
    color: "#22a2c9",
    cursor: "help"
  },
  url: {
    color: "#22a2c9"
  },
  "attr-value": {
    color: "#ac9739"
  },
  keyword: {
    color: "#ac9739"
  },
  control: {
    color: "#ac9739"
  },
  directive: {
    color: "#ac9739"
  },
  unit: {
    color: "#ac9739"
  },
  statement: {
    color: "#22a2c9"
  },
  regex: {
    color: "#22a2c9"
  },
  atrule: {
    color: "#22a2c9"
  },
  placeholder: {
    color: "#3d8fd1"
  },
  variable: {
    color: "#3d8fd1"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #202746",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#c94922"
  },
  bold: {
    fontWeight: "bold"
  }
};
var coldarkCold = {
  base: {
    color: "#111b27",
    background: "#e3eaf2",
    fontFamily: 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#3c526d"
  },
  prolog: {
    color: "#3c526d"
  },
  doctype: {
    color: "#3c526d"
  },
  cdata: {
    color: "#3c526d"
  },
  punctuation: {
    color: "#111b27"
  },
  "delimiter.important": {
    color: "#006d6d",
    fontWeight: "inherit"
  },
  "selector .parent": {
    color: "#006d6d"
  },
  tag: {
    color: "#006d6d"
  },
  "tag .token.punctuation": {
    color: "#006d6d"
  },
  "attr-name": {
    color: "#755f00"
  },
  boolean: {
    color: "#755f00"
  },
  "boolean.important": {
    color: "#755f00"
  },
  number: {
    color: "#755f00"
  },
  constant: {
    color: "#755f00"
  },
  "selector .token.attribute": {
    color: "#755f00"
  },
  "class-name": {
    color: "#005a8e"
  },
  key: {
    color: "#005a8e"
  },
  parameter: {
    color: "#005a8e"
  },
  property: {
    color: "#005a8e"
  },
  "property-access": {
    color: "#005a8e"
  },
  variable: {
    color: "#005a8e"
  },
  "attr-value": {
    color: "#116b00"
  },
  inserted: {
    color: "#116b00"
  },
  color: {
    color: "#116b00"
  },
  "selector .token.value": {
    color: "#116b00"
  },
  string: {
    color: "#116b00"
  },
  "string .token.url-link": {
    color: "#116b00"
  },
  builtin: {
    color: "#af00af"
  },
  "keyword-array": {
    color: "#af00af"
  },
  package: {
    color: "#af00af"
  },
  regex: {
    color: "#af00af"
  },
  function: {
    color: "#7c00aa"
  },
  "selector .token.class": {
    color: "#7c00aa"
  },
  "selector .token.id": {
    color: "#7c00aa"
  },
  "atrule .token.rule": {
    color: "#a04900"
  },
  combinator: {
    color: "#a04900"
  },
  keyword: {
    color: "#a04900"
  },
  operator: {
    color: "#a04900"
  },
  "pseudo-class": {
    color: "#a04900"
  },
  "pseudo-element": {
    color: "#a04900"
  },
  selector: {
    color: "#a04900"
  },
  unit: {
    color: "#a04900"
  },
  deleted: {
    color: "#c22f2e"
  },
  important: {
    color: "#c22f2e",
    fontWeight: "bold"
  },
  "keyword-this": {
    color: "#005a8e",
    fontWeight: "bold"
  },
  this: {
    color: "#005a8e",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  entity: {
    cursor: "help"
  },
  "token.tab:not(:empty):before": {
    color: "#3c526d"
  },
  "token.cr:before": {
    color: "#3c526d"
  },
  "token.lf:before": {
    color: "#3c526d"
  },
  "token.space:before": {
    color: "#3c526d"
  }
};
var solarizedDarkAtom = {
  base: {
    color: "#839496",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    borderRadius: "0.3em",
    background: "#002b36"
  },
  comment: {
    color: "#586e75"
  },
  prolog: {
    color: "#586e75"
  },
  doctype: {
    color: "#586e75"
  },
  cdata: {
    color: "#586e75"
  },
  punctuation: {
    color: "#93a1a1"
  },
  property: {
    color: "#268bd2"
  },
  keyword: {
    color: "#268bd2"
  },
  tag: {
    color: "#268bd2"
  },
  "class-name": {
    color: "#FFFFB6",
    textDecoration: "underline"
  },
  boolean: {
    color: "#b58900"
  },
  constant: {
    color: "#b58900"
  },
  symbol: {
    color: "#dc322f"
  },
  deleted: {
    color: "#dc322f"
  },
  number: {
    color: "#859900"
  },
  selector: {
    color: "#859900"
  },
  "attr-name": {
    color: "#859900"
  },
  string: {
    color: "#859900"
  },
  char: {
    color: "#859900"
  },
  builtin: {
    color: "#859900"
  },
  inserted: {
    color: "#859900"
  },
  variable: {
    color: "#268bd2"
  },
  operator: {
    color: "#EDEDED"
  },
  function: {
    color: "#268bd2"
  },
  regex: {
    color: "#E9C062"
  },
  important: {
    color: "#fd971f",
    fontWeight: "bold"
  },
  entity: {
    color: "#FFFFB6",
    cursor: "help"
  },
  url: {
    color: "#96CBFE"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  atrule: {
    color: "#F9EE98"
  },
  "attr-value": {
    color: "#F9EE98"
  }
};
var synthwave84 = {
  base: {
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3",
    background: "none",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    backgroundColor: "transparent !important",
    backgroundImage: "linear-gradient(to bottom, #2a2139 75%, #34294f)"
  },
  comment: {
    color: "#8e8e8e"
  },
  "block-comment": {
    color: "#8e8e8e"
  },
  prolog: {
    color: "#8e8e8e"
  },
  doctype: {
    color: "#8e8e8e"
  },
  cdata: {
    color: "#8e8e8e"
  },
  punctuation: {
    color: "#ccc"
  },
  tag: {
    color: "#e2777a"
  },
  "attr-name": {
    color: "#e2777a"
  },
  namespace: {
    color: "#e2777a"
  },
  number: {
    color: "#e2777a"
  },
  unit: {
    color: "#e2777a"
  },
  hexcode: {
    color: "#e2777a"
  },
  deleted: {
    color: "#e2777a"
  },
  property: {
    color: "#72f1b8",
    textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
  },
  selector: {
    color: "#72f1b8",
    textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
  },
  "function-name": {
    color: "#6196cc"
  },
  boolean: {
    color: "#fdfdfd",
    textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
  },
  "selector .token.id": {
    color: "#fdfdfd",
    textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
  },
  function: {
    color: "#fdfdfd",
    textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
  },
  "class-name": {
    color: "#fff5f6",
    textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
  },
  constant: {
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  symbol: {
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  important: {
    color: "#f4eee4",
    textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575",
    fontWeight: "bold"
  },
  atrule: {
    color: "#f4eee4",
    textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
  },
  keyword: {
    color: "#f4eee4",
    textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
  },
  "selector .token.class": {
    color: "#f4eee4",
    textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
  },
  builtin: {
    color: "#f4eee4",
    textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
  },
  string: {
    color: "#f87c32"
  },
  char: {
    color: "#f87c32"
  },
  "attr-value": {
    color: "#f87c32"
  },
  regex: {
    color: "#f87c32"
  },
  variable: {
    color: "#f87c32"
  },
  operator: {
    color: "#67cdcc"
  },
  entity: {
    color: "#67cdcc",
    cursor: "help"
  },
  url: {
    color: "#67cdcc"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  inserted: {
    color: "green"
  }
};
var materialOceanic = {
  base: {
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    color: "#c3cee3",
    background: "#263238",
    fontFamily: "Roboto Mono, monospace",
    fontSize: "1em",
    lineHeight: "1.5em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    overflow: "auto",
    position: "relative",
    margin: "0.5em 0",
    padding: "1.25em 1em"
  },
  atrule: {
    color: "#c792ea"
  },
  "attr-name": {
    color: "#ffcb6b"
  },
  "attr-value": {
    color: "#c3e88d"
  },
  attribute: {
    color: "#c3e88d"
  },
  boolean: {
    color: "#c792ea"
  },
  builtin: {
    color: "#ffcb6b"
  },
  cdata: {
    color: "#80cbc4"
  },
  char: {
    color: "#80cbc4"
  },
  class: {
    color: "#ffcb6b"
  },
  "class-name": {
    color: "#f2ff00"
  },
  color: {
    color: "#f2ff00"
  },
  comment: {
    color: "#546e7a"
  },
  constant: {
    color: "#c792ea"
  },
  deleted: {
    color: "#f07178"
  },
  doctype: {
    color: "#546e7a"
  },
  entity: {
    color: "#f07178"
  },
  function: {
    color: "#c792ea"
  },
  hexcode: {
    color: "#f2ff00"
  },
  id: {
    color: "#c792ea",
    fontWeight: "bold"
  },
  important: {
    color: "#c792ea",
    fontWeight: "bold"
  },
  inserted: {
    color: "#80cbc4"
  },
  keyword: {
    color: "#c792ea",
    fontStyle: "italic"
  },
  number: {
    color: "#fd9170"
  },
  operator: {
    color: "#89ddff"
  },
  prolog: {
    color: "#546e7a"
  },
  property: {
    color: "#80cbc4"
  },
  "pseudo-class": {
    color: "#c3e88d"
  },
  "pseudo-element": {
    color: "#c3e88d"
  },
  punctuation: {
    color: "#89ddff"
  },
  regex: {
    color: "#f2ff00"
  },
  selector: {
    color: "#f07178"
  },
  string: {
    color: "#c3e88d"
  },
  symbol: {
    color: "#c792ea"
  },
  tag: {
    color: "#f07178"
  },
  unit: {
    color: "#f07178"
  },
  url: {
    color: "#fd9170"
  },
  variable: {
    color: "#f07178"
  }
};
var duotoneSpace = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#24242e",
    color: "#767693",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#5b5b76"
  },
  prolog: {
    color: "#5b5b76"
  },
  doctype: {
    color: "#5b5b76"
  },
  cdata: {
    color: "#5b5b76"
  },
  punctuation: {
    color: "#5b5b76"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#dd672c"
  },
  operator: {
    color: "#dd672c"
  },
  number: {
    color: "#dd672c"
  },
  property: {
    color: "#767693"
  },
  function: {
    color: "#767693"
  },
  "tag-id": {
    color: "#ebebff"
  },
  selector: {
    color: "#ebebff"
  },
  "atrule-id": {
    color: "#ebebff"
  },
  "attr-name": {
    color: "#aaaaca"
  },
  boolean: {
    color: "#fe8c52"
  },
  string: {
    color: "#fe8c52"
  },
  entity: {
    color: "#fe8c52",
    cursor: "help"
  },
  url: {
    color: "#fe8c52"
  },
  "attr-value": {
    color: "#fe8c52"
  },
  keyword: {
    color: "#fe8c52"
  },
  control: {
    color: "#fe8c52"
  },
  directive: {
    color: "#fe8c52"
  },
  unit: {
    color: "#fe8c52"
  },
  statement: {
    color: "#fe8c52"
  },
  regex: {
    color: "#fe8c52"
  },
  atrule: {
    color: "#fe8c52"
  },
  placeholder: {
    color: "#fe8c52"
  },
  variable: {
    color: "#fe8c52"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #ebebff",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#aaaaca"
  },
  bold: {
    fontWeight: "bold"
  }
};
var materialLight = {
  base: {
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    color: "#90a4ae",
    background: "#fafafa",
    fontFamily: "Roboto Mono, monospace",
    fontSize: "1em",
    lineHeight: "1.5em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    overflow: "auto",
    position: "relative",
    margin: "0.5em 0",
    padding: "1.25em 1em"
  },
  atrule: {
    color: "#7c4dff"
  },
  "attr-name": {
    color: "#39adb5"
  },
  "attr-value": {
    color: "#f6a434"
  },
  attribute: {
    color: "#f6a434"
  },
  boolean: {
    color: "#7c4dff"
  },
  builtin: {
    color: "#39adb5"
  },
  cdata: {
    color: "#39adb5"
  },
  char: {
    color: "#39adb5"
  },
  class: {
    color: "#39adb5"
  },
  "class-name": {
    color: "#6182b8"
  },
  comment: {
    color: "#aabfc9"
  },
  constant: {
    color: "#7c4dff"
  },
  deleted: {
    color: "#e53935"
  },
  doctype: {
    color: "#aabfc9"
  },
  entity: {
    color: "#e53935"
  },
  function: {
    color: "#7c4dff"
  },
  hexcode: {
    color: "#f76d47"
  },
  id: {
    color: "#7c4dff",
    fontWeight: "bold"
  },
  important: {
    color: "#7c4dff",
    fontWeight: "bold"
  },
  inserted: {
    color: "#39adb5"
  },
  keyword: {
    color: "#7c4dff"
  },
  number: {
    color: "#f76d47"
  },
  operator: {
    color: "#39adb5"
  },
  prolog: {
    color: "#aabfc9"
  },
  property: {
    color: "#39adb5"
  },
  "pseudo-class": {
    color: "#f6a434"
  },
  "pseudo-element": {
    color: "#f6a434"
  },
  punctuation: {
    color: "#39adb5"
  },
  regex: {
    color: "#6182b8"
  },
  selector: {
    color: "#e53935"
  },
  string: {
    color: "#f6a434"
  },
  symbol: {
    color: "#7c4dff"
  },
  tag: {
    color: "#e53935"
  },
  unit: {
    color: "#f76d47"
  },
  url: {
    color: "#e53935"
  },
  variable: {
    color: "#e53935"
  }
};
var duotoneSea = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#1d262f",
    color: "#57718e",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#4a5f78"
  },
  prolog: {
    color: "#4a5f78"
  },
  doctype: {
    color: "#4a5f78"
  },
  cdata: {
    color: "#4a5f78"
  },
  punctuation: {
    color: "#4a5f78"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#0aa370"
  },
  operator: {
    color: "#0aa370"
  },
  number: {
    color: "#0aa370"
  },
  property: {
    color: "#57718e"
  },
  function: {
    color: "#57718e"
  },
  "tag-id": {
    color: "#ebf4ff"
  },
  selector: {
    color: "#ebf4ff"
  },
  "atrule-id": {
    color: "#ebf4ff"
  },
  "attr-name": {
    color: "#7eb6f6"
  },
  boolean: {
    color: "#47ebb4"
  },
  string: {
    color: "#47ebb4"
  },
  entity: {
    color: "#47ebb4",
    cursor: "help"
  },
  url: {
    color: "#47ebb4"
  },
  "attr-value": {
    color: "#47ebb4"
  },
  keyword: {
    color: "#47ebb4"
  },
  control: {
    color: "#47ebb4"
  },
  directive: {
    color: "#47ebb4"
  },
  unit: {
    color: "#47ebb4"
  },
  statement: {
    color: "#47ebb4"
  },
  regex: {
    color: "#47ebb4"
  },
  atrule: {
    color: "#47ebb4"
  },
  placeholder: {
    color: "#47ebb4"
  },
  variable: {
    color: "#47ebb4"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #ebf4ff",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#7eb6f6"
  },
  bold: {
    fontWeight: "bold"
  }
};
var a11yDark = {
  base: {
    color: "#f8f8f2",
    background: "#2b2b2b",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "#d4d0ab"
  },
  prolog: {
    color: "#d4d0ab"
  },
  doctype: {
    color: "#d4d0ab"
  },
  cdata: {
    color: "#d4d0ab"
  },
  punctuation: {
    color: "#fefefe"
  },
  property: {
    color: "#ffa07a"
  },
  tag: {
    color: "#ffa07a"
  },
  constant: {
    color: "#ffa07a"
  },
  symbol: {
    color: "#ffa07a"
  },
  deleted: {
    color: "#ffa07a"
  },
  boolean: {
    color: "#00e0e0"
  },
  number: {
    color: "#00e0e0"
  },
  selector: {
    color: "#abe338"
  },
  "attr-name": {
    color: "#abe338"
  },
  string: {
    color: "#abe338"
  },
  char: {
    color: "#abe338"
  },
  builtin: {
    color: "#abe338"
  },
  inserted: {
    color: "#abe338"
  },
  operator: {
    color: "#00e0e0"
  },
  entity: {
    color: "#00e0e0",
    cursor: "help"
  },
  url: {
    color: "#00e0e0"
  },
  variable: {
    color: "#00e0e0"
  },
  atrule: {
    color: "#ffd700"
  },
  "attr-value": {
    color: "#ffd700"
  },
  function: {
    color: "#ffd700"
  },
  keyword: {
    color: "#00e0e0"
  },
  regex: {
    color: "#ffd700"
  },
  important: {
    color: "#ffd700",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var darcula = {
  base: {
    color: "#a9b7c6",
    fontFamily: "Consolas, Monaco, 'Andale Mono', monospace",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    background: "#2b2b2b"
  },
  comment: {
    color: "#808080"
  },
  prolog: {
    color: "#808080"
  },
  cdata: {
    color: "#808080"
  },
  delimiter: {
    color: "#cc7832"
  },
  boolean: {
    color: "#cc7832"
  },
  keyword: {
    color: "#cc7832"
  },
  selector: {
    color: "#cc7832"
  },
  important: {
    color: "#cc7832"
  },
  atrule: {
    color: "#cc7832"
  },
  operator: {
    color: "#a9b7c6"
  },
  punctuation: {
    color: "#a9b7c6"
  },
  "attr-name": {
    color: "#a9b7c6"
  },
  tag: {
    color: "#e8bf6a"
  },
  "tag .punctuation": {
    color: "#e8bf6a"
  },
  doctype: {
    color: "#e8bf6a"
  },
  builtin: {
    color: "#e8bf6a"
  },
  entity: {
    color: "#6897bb"
  },
  number: {
    color: "#6897bb"
  },
  symbol: {
    color: "#6897bb"
  },
  property: {
    color: "#9876aa"
  },
  constant: {
    color: "#9876aa"
  },
  variable: {
    color: "#9876aa"
  },
  string: {
    color: "#6a8759"
  },
  char: {
    color: "#6a8759"
  },
  "attr-value": {
    color: "#a5c261"
  },
  "attr-value .punctuation": {
    color: "#a5c261"
  },
  "attr-value .punctuation:first-child": {
    color: "#a9b7c6"
  },
  url: {
    color: "#287bde",
    textDecoration: "underline"
  },
  function: {
    color: "#ffc66d"
  },
  regex: {
    background: "#364135"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  inserted: {
    background: "#294436"
  },
  deleted: {
    background: "#484a4a"
  }
};
var zTouch = {
  base: {
    color: "white",
    fontFamily: "monospace",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    lineHeight: "25px",
    fontSize: "18px",
    margin: "0.5em 0",
    background: "#0a143c",
    padding: "1em",
    overflow: "auto"
  },
  comment: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  prolog: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  cdata: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  punctuation: {
    color: "rgb(199, 146, 234)"
  },
  deleted: {
    color: "rgba(239, 83, 80, 0.56)",
    fontStyle: "italic"
  },
  symbol: {
    color: "rgb(128, 203, 196)"
  },
  property: {
    color: "rgb(128, 203, 196)"
  },
  tag: {
    color: "rgb(127, 219, 202)"
  },
  operator: {
    color: "rgb(127, 219, 202)"
  },
  keyword: {
    color: "rgb(127, 219, 202)"
  },
  boolean: {
    color: "rgb(255, 88, 116)"
  },
  number: {
    color: "rgb(247, 140, 108)"
  },
  constant: {
    color: "rgb(34 183 199)"
  },
  function: {
    color: "rgb(34 183 199)"
  },
  builtin: {
    color: "rgb(34 183 199)"
  },
  char: {
    color: "rgb(34 183 199)"
  },
  selector: {
    color: "rgb(199, 146, 234)",
    fontStyle: "italic"
  },
  doctype: {
    color: "rgb(199, 146, 234)",
    fontStyle: "italic"
  },
  "attr-name": {
    color: "rgb(173, 219, 103)",
    fontStyle: "italic"
  },
  inserted: {
    color: "rgb(173, 219, 103)",
    fontStyle: "italic"
  },
  string: {
    color: "rgb(173, 219, 103)"
  },
  url: {
    color: "rgb(173, 219, 103)"
  },
  entity: {
    color: "rgb(173, 219, 103)"
  },
  "class-name": {
    color: "rgb(255, 203, 139)"
  },
  atrule: {
    color: "rgb(255, 203, 139)"
  },
  "attr-value": {
    color: "rgb(255, 203, 139)"
  },
  regex: {
    color: "rgb(214, 222, 235)"
  },
  important: {
    color: "rgb(214, 222, 235)",
    fontWeight: "bold"
  },
  variable: {
    color: "rgb(214, 222, 235)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var duotoneEarth = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#322d29",
    color: "#88786d",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#6a5f58"
  },
  prolog: {
    color: "#6a5f58"
  },
  doctype: {
    color: "#6a5f58"
  },
  cdata: {
    color: "#6a5f58"
  },
  punctuation: {
    color: "#6a5f58"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#bfa05a"
  },
  operator: {
    color: "#bfa05a"
  },
  number: {
    color: "#bfa05a"
  },
  property: {
    color: "#88786d"
  },
  function: {
    color: "#88786d"
  },
  "tag-id": {
    color: "#fff3eb"
  },
  selector: {
    color: "#fff3eb"
  },
  "atrule-id": {
    color: "#fff3eb"
  },
  "attr-name": {
    color: "#a48774"
  },
  boolean: {
    color: "#fcc440"
  },
  string: {
    color: "#fcc440"
  },
  entity: {
    color: "#fcc440",
    cursor: "help"
  },
  url: {
    color: "#fcc440"
  },
  "attr-value": {
    color: "#fcc440"
  },
  keyword: {
    color: "#fcc440"
  },
  control: {
    color: "#fcc440"
  },
  directive: {
    color: "#fcc440"
  },
  unit: {
    color: "#fcc440"
  },
  statement: {
    color: "#fcc440"
  },
  regex: {
    color: "#fcc440"
  },
  atrule: {
    color: "#fcc440"
  },
  placeholder: {
    color: "#fcc440"
  },
  variable: {
    color: "#fcc440"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #fff3eb",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#a48774"
  },
  bold: {
    fontWeight: "bold"
  }
};
var gruvboxLight = {
  base: {
    color: "#3c3836",
    fontFamily: 'Consolas, Monaco, "Andale Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    background: "#f9f5d7"
  },
  comment: {
    color: "#7c6f64"
  },
  prolog: {
    color: "#7c6f64"
  },
  cdata: {
    color: "#7c6f64"
  },
  delimiter: {
    color: "#9d0006"
  },
  boolean: {
    color: "#9d0006"
  },
  keyword: {
    color: "#9d0006"
  },
  selector: {
    color: "#9d0006"
  },
  important: {
    color: "#9d0006"
  },
  atrule: {
    color: "#9d0006"
  },
  operator: {
    color: "#7c6f64"
  },
  punctuation: {
    color: "#7c6f64"
  },
  "attr-name": {
    color: "#7c6f64"
  },
  tag: {
    color: "#b57614"
  },
  "tag .punctuation": {
    color: "#b57614"
  },
  doctype: {
    color: "#b57614"
  },
  builtin: {
    color: "#b57614"
  },
  entity: {
    color: "#8f3f71"
  },
  number: {
    color: "#8f3f71"
  },
  symbol: {
    color: "#8f3f71"
  },
  property: {
    color: "#9d0006"
  },
  constant: {
    color: "#9d0006"
  },
  variable: {
    color: "#9d0006"
  },
  string: {
    color: "#797403"
  },
  char: {
    color: "#797403"
  },
  "attr-value": {
    color: "#7c6f64"
  },
  "attr-value .punctuation": {
    color: "#7c6f64"
  },
  url: {
    color: "#797403",
    textDecoration: "underline"
  },
  function: {
    color: "#b57614"
  },
  regex: {
    background: "#797403"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  inserted: {
    background: "#7c6f64"
  },
  deleted: {
    background: "#9d0006"
  }
};
var oneDark = {
  base: {
    background: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(220, 10%, 40%)"
  },
  cdata: {
    color: "hsl(220, 10%, 40%)"
  },
  doctype: {
    color: "hsl(220, 14%, 71%)"
  },
  punctuation: {
    color: "hsl(220, 14%, 71%)"
  },
  entity: {
    color: "hsl(220, 14%, 71%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(29, 54%, 61%)"
  },
  "class-name": {
    color: "hsl(29, 54%, 61%)"
  },
  boolean: {
    color: "hsl(29, 54%, 61%)"
  },
  constant: {
    color: "hsl(29, 54%, 61%)"
  },
  number: {
    color: "hsl(29, 54%, 61%)"
  },
  atrule: {
    color: "hsl(29, 54%, 61%)"
  },
  keyword: {
    color: "hsl(286, 60%, 67%)"
  },
  property: {
    color: "hsl(355, 65%, 65%)"
  },
  tag: {
    color: "hsl(355, 65%, 65%)"
  },
  symbol: {
    color: "hsl(355, 65%, 65%)"
  },
  deleted: {
    color: "hsl(355, 65%, 65%)"
  },
  important: {
    color: "hsl(355, 65%, 65%)"
  },
  selector: {
    color: "hsl(95, 38%, 62%)"
  },
  string: {
    color: "hsl(95, 38%, 62%)"
  },
  char: {
    color: "hsl(95, 38%, 62%)"
  },
  builtin: {
    color: "hsl(95, 38%, 62%)"
  },
  inserted: {
    color: "hsl(95, 38%, 62%)"
  },
  regex: {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value": {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(95, 38%, 62%)"
  },
  variable: {
    color: "hsl(207, 82%, 66%)"
  },
  operator: {
    color: "hsl(207, 82%, 66%)"
  },
  function: {
    color: "hsl(207, 82%, 66%)"
  },
  url: {
    color: "hsl(187, 47%, 55%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(220, 14%, 71%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(220, 14%, 71%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.cr:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.lf:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.space:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  }
};
var duotoneDark = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#2a2734",
    color: "#9a86fd",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#6c6783"
  },
  prolog: {
    color: "#6c6783"
  },
  doctype: {
    color: "#6c6783"
  },
  cdata: {
    color: "#6c6783"
  },
  punctuation: {
    color: "#6c6783"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#e09142"
  },
  operator: {
    color: "#e09142"
  },
  number: {
    color: "#e09142"
  },
  property: {
    color: "#9a86fd"
  },
  function: {
    color: "#9a86fd"
  },
  "tag-id": {
    color: "#eeebff"
  },
  selector: {
    color: "#eeebff"
  },
  "atrule-id": {
    color: "#eeebff"
  },
  "attr-name": {
    color: "#c4b9fe"
  },
  boolean: {
    color: "#ffcc99"
  },
  string: {
    color: "#ffcc99"
  },
  entity: {
    color: "#ffcc99",
    cursor: "help"
  },
  url: {
    color: "#ffcc99"
  },
  "attr-value": {
    color: "#ffcc99"
  },
  keyword: {
    color: "#ffcc99"
  },
  control: {
    color: "#ffcc99"
  },
  directive: {
    color: "#ffcc99"
  },
  unit: {
    color: "#ffcc99"
  },
  statement: {
    color: "#ffcc99"
  },
  regex: {
    color: "#ffcc99"
  },
  atrule: {
    color: "#ffcc99"
  },
  placeholder: {
    color: "#ffcc99"
  },
  variable: {
    color: "#ffcc99"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #eeebff",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#c4b9fe"
  },
  bold: {
    fontWeight: "bold"
  }
};
var lucario = {
  base: {
    color: "#f8f8f2",
    background: "#263E52",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: "Monaco, Consolas, 'Andale Mono', 'Ubuntu Mono', monospace",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "#5c98cd"
  },
  prolog: {
    color: "#5c98cd"
  },
  doctype: {
    color: "#5c98cd"
  },
  cdata: {
    color: "#5c98cd"
  },
  punctuation: {
    color: "#f8f8f2"
  },
  property: {
    color: "#F05E5D"
  },
  tag: {
    color: "#F05E5D"
  },
  constant: {
    color: "#F05E5D"
  },
  symbol: {
    color: "#F05E5D"
  },
  deleted: {
    color: "#F05E5D"
  },
  boolean: {
    color: "#BC94F9"
  },
  number: {
    color: "#BC94F9"
  },
  selector: {
    color: "#FCFCD6"
  },
  "attr-name": {
    color: "#FCFCD6"
  },
  string: {
    color: "#FCFCD6"
  },
  char: {
    color: "#FCFCD6"
  },
  builtin: {
    color: "#FCFCD6"
  },
  inserted: {
    color: "#FCFCD6"
  },
  operator: {
    color: "#f8f8f2"
  },
  entity: {
    color: "#f8f8f2",
    cursor: "help"
  },
  url: {
    color: "#f8f8f2"
  },
  variable: {
    color: "#f8f8f2"
  },
  atrule: {
    color: "#66D8EF"
  },
  "attr-value": {
    color: "#66D8EF"
  },
  function: {
    color: "#66D8EF"
  },
  "class-name": {
    color: "#66D8EF"
  },
  keyword: {
    color: "#6EB26E"
  },
  regex: {
    color: "#F05E5D"
  },
  important: {
    color: "#F05E5D",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var coldarkDark = {
  base: {
    color: "#e3eaf2",
    background: "#111b27",
    fontFamily: 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#8da1b9"
  },
  prolog: {
    color: "#8da1b9"
  },
  doctype: {
    color: "#8da1b9"
  },
  cdata: {
    color: "#8da1b9"
  },
  punctuation: {
    color: "#e3eaf2"
  },
  "delimiter.important": {
    color: "#66cccc",
    fontWeight: "inherit"
  },
  "selector .parent": {
    color: "#66cccc"
  },
  tag: {
    color: "#66cccc"
  },
  "tag .token.punctuation": {
    color: "#66cccc"
  },
  "attr-name": {
    color: "#e6d37a"
  },
  boolean: {
    color: "#e6d37a"
  },
  "boolean.important": {
    color: "#e6d37a"
  },
  number: {
    color: "#e6d37a"
  },
  constant: {
    color: "#e6d37a"
  },
  "selector .token.attribute": {
    color: "#e6d37a"
  },
  "class-name": {
    color: "#6cb8e6"
  },
  key: {
    color: "#6cb8e6"
  },
  parameter: {
    color: "#6cb8e6"
  },
  property: {
    color: "#6cb8e6"
  },
  "property-access": {
    color: "#6cb8e6"
  },
  variable: {
    color: "#6cb8e6"
  },
  "attr-value": {
    color: "#91d076"
  },
  inserted: {
    color: "#91d076"
  },
  color: {
    color: "#91d076"
  },
  "selector .token.value": {
    color: "#91d076"
  },
  string: {
    color: "#91d076"
  },
  "string .token.url-link": {
    color: "#91d076"
  },
  builtin: {
    color: "#f4adf4"
  },
  "keyword-array": {
    color: "#f4adf4"
  },
  package: {
    color: "#f4adf4"
  },
  regex: {
    color: "#f4adf4"
  },
  function: {
    color: "#c699e3"
  },
  "selector .token.class": {
    color: "#c699e3"
  },
  "selector .token.id": {
    color: "#c699e3"
  },
  "atrule .token.rule": {
    color: "#e9ae7e"
  },
  combinator: {
    color: "#e9ae7e"
  },
  keyword: {
    color: "#e9ae7e"
  },
  operator: {
    color: "#e9ae7e"
  },
  "pseudo-class": {
    color: "#e9ae7e"
  },
  "pseudo-element": {
    color: "#e9ae7e"
  },
  selector: {
    color: "#e9ae7e"
  },
  unit: {
    color: "#e9ae7e"
  },
  deleted: {
    color: "#cd6660"
  },
  important: {
    color: "#cd6660",
    fontWeight: "bold"
  },
  "keyword-this": {
    color: "#6cb8e6",
    fontWeight: "bold"
  },
  this: {
    color: "#6cb8e6",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  entity: {
    cursor: "help"
  },
  "token.tab:not(:empty):before": {
    color: "#8da1b9"
  },
  "token.cr:before": {
    color: "#8da1b9"
  },
  "token.lf:before": {
    color: "#8da1b9"
  },
  "token.space:before": {
    color: "#8da1b9"
  }
};
var atomDark = {
  base: {
    color: "#c5c8c6",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    borderRadius: "0.3em",
    background: "#1d1f21"
  },
  comment: {
    color: "#7C7C7C"
  },
  prolog: {
    color: "#7C7C7C"
  },
  doctype: {
    color: "#7C7C7C"
  },
  cdata: {
    color: "#7C7C7C"
  },
  punctuation: {
    color: "#c5c8c6"
  },
  property: {
    color: "#96CBFE"
  },
  keyword: {
    color: "#96CBFE"
  },
  tag: {
    color: "#96CBFE"
  },
  "class-name": {
    color: "#FFFFB6",
    textDecoration: "underline"
  },
  boolean: {
    color: "#99CC99"
  },
  constant: {
    color: "#99CC99"
  },
  symbol: {
    color: "#f92672"
  },
  deleted: {
    color: "#f92672"
  },
  number: {
    color: "#FF73FD"
  },
  selector: {
    color: "#A8FF60"
  },
  "attr-name": {
    color: "#A8FF60"
  },
  string: {
    color: "#A8FF60"
  },
  char: {
    color: "#A8FF60"
  },
  builtin: {
    color: "#A8FF60"
  },
  inserted: {
    color: "#A8FF60"
  },
  variable: {
    color: "#C6C5FE"
  },
  operator: {
    color: "#EDEDED"
  },
  entity: {
    color: "#FFFFB6",
    cursor: "help"
  },
  url: {
    color: "#96CBFE"
  },
  atrule: {
    color: "#F9EE98"
  },
  "attr-value": {
    color: "#F9EE98"
  },
  function: {
    color: "#DAD085"
  },
  regex: {
    color: "#E9C062"
  },
  important: {
    color: "#fd971f",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var pojoaque = {
  base: {
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    whiteSpace: "pre-wrap",
    wordBreak: "break-all",
    wordWrap: "break-word",
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    fontSize: "15px",
    lineHeight: "1.5",
    color: "#DCCF8F",
    textShadow: "0",
    borderRadius: "5px",
    border: "1px solid #000",
    background: "#181914 url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQACQYGBgcGCQcHCQ0IBwgNDwsJCQsPEQ4ODw4OERENDg4ODg0RERQUFhQUERoaHBwaGiYmJiYmKysrKysrKysrKwEJCAgJCgkMCgoMDwwODA8TDg4ODhMVDg4PDg4VGhMRERERExoXGhYWFhoXHR0aGh0dJCQjJCQrKysrKysrKysr/8AAEQgAjACMAwEiAAIRAQMRAf/EAF4AAQEBAAAAAAAAAAAAAAAAAAABBwEBAQAAAAAAAAAAAAAAAAAAAAIQAAEDAwIHAQEAAAAAAAAAAADwAREhYaExkUFRcYGxwdHh8REBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AyGFEjHaBS2fDDs2zkhKmBKktb7km+ZwwCnXPkLVmCTMItj6AXFxRS465/BTnkAJvkLkJe+7AKKoi2AtRS2zuAWsCb5GOlBN8gKfmuGHZ8MFqIth3ALmFoFwbwKWyAlTAp17uKqBvgBD8sM4fTjhvAhkzhaRkBMKBrfs7jGPIpzy7gFrAqnC0C0gB0EWwBDW2cBVQwm+QtPpa3wBO3sVvszCnLAhkzgL5/RLf13cLQd8/AGlu0Cb5HTx9KuAEieGJEdcehS3eRTp2ATdt3CpIm+QtZwAhROXFeb7swp/ahaM3kBE/jSIUBc/AWrgBN8uNFAl+b7sAXFxFn2YLUU5Ns7gFX8C4ib+hN8gFWXwK3bZglxEJm+gKdciLPsFV/TClsgJUwKJ5FVA7tvIFrfZhVfGJDcsCKaYgAqv6YRbE+RWOWBtu7+AL3yRalXLyKqAIIfk+zARbDgFyEsncYwJvlgFRW+GEWntIi2P0BooyFxcNr8Ep3+ANLbMO+QyhvbiqdgC0kVvgUUiLYgBS2QtPbiVI1/sgOmG9uO+Y8DW+7jS2zAOnj6O2BndwuIAUtkdRN8gFoK3wwXMQyZwHVbClsuNLd4E3yAUR6FVDBR+BafQGt93LVMxJTv8ABts4CVLhcfYWsCb5kC9/BHdU8CLYFY5bMAd+eX9MGthhpbA1vu4B7+RKkaW2Yq4AQtVBBFsAJU/AuIXBhN8gGWnstefhiZyWvLAEnbYS1uzSFP6Jvn4Baxx70JKkQojLib5AVTey1jjgkKJGO0AKWyOm7N7cSpgSpAdPH0Tfd/gp1z5C1ZgKqN9J2wFxcUUuAFLZAm+QC0Fb4YUVRFsAOvj4KW2dwtYE3yAWk/wS/PLMKfmuGHZ8MAXF/Ja32Yi5haAKWz4Ydm2cSpgU693Atb7km+Zwwh+WGcPpxw3gAkzCLY+iYUDW/Z3Adc/gpzyFrAqnALkJe+7DoItgAtRS2zuKqGE3yAx0oJvkdvYrfZmALURbDuL5/RLf13cAuDeBS2RpbtAm+QFVA3wR+3fUtFHoBDJnC0jIXH0HWsgMY8inPLuOkd9chp4z20ALQLSA8cI9jYAIa2zjzjBd8gRafS1vgiUho/kAKcsCGTOGWvoOpkAtB3z8Hm8x2Ff5ADp4+lXAlIvcmwH/2Q==') repeat left top",
    padding: "12px",
    overflow: "auto"
  },
  namespace: {
    opacity: ".7"
  },
  comment: {
    color: "#586e75",
    fontStyle: "italic"
  },
  prolog: {
    color: "#586e75",
    fontStyle: "italic"
  },
  doctype: {
    color: "#586e75",
    fontStyle: "italic"
  },
  cdata: {
    color: "#586e75",
    fontStyle: "italic"
  },
  number: {
    color: "#b89859"
  },
  string: {
    color: "#468966"
  },
  char: {
    color: "#468966"
  },
  builtin: {
    color: "#468966"
  },
  inserted: {
    color: "#468966"
  },
  "attr-name": {
    color: "#b89859"
  },
  operator: {
    color: "#dccf8f"
  },
  entity: {
    color: "#dccf8f",
    cursor: "help"
  },
  url: {
    color: "#dccf8f"
  },
  selector: {
    color: "#859900"
  },
  regex: {
    color: "#859900"
  },
  atrule: {
    color: "#cb4b16"
  },
  keyword: {
    color: "#cb4b16"
  },
  "attr-value": {
    color: "#468966"
  },
  function: {
    color: "#b58900"
  },
  variable: {
    color: "#b58900"
  },
  placeholder: {
    color: "#b58900"
  },
  property: {
    color: "#b89859"
  },
  tag: {
    color: "#ffb03b"
  },
  boolean: {
    color: "#b89859"
  },
  constant: {
    color: "#b89859"
  },
  symbol: {
    color: "#b89859"
  },
  important: {
    color: "#dc322f"
  },
  statement: {
    color: "#dc322f"
  },
  deleted: {
    color: "#dc322f"
  },
  punctuation: {
    color: "#dccf8f"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var duotoneLight = {
  base: {
    fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
    fontSize: "14px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    background: "#faf8f5",
    color: "#728fcb",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#b6ad9a"
  },
  prolog: {
    color: "#b6ad9a"
  },
  doctype: {
    color: "#b6ad9a"
  },
  cdata: {
    color: "#b6ad9a"
  },
  punctuation: {
    color: "#b6ad9a"
  },
  namespace: {
    opacity: ".7"
  },
  tag: {
    color: "#063289"
  },
  operator: {
    color: "#063289"
  },
  number: {
    color: "#063289"
  },
  property: {
    color: "#b29762"
  },
  function: {
    color: "#b29762"
  },
  "tag-id": {
    color: "#2d2006"
  },
  selector: {
    color: "#2d2006"
  },
  "atrule-id": {
    color: "#2d2006"
  },
  "attr-name": {
    color: "#896724"
  },
  boolean: {
    color: "#728fcb"
  },
  string: {
    color: "#728fcb"
  },
  entity: {
    color: "#728fcb",
    cursor: "help"
  },
  url: {
    color: "#728fcb"
  },
  "attr-value": {
    color: "#728fcb"
  },
  keyword: {
    color: "#728fcb"
  },
  control: {
    color: "#728fcb"
  },
  directive: {
    color: "#728fcb"
  },
  unit: {
    color: "#728fcb"
  },
  statement: {
    color: "#728fcb"
  },
  regex: {
    color: "#728fcb"
  },
  atrule: {
    color: "#728fcb"
  },
  placeholder: {
    color: "#93abdc"
  },
  variable: {
    color: "#93abdc"
  },
  deleted: {
    textDecoration: "line-through"
  },
  inserted: {
    borderBottom: "1px dotted #2d2006",
    textDecoration: "none"
  },
  italic: {
    fontStyle: "italic"
  },
  important: {
    fontWeight: "bold",
    color: "#896724"
  },
  bold: {
    fontWeight: "bold"
  }
};
var nightOwl = {
  base: {
    color: "white",
    fontFamily: 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    fontSize: "1em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    background: "#011627"
  },
  comment: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  prolog: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  cdata: {
    color: "rgb(99, 119, 119)",
    fontStyle: "italic"
  },
  punctuation: {
    color: "rgb(199, 146, 234)"
  },
  deleted: {
    color: "rgba(239, 83, 80, 0.56)",
    fontStyle: "italic"
  },
  symbol: {
    color: "rgb(128, 203, 196)"
  },
  property: {
    color: "rgb(128, 203, 196)"
  },
  tag: {
    color: "rgb(127, 219, 202)"
  },
  operator: {
    color: "rgb(127, 219, 202)"
  },
  keyword: {
    color: "rgb(127, 219, 202)"
  },
  boolean: {
    color: "rgb(255, 88, 116)"
  },
  number: {
    color: "rgb(247, 140, 108)"
  },
  constant: {
    color: "rgb(130, 170, 255)"
  },
  function: {
    color: "rgb(130, 170, 255)"
  },
  builtin: {
    color: "rgb(130, 170, 255)"
  },
  char: {
    color: "rgb(130, 170, 255)"
  },
  selector: {
    color: "rgb(199, 146, 234)",
    fontStyle: "italic"
  },
  doctype: {
    color: "rgb(199, 146, 234)",
    fontStyle: "italic"
  },
  "attr-name": {
    color: "rgb(173, 219, 103)",
    fontStyle: "italic"
  },
  inserted: {
    color: "rgb(173, 219, 103)",
    fontStyle: "italic"
  },
  string: {
    color: "rgb(173, 219, 103)"
  },
  url: {
    color: "rgb(173, 219, 103)"
  },
  entity: {
    color: "rgb(173, 219, 103)"
  },
  "class-name": {
    color: "rgb(255, 203, 139)"
  },
  atrule: {
    color: "rgb(255, 203, 139)"
  },
  "attr-value": {
    color: "rgb(255, 203, 139)"
  },
  regex: {
    color: "rgb(214, 222, 235)"
  },
  important: {
    color: "rgb(214, 222, 235)",
    fontWeight: "bold"
  },
  variable: {
    color: "rgb(214, 222, 235)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var laserwave = {
  base: {
    background: "#27212e",
    color: "#ffffff",
    fontFamily: 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
    fontSize: "1em",
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.5em"
  },
  comment: {
    color: "#91889b"
  },
  prolog: {
    color: "#91889b"
  },
  cdata: {
    color: "#91889b"
  },
  punctuation: {
    color: "#7b6995"
  },
  builtin: {
    color: "#ffe261"
  },
  constant: {
    color: "#ffe261"
  },
  boolean: {
    color: "#ffe261"
  },
  number: {
    color: "#b381c5"
  },
  important: {
    color: "#40b4c4"
  },
  atrule: {
    color: "#40b4c4"
  },
  property: {
    color: "#40b4c4"
  },
  keyword: {
    color: "#40b4c4"
  },
  doctype: {
    color: "#74dfc4"
  },
  operator: {
    color: "#74dfc4"
  },
  inserted: {
    color: "#74dfc4"
  },
  tag: {
    color: "#74dfc4"
  },
  "class-name": {
    color: "#74dfc4"
  },
  symbol: {
    color: "#74dfc4"
  },
  "attr-name": {
    color: "#eb64b9"
  },
  function: {
    color: "#eb64b9"
  },
  deleted: {
    color: "#eb64b9"
  },
  selector: {
    color: "#eb64b9"
  },
  "attr-value": {
    color: "#b4dce7"
  },
  regex: {
    color: "#b4dce7"
  },
  char: {
    color: "#b4dce7"
  },
  string: {
    color: "#b4dce7"
  },
  entity: {
    color: "#ffffff",
    cursor: "help"
  },
  url: {
    color: "#ffffff"
  },
  variable: {
    color: "#ffffff"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    opacity: "0.7"
  }
};
var coyWithoutShadows = {
  base: {
    color: "black",
    background: "none",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    position: "relative",
    borderLeft: "10px solid #358ccb",
    boxShadow: "-1px 0 0 0 #358ccb, 0 0 0 1px #dfdfdf",
    backgroundColor: "#fdfdfd",
    backgroundImage: "linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%)",
    backgroundSize: "3em 3em",
    backgroundOrigin: "content-box",
    backgroundAttachment: "local",
    margin: ".5em 0",
    padding: "0 1em"
  },
  comment: {
    color: "#7D8B99"
  },
  "block-comment": {
    color: "#7D8B99"
  },
  prolog: {
    color: "#7D8B99"
  },
  doctype: {
    color: "#7D8B99"
  },
  cdata: {
    color: "#7D8B99"
  },
  punctuation: {
    color: "#5F6364"
  },
  property: {
    color: "#c92c2c"
  },
  tag: {
    color: "#c92c2c"
  },
  boolean: {
    color: "#c92c2c"
  },
  number: {
    color: "#c92c2c"
  },
  "function-name": {
    color: "#c92c2c"
  },
  constant: {
    color: "#c92c2c"
  },
  symbol: {
    color: "#c92c2c"
  },
  deleted: {
    color: "#c92c2c"
  },
  selector: {
    color: "#2f9c0a"
  },
  "attr-name": {
    color: "#2f9c0a"
  },
  string: {
    color: "#2f9c0a"
  },
  char: {
    color: "#2f9c0a"
  },
  function: {
    color: "#2f9c0a"
  },
  builtin: {
    color: "#2f9c0a"
  },
  inserted: {
    color: "#2f9c0a"
  },
  operator: {
    color: "#a67f59",
    background: "rgba(255, 255, 255, 0.5)"
  },
  entity: {
    color: "#a67f59",
    background: "rgba(255, 255, 255, 0.5)",
    cursor: "help"
  },
  url: {
    color: "#a67f59",
    background: "rgba(255, 255, 255, 0.5)"
  },
  variable: {
    color: "#a67f59",
    background: "rgba(255, 255, 255, 0.5)"
  },
  atrule: {
    color: "#1990b8"
  },
  "attr-value": {
    color: "#1990b8"
  },
  keyword: {
    color: "#1990b8"
  },
  "class-name": {
    color: "#1990b8"
  },
  regex: {
    color: "#e90"
  },
  important: {
    color: "#e90",
    fontWeight: "normal"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    opacity: ".7"
  }
};
var hopscotch = {
  base: {
    fontFamily: '"Fira Mono", Menlo, Monaco, "Lucida Console", "Courier New", Courier, monospace',
    fontSize: "16px",
    lineHeight: "1.375",
    direction: "ltr",
    textAlign: "left",
    wordSpacing: "normal",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    whiteSpace: "pre-wrap",
    wordBreak: "break-all",
    wordWrap: "break-word",
    background: "#322931",
    color: "#b9b5b8",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  comment: {
    color: "#797379"
  },
  prolog: {
    color: "#797379"
  },
  doctype: {
    color: "#797379"
  },
  cdata: {
    color: "#797379"
  },
  punctuation: {
    color: "#b9b5b8"
  },
  null: {
    color: "#fd8b19"
  },
  operator: {
    color: "#fd8b19"
  },
  boolean: {
    color: "#fd8b19"
  },
  number: {
    color: "#fd8b19"
  },
  property: {
    color: "#fdcc59"
  },
  tag: {
    color: "#1290bf"
  },
  string: {
    color: "#149b93"
  },
  selector: {
    color: "#c85e7c"
  },
  "attr-name": {
    color: "#fd8b19"
  },
  entity: {
    color: "#149b93",
    cursor: "help"
  },
  url: {
    color: "#149b93"
  },
  "attr-value": {
    color: "#8fc13e"
  },
  keyword: {
    color: "#8fc13e"
  },
  control: {
    color: "#8fc13e"
  },
  directive: {
    color: "#8fc13e"
  },
  unit: {
    color: "#8fc13e"
  },
  statement: {
    color: "#149b93"
  },
  regex: {
    color: "#149b93"
  },
  atrule: {
    color: "#149b93"
  },
  placeholder: {
    color: "#1290bf"
  },
  variable: {
    color: "#1290bf"
  },
  important: {
    color: "#dd464c",
    fontWeight: "bold"
  }
};
var oneLight = {
  base: {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(230, 4%, 64%)"
  },
  cdata: {
    color: "hsl(230, 4%, 64%)"
  },
  doctype: {
    color: "hsl(230, 8%, 24%)"
  },
  punctuation: {
    color: "hsl(230, 8%, 24%)"
  },
  entity: {
    color: "hsl(230, 8%, 24%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(35, 99%, 36%)"
  },
  "class-name": {
    color: "hsl(35, 99%, 36%)"
  },
  boolean: {
    color: "hsl(35, 99%, 36%)"
  },
  constant: {
    color: "hsl(35, 99%, 36%)"
  },
  number: {
    color: "hsl(35, 99%, 36%)"
  },
  atrule: {
    color: "hsl(35, 99%, 36%)"
  },
  keyword: {
    color: "hsl(301, 63%, 40%)"
  },
  property: {
    color: "hsl(5, 74%, 59%)"
  },
  tag: {
    color: "hsl(5, 74%, 59%)"
  },
  symbol: {
    color: "hsl(5, 74%, 59%)"
  },
  deleted: {
    color: "hsl(5, 74%, 59%)"
  },
  important: {
    color: "hsl(5, 74%, 59%)"
  },
  selector: {
    color: "hsl(119, 34%, 47%)"
  },
  string: {
    color: "hsl(119, 34%, 47%)"
  },
  char: {
    color: "hsl(119, 34%, 47%)"
  },
  builtin: {
    color: "hsl(119, 34%, 47%)"
  },
  inserted: {
    color: "hsl(119, 34%, 47%)"
  },
  regex: {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value": {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(119, 34%, 47%)"
  },
  variable: {
    color: "hsl(221, 87%, 60%)"
  },
  operator: {
    color: "hsl(221, 87%, 60%)"
  },
  function: {
    color: "hsl(221, 87%, 60%)"
  },
  url: {
    color: "hsl(198, 99%, 37%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(230, 8%, 24%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(230, 8%, 24%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.cr:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.lf:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.space:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  }
};
var nord = {
  base: {
    color: "#f8f8f2",
    background: "#2E3440",
    fontFamily: `"Fira Code", Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace`,
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  comment: {
    color: "#636f88"
  },
  prolog: {
    color: "#636f88"
  },
  doctype: {
    color: "#636f88"
  },
  cdata: {
    color: "#636f88"
  },
  punctuation: {
    color: "#81A1C1"
  },
  property: {
    color: "#81A1C1"
  },
  tag: {
    color: "#81A1C1"
  },
  constant: {
    color: "#81A1C1"
  },
  symbol: {
    color: "#81A1C1"
  },
  deleted: {
    color: "#81A1C1"
  },
  number: {
    color: "#B48EAD"
  },
  boolean: {
    color: "#81A1C1"
  },
  selector: {
    color: "#A3BE8C"
  },
  "attr-name": {
    color: "#A3BE8C"
  },
  string: {
    color: "#A3BE8C"
  },
  char: {
    color: "#A3BE8C"
  },
  builtin: {
    color: "#A3BE8C"
  },
  inserted: {
    color: "#A3BE8C"
  },
  operator: {
    color: "#81A1C1"
  },
  entity: {
    color: "#81A1C1",
    cursor: "help"
  },
  url: {
    color: "#81A1C1"
  },
  variable: {
    color: "#81A1C1"
  },
  atrule: {
    color: "#88C0D0"
  },
  "attr-value": {
    color: "#88C0D0"
  },
  function: {
    color: "#88C0D0"
  },
  "class-name": {
    color: "#88C0D0"
  },
  keyword: {
    color: "#81A1C1"
  },
  regex: {
    color: "#EBCB8B"
  },
  important: {
    color: "#EBCB8B",
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var ghcolors = {
  base: {
    color: "#393A34",
    fontFamily: '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    fontSize: ".9em",
    lineHeight: "1.2em",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    border: "1px solid #dddddd",
    backgroundColor: "white"
  },
  comment: {
    color: "#999988",
    fontStyle: "italic"
  },
  prolog: {
    color: "#999988",
    fontStyle: "italic"
  },
  doctype: {
    color: "#999988",
    fontStyle: "italic"
  },
  cdata: {
    color: "#999988",
    fontStyle: "italic"
  },
  namespace: {
    opacity: ".7"
  },
  string: {
    color: "#e3116c"
  },
  "attr-value": {
    color: "#e3116c"
  },
  punctuation: {
    color: "#393A34"
  },
  operator: {
    color: "#393A34"
  },
  entity: {
    color: "#36acaa"
  },
  url: {
    color: "#36acaa"
  },
  symbol: {
    color: "#36acaa"
  },
  number: {
    color: "#36acaa"
  },
  boolean: {
    color: "#36acaa"
  },
  variable: {
    color: "#36acaa"
  },
  constant: {
    color: "#36acaa"
  },
  property: {
    color: "#36acaa"
  },
  regex: {
    color: "#36acaa"
  },
  inserted: {
    color: "#36acaa"
  },
  atrule: {
    color: "#00a4db"
  },
  keyword: {
    color: "#00a4db"
  },
  "attr-name": {
    color: "#00a4db"
  },
  function: {
    color: "#9a050f",
    fontWeight: "bold"
  },
  deleted: {
    color: "#9a050f"
  },
  tag: {
    color: "#00009f"
  },
  selector: {
    color: "#00009f"
  },
  important: {
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var vesper = {
  base: {
    color: "#a0a0a0",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    MsHyphens: "none",
    hyphens: "none",
    overflowX: "auto",
    backgroundColor: "#1E1E1E"
  },
  selection: {
    textShadow: "none",
    background: "#ffffff25"
  },
  print: {
    textShadow: "none"
  },
  pre: {
    color: "#a0a0a0",
    background: "#101010"
  },
  comment: {
    color: "#8b8b8b94"
  },
  punctuation: {
    color: "#8b8b8b94"
  },
  variable: {
    color: "#a0a0a0"
  },
  tag: {
    color: "#a0a0a0"
  },
  hexcode: {
    color: "#a0a0a0"
  },
  string: {
    color: "rgb(161, 252, 234)"
  },
  url: {
    color: "#a0a0a0"
  },
  keyword: {
    color: "#fff"
  },
  deleted: {
    color: "#fff"
  },
  function: {
    color: "#ffc799"
  },
  builtin: {
    color: "#fff"
  },
  number: {
    color: "#fff"
  },
  char: {
    color: "#fff"
  },
  constant: {
    color: "#fff"
  },
  boolean: {
    color: "#fff"
  },
  changed: {
    color: "#fff"
  },
  symbol: {
    color: "#99ffe4"
  },
  inserted: {
    color: "#ffc799"
  },
  "attr-name": {
    color: "#a0a0a0"
  },
  selector: {
    color: "#a0a0a0"
  },
  property: {
    color: "#a0a0a0"
  },
  regex: {
    color: "#a0a0a0"
  },
  important: {
    fontWeight: "bold"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};

// node_modules/@react-email/code-inline/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var __defProp4 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp4.call(b3, prop))
      __defNormalProp4(a, prop, b3[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b3)) {
      if (__propIsEnum4.call(b3, prop))
        __defNormalProp4(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b3) => __defProps4(a, __getOwnPropDescs4(b3));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var CodeInline = React4.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children } = _b, props = __objRest4(_b, ["children"]);
    return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      (0, import_jsx_runtime4.jsx)("style", { children: `
        meta ~ .cino {
          display: none !important;
          opacity: 0 !important;
        }

        meta ~ .cio {
          display: block !important;
        }
      ` }),
      (0, import_jsx_runtime4.jsx)(
        "code",
        __spreadProps4(__spreadValues4({}, props), {
          className: `${props.className ? props.className : ""} cino`,
          children
        })
      ),
      (0, import_jsx_runtime4.jsx)(
        "span",
        __spreadProps4(__spreadValues4({}, props), {
          className: `${props.className ? props.className : ""} cio`,
          ref,
          style: __spreadValues4({ display: "none" }, props.style),
          children
        })
      )
    ] });
  }
);
CodeInline.displayName = "CodeInline";

// node_modules/@react-email/column/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var __defProp5 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp5.call(b3, prop))
      __defNormalProp5(a, prop, b3[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b3)) {
      if (__propIsEnum5.call(b3, prop))
        __defNormalProp5(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b3) => __defProps5(a, __getOwnPropDescs5(b3));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Column = React5.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style } = _b, props = __objRest5(_b, ["children", "style"]);
    return (0, import_jsx_runtime5.jsx)("td", __spreadProps5(__spreadValues5({}, props), { "data-id": "__react-email-column", ref, style, children }));
  }
);
Column.displayName = "Column";

// node_modules/@react-email/container/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var __defProp6 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp6.call(b3, prop))
      __defNormalProp6(a, prop, b3[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b3)) {
      if (__propIsEnum6.call(b3, prop))
        __defNormalProp6(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b3) => __defProps6(a, __getOwnPropDescs6(b3));
var __objRest6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Container = React6.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style } = _b, props = __objRest6(_b, ["children", "style"]);
    return (0, import_jsx_runtime6.jsx)(
      "table",
      __spreadProps6(__spreadValues6({
        align: "center",
        width: "100%"
      }, props), {
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        ref,
        role: "presentation",
        style: __spreadValues6({ maxWidth: "37.5em" }, style),
        children: (0, import_jsx_runtime6.jsx)("tbody", { children: (0, import_jsx_runtime6.jsx)("tr", { style: { width: "100%" }, children: (0, import_jsx_runtime6.jsx)("td", { children }) }) })
      })
    );
  }
);
Container.displayName = "Container";

// node_modules/@react-email/font/dist/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var Font = ({
  fontFamily,
  fallbackFontFamily,
  webFont,
  fontStyle = "normal",
  fontWeight = 400
}) => {
  const src = webFont ? `src: url(${webFont.url}) format('${webFont.format}');` : "";
  const style = `
    @font-face {
      font-family: '${fontFamily}';
      font-style: ${fontStyle};
      font-weight: ${fontWeight};
      mso-font-alt: '${Array.isArray(fallbackFontFamily) ? fallbackFontFamily[0] : fallbackFontFamily}';
      ${src}
    }

    * {
      font-family: '${fontFamily}', ${Array.isArray(fallbackFontFamily) ? fallbackFontFamily.join(", ") : fallbackFontFamily};
    }
  `;
  return (0, import_jsx_runtime7.jsx)("style", { dangerouslySetInnerHTML: { __html: style } });
};

// node_modules/@react-email/head/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __defProp7 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp7.call(b3, prop))
      __defNormalProp7(a, prop, b3[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b3)) {
      if (__propIsEnum7.call(b3, prop))
        __defNormalProp7(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b3) => __defProps7(a, __getOwnPropDescs7(b3));
var __objRest7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Head = React7.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children } = _b, props = __objRest7(_b, ["children"]);
    return (0, import_jsx_runtime8.jsxs)("head", __spreadProps7(__spreadValues7({}, props), { ref, children: [
      (0, import_jsx_runtime8.jsx)("meta", { content: "text/html; charset=UTF-8", httpEquiv: "Content-Type" }),
      (0, import_jsx_runtime8.jsx)("meta", { name: "x-apple-disable-message-reformatting" }),
      children
    ] }));
  }
);
Head.displayName = "Head";

// node_modules/@react-email/heading/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var __defProp8 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp8.call(b3, prop))
      __defNormalProp8(a, prop, b3[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b3)) {
      if (__propIsEnum8.call(b3, prop))
        __defNormalProp8(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b3) => __defProps8(a, __getOwnPropDescs8(b3));
var __objRest8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var withMargin = (props) => {
  const nonEmptyStyles = [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ].filter((s2) => Object.keys(s2).length);
  const mergedStyles = nonEmptyStyles.reduce((acc, style) => {
    return __spreadValues8(__spreadValues8({}, acc), style);
  }, {});
  return mergedStyles;
};
var withSpace = (value, properties) => {
  return properties.reduce((styles2, property) => {
    if (!isNaN(parseFloat(value))) {
      return __spreadProps8(__spreadValues8({}, styles2), { [property]: `${value}px` });
    }
    return styles2;
  }, {});
};
var Heading = React8.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { as: Tag2 = "h1", children, style, m, mx, my, mt: mt4, mr: mr4, mb, ml: ml2 } = _b, props = __objRest8(_b, ["as", "children", "style", "m", "mx", "my", "mt", "mr", "mb", "ml"]);
    return (0, import_jsx_runtime9.jsx)(
      Tag2,
      __spreadProps8(__spreadValues8({}, props), {
        ref,
        style: __spreadValues8(__spreadValues8({}, withMargin({ m, mx, my, mt: mt4, mr: mr4, mb, ml: ml2 })), style),
        children
      })
    );
  }
);
Heading.displayName = "Heading";

// node_modules/@react-email/hr/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var __defProp9 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp9.call(b3, prop))
      __defNormalProp9(a, prop, b3[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b3)) {
      if (__propIsEnum9.call(b3, prop))
        __defNormalProp9(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b3) => __defProps9(a, __getOwnPropDescs9(b3));
var __objRest9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Hr = React9.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { style } = _b, props = __objRest9(_b, ["style"]);
    return (0, import_jsx_runtime10.jsx)(
      "hr",
      __spreadProps9(__spreadValues9({}, props), {
        ref,
        style: __spreadValues9({
          width: "100%",
          border: "none",
          borderTop: "1px solid #eaeaea"
        }, style)
      })
    );
  }
);
Hr.displayName = "Hr";

// node_modules/@react-email/html/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var __defProp10 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp10.call(b3, prop))
      __defNormalProp10(a, prop, b3[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b3)) {
      if (__propIsEnum10.call(b3, prop))
        __defNormalProp10(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b3) => __defProps10(a, __getOwnPropDescs10(b3));
var __objRest10 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp10.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum10.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Html = React10.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, lang = "en", dir = "ltr" } = _b, props = __objRest10(_b, ["children", "lang", "dir"]);
    return (0, import_jsx_runtime11.jsx)("html", __spreadProps10(__spreadValues10({}, props), { dir, lang, ref, children }));
  }
);
Html.displayName = "Html";

// node_modules/@react-email/img/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var __defProp11 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp11.call(b3, prop))
      __defNormalProp11(a, prop, b3[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b3)) {
      if (__propIsEnum11.call(b3, prop))
        __defNormalProp11(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b3) => __defProps11(a, __getOwnPropDescs11(b3));
var __objRest11 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp11.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum11.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Img = React11.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { alt, src, width, height, style } = _b, props = __objRest11(_b, ["alt", "src", "width", "height", "style"]);
    return (0, import_jsx_runtime12.jsx)(
      "img",
      __spreadProps11(__spreadValues11({}, props), {
        alt,
        height,
        ref,
        src,
        style: __spreadValues11({
          display: "block",
          outline: "none",
          border: "none",
          textDecoration: "none"
        }, style),
        width
      })
    );
  }
);
Img.displayName = "Img";

// node_modules/@react-email/link/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var __defProp12 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp12.call(b3, prop))
      __defNormalProp12(a, prop, b3[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b3)) {
      if (__propIsEnum12.call(b3, prop))
        __defNormalProp12(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps12 = (a, b3) => __defProps12(a, __getOwnPropDescs12(b3));
var __objRest12 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp12.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum12.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Link = React12.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { target = "_blank", style } = _b, props = __objRest12(_b, ["target", "style"]);
    return (0, import_jsx_runtime13.jsx)(
      "a",
      __spreadProps12(__spreadValues12({}, props), {
        ref,
        style: __spreadValues12({
          color: "#067df7",
          textDecorationLine: "none"
        }, style),
        target,
        children: props.children
      })
    );
  }
);
Link.displayName = "Link";

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: false,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: false,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape2(html) {
  return html.replace(unescapeTest, (_3, n2) => {
    n2 = n2.toLowerCase();
    if (n2 === "colon")
      return ":";
    if (n2.charAt(0) === "#") {
      return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = typeof val === "object" && "source" in val ? val.source : val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e2) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e2) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: () => null };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b3) {
  if (str.indexOf(b3[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b3[0]) {
      level++;
    } else if (str[i] === b3[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkDeprecations(opt, callback) {
  if (!opt || opt.silent) {
    return;
  }
  if (callback) {
    console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async");
  }
  if (opt.sanitize || opt.sanitizer) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
  if (opt.highlight || opt.langPrefix !== "language-") {
    console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.");
  }
  if (opt.mangle) {
    console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.");
  }
  if (opt.baseUrl) {
    console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.");
  }
  if (opt.smartypants) {
    console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.");
  }
  if (opt.xhtml) {
    console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.");
  }
  if (opt.headerIds || opt.headerPrefix) {
    console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.");
  }
}
function outputLink(cap, link2, raw, lexer2) {
  const href = link2.href;
  const title = link2.title ? escape(link2.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token2 = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token2;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  constructor(options2) {
    __publicField(this, "options");
    // TODO: Fix this rules type
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t8) => " ".repeat(3 * t8.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      for (let i = 0; i < list.items.length; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t8) => t8.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t8) => /\n.*\n/.test(t8.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (let i = 0; i < list.items.length; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token2 = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        const paragraph = token2;
        paragraph.type = "paragraph";
        paragraph.text = text;
        paragraph.tokens = this.lexer.inline(text);
      }
      return token2;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        raw: cap[0],
        header: splitCells(cap[1]).map((c2) => {
          return { text: c2, tokens: [] };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        let l2 = item.align.length;
        let i, j3, k3, row;
        for (i = 0; i < l2; i++) {
          const align = item.align[i];
          if (align) {
            if (/^ *-+: *$/.test(align)) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(align)) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(align)) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
        }
        l2 = item.rows.length;
        for (i = 0; i < l2; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c2) => {
            return { text: c2, tokens: [] };
          });
        }
        l2 = item.header.length;
        for (j3 = 0; j3 < l2; j3++) {
          item.header[j3].tokens = this.lexer.inline(item.header[j3].text);
        }
        l2 = item.rows.length;
        for (j3 = 0; j3 < l2; j3++) {
          row = item.rows[j3];
          for (k3 = 0; k3 < row.length; k3++) {
            row[k3].tokens = this.lexer.inline(row[k3].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link2 = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link2 = links[link2.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = [...src].slice(0, lLength + match.index + rLength + 1).join("");
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
    rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^((?![*_])[\spunctuation])/
};
inline._punctuation = "\\p{P}$+<=>`^|~";
inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline.anyPunctuation = /\\[punct]/g;
inline._escapes = /\\([punct])/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text) {
  return text.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text) {
  let out = "";
  for (let i = 0; i < text.length; i++) {
    const ch = Math.random() > 0.5 ? "x" + text.charCodeAt(i).toString(16) : text.charCodeAt(i).toString();
    out += "&#" + ch + ";";
  }
  return out;
}
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_3, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token2;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token2 = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.space(src)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.code(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.fences(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.heading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.hr(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.blockquote(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.list(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.html(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.def(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token2.tag]) {
          this.tokens.links[token2.tag] = {
            href: token2.href,
            title: token2.title
          };
        }
        continue;
      }
      if (token2 = this.tokenizer.table(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.lheading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token2 = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token2.raw.length);
        continue;
      }
      if (token2 = this.tokenizer.text(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token2, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token2 = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.escape(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.tag(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.link(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.codespan(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.br(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.del(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (!this.state.inLink && (token2 = this.tokenizer.url(src, mangle))) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token2 = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.slice(-1) !== "_") {
          prevChar = token2.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  code(code, infostring, escaped) {
    var _a5;
    const lang = (_a5 = (infostring || "").match(/^\S*/)) == null ? void 0 : _a5[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html, block2) {
    return html;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>
`;
    }
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text, task, checked) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Slugger = class {
  constructor() {
    __publicField(this, "seen");
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    __publicField(this, "slugger");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer();
    this.slugger = new _Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token2 = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        const genericToken = token2;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token2;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          const codeToken = token2;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token2;
          let header = "";
          let cell = "";
          for (let j3 = 0; j3 < tableToken.header.length; j3++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j3].tokens), { header: true, align: tableToken.align[j3] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j3 = 0; j3 < tableToken.rows.length; j3++) {
            const row = tableToken.rows[j3];
            cell = "";
            for (let k3 = 0; k3 < row.length; k3++) {
              cell += this.renderer.tablecell(this.parseInline(row[k3].tokens), { header: false, align: tableToken.align[k3] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token2;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token2;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j3 = 0; j3 < listToken.items.length; j3++) {
            const item = listToken.items[j3];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token2;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token2;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token2;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token2 = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        const ret = this.options.extensions.renderers[token2.type].call({ parser: this }, token2);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "escape": {
          const escapeToken = token2;
          out += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token2;
          out += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token2;
          out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token2;
          out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token2;
          out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token2;
          out += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token2;
          out += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          const delToken = token2;
          out += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token2;
          out += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
var _Marked_instances, parseMarkdown_fn, onError_fn;
var Marked = class {
  constructor(...args) {
    __privateAdd(this, _Marked_instances);
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
    __publicField(this, "parseInline", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "parser", _Parser.parse);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "lexer", _Lexer.lex);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Slugger", _Slugger);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a5, _b;
    let values = [];
    for (const token2 of tokens) {
      values = values.concat(callback.call(this, token2));
      switch (token2.type) {
        case "table": {
          const tableToken = token2;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token2;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token2;
          if ((_b = (_a5 = this.defaults.extensions) == null ? void 0 : _a5.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(genericToken[childTokens], callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          const rendererFunc = pack.renderer[prop];
          const rendererKey = prop;
          const prevRenderer = renderer[rendererKey];
          renderer[rendererKey] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          const tokenizerFunc = pack.tokenizer[prop];
          const tokenizerKey = prop;
          const prevTokenizer = tokenizer[tokenizerKey];
          tokenizer[tokenizerKey] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          const hooksFunc = pack.hooks[prop];
          const hooksKey = prop;
          const prevHook = hooks[hooksKey];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksKey] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksKey] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token2) {
          let values = [];
          values.push(packWalktokens.call(this, token2));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token2));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
};
_Marked_instances = new WeakSet();
parseMarkdown_fn = function(lexer2, parser2) {
  return (src, optOrCallback, callback) => {
    if (typeof optOrCallback === "function") {
      callback = optOrCallback;
      optOrCallback = null;
    }
    const origOpt = { ...optOrCallback };
    const opt = { ...this.defaults, ...origOpt };
    if (this.defaults.async === true && origOpt.async === false) {
      if (!opt.silent) {
        console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
      }
      opt.async = true;
    }
    const throwError = __privateMethod(this, _Marked_instances, onError_fn).call(this, !!opt.silent, !!opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkDeprecations(opt, callback);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const resultCallback = callback;
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer2(src, opt);
      } catch (e2) {
        return throwError(e2);
      }
      const done = (err) => {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              this.walkTokens(tokens, opt.walkTokens);
            }
            out = parser2(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e2) {
            err = e2;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : resultCallback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      this.walkTokens(tokens, (token2) => {
        if (token2.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token2.text, token2.lang, (err, code) => {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token2.text) {
                token2.text = code;
                token2.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        this.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser2(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e2) {
      return throwError(e2);
    }
  };
};
onError_fn = function(silent, async, callback) {
  return (e2) => {
    e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e2);
    }
    if (callback) {
      callback(e2);
      return;
    }
    throw e2;
  };
};
var markedInstance = new Marked();
function marked(src, opt, callback) {
  return markedInstance.parse(src, opt, callback);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Slugger = _Slugger;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// node_modules/md-to-react-email/dist/index.mjs
var React13 = __toESM(require_react(), 1);
var emptyStyle = {};
var baseHeaderStyles = {
  fontWeight: "500",
  paddingTop: 20
};
var h1 = {
  ...baseHeaderStyles,
  fontSize: "2.5rem"
};
var h2 = {
  ...baseHeaderStyles,
  fontSize: "2rem"
};
var h3 = {
  ...baseHeaderStyles,
  fontSize: "1.75rem"
};
var h4 = {
  ...baseHeaderStyles,
  fontSize: "1.5rem"
};
var h5 = {
  ...baseHeaderStyles,
  fontSize: "1.25rem"
};
var h6 = {
  ...baseHeaderStyles,
  fontSize: "1rem"
};
var bold = {
  fontWeight: "bold"
};
var italic = {
  fontStyle: "italic"
};
var blockQuote = {
  background: "#f9f9f9",
  borderLeft: "10px solid #ccc",
  margin: "1.5em 10px",
  padding: "1em 10px"
};
var codeInline = {
  color: "#212529",
  fontSize: "87.5%",
  display: "inline",
  background: " #f8f8f8",
  fontFamily: `SFMono-Regular,Menlo,Monaco,Consolas,monospace`
};
var codeBlock = {
  ...codeInline,
  paddingTop: 10,
  paddingRight: 10,
  paddingLeft: 10,
  paddingBottom: 1,
  marginBottom: 20,
  background: " #f8f8f8"
};
var link = {
  color: "#007bff",
  textDecoration: "underline",
  backgroundColor: "transparent"
};
var styles = {
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  blockQuote,
  bold,
  italic,
  link,
  codeBlock: { ...codeBlock, wordWrap: "break-word" },
  codeInline: { ...codeInline, wordWrap: "break-word" },
  p: emptyStyle,
  li: emptyStyle,
  ul: emptyStyle,
  ol: emptyStyle,
  image: emptyStyle,
  br: emptyStyle,
  hr: emptyStyle,
  table: emptyStyle,
  thead: emptyStyle,
  tbody: emptyStyle,
  th: emptyStyle,
  td: emptyStyle,
  tr: emptyStyle,
  strikethrough: emptyStyle
};
function escapeQuotes(value) {
  if (typeof value === "string" && value.includes('"')) {
    return value.replace(/"/g, "&#x27;");
  }
  return value;
}
function camelToKebabCase(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function parseCssInJsToInlineCss(cssProperties) {
  if (!cssProperties)
    return "";
  const numericalCssProperties = [
    "width",
    "height",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "borderWidth",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",
    "outlineWidth",
    "top",
    "right",
    "bottom",
    "left",
    "fontSize",
    "lineHeight",
    "letterSpacing",
    "wordSpacing",
    "maxWidth",
    "minWidth",
    "maxHeight",
    "minHeight",
    "borderRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius",
    "textIndent",
    "gridColumnGap",
    "gridRowGap",
    "gridGap",
    "translateX",
    "translateY"
  ];
  return Object.entries(cssProperties).map(([property, value]) => {
    if (typeof value === "number" && numericalCssProperties.includes(property)) {
      return `${camelToKebabCase(property)}:${value}px`;
    } else {
      const escapedValue = escapeQuotes(value);
      return `${camelToKebabCase(property)}:${escapedValue}`;
    }
  }).join(";");
}
var initRenderer = ({
  customStyles
}) => {
  const finalStyles = { ...styles, ...customStyles };
  const customRenderer = new _Renderer();
  customRenderer.blockquote = (quote) => {
    return `<blockquote${parseCssInJsToInlineCss(finalStyles.blockQuote) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.blockQuote)}"` : ""}>
${quote}</blockquote>
`;
  };
  customRenderer.br = () => {
    return `<br${parseCssInJsToInlineCss(finalStyles.br) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.br)}"` : ""} />`;
  };
  customRenderer.code = (code) => {
    code = code.replace(/\n$/, "") + "\n";
    return `<pre${parseCssInJsToInlineCss(finalStyles.codeBlock) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.codeBlock)}"` : ""}><code>${code}</code></pre>
`;
  };
  customRenderer.codespan = (text) => {
    return `<code${parseCssInJsToInlineCss(finalStyles.codeInline) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.codeInline)}"` : ""}>${text}</code>`;
  };
  customRenderer.del = (text) => {
    return `<del${parseCssInJsToInlineCss(finalStyles.strikethrough) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.strikethrough)}"` : ""}>${text}</del>`;
  };
  customRenderer.em = (text) => {
    return `<em${parseCssInJsToInlineCss(finalStyles.italic) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.italic)}"` : ""}>${text}</em>`;
  };
  customRenderer.heading = (text, level) => {
    return `<h${level}${parseCssInJsToInlineCss(
      finalStyles[`h${level}`]
    ) !== "" ? ` style="${parseCssInJsToInlineCss(
      finalStyles[`h${level}`]
    )}"` : ""}>${text}</h${level}>`;
  };
  customRenderer.hr = () => {
    return `<hr${parseCssInJsToInlineCss(finalStyles.hr) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.hr)}"` : ""} />
`;
  };
  customRenderer.image = (href, _3, text) => {
    return `<img src="${href}" alt="${text}"${parseCssInJsToInlineCss(finalStyles.image) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.image)}"` : ""}>`;
  };
  customRenderer.link = (href, _3, text) => {
    return `<a href="${href}" target="_blank"${parseCssInJsToInlineCss(finalStyles.link) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.link)}"` : ""}>${text}</a>`;
  };
  customRenderer.list = (body, ordered, start) => {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    const styles2 = parseCssInJsToInlineCss(
      finalStyles[ordered ? "ol" : "ul"]
    );
    return "<" + type + startatt + `${styles2 !== "" ? ` style="${styles2}"` : ""}>
` + body + "</" + type + ">\n";
  };
  customRenderer.listitem = (text) => {
    return `<li${parseCssInJsToInlineCss(finalStyles.li) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.li)}"` : ""}>${text}</li>
`;
  };
  customRenderer.paragraph = (text) => {
    return `<p${parseCssInJsToInlineCss(finalStyles.p) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.p)}"` : ""}>${text}</p>
`;
  };
  customRenderer.strong = (text) => {
    return `<strong${parseCssInJsToInlineCss(finalStyles.bold) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.bold)}"` : ""}>${text}</strong>`;
  };
  customRenderer.table = (header, body) => {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return `<table${parseCssInJsToInlineCss(finalStyles.table) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.table)}"` : ""}>
<thead${parseCssInJsToInlineCss(finalStyles.thead) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.thead)}"` : ""}>
${header}</thead>
${body}</table>
`;
  };
  customRenderer.tablecell = (content, flags) => {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}"${parseCssInJsToInlineCss(finalStyles.td) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.td)}"` : ""}>` : `<${type}${parseCssInJsToInlineCss(finalStyles.td) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.td)}"` : ""}>`;
    return tag + content + `</${type}>
`;
  };
  customRenderer.tablerow = (content) => {
    return `<tr${parseCssInJsToInlineCss(finalStyles.tr) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.tr)}"` : ""}>
${content}</tr>
`;
  };
  return customRenderer;
};
var MarkdownParser = class {
  constructor({ customStyles }) {
    __publicField(this, "renderer");
    this.renderer = initRenderer({ customStyles });
  }
  parse(markdown) {
    return marked.parse(markdown, { renderer: this.renderer });
  }
};
var parseMarkdownToJSX = ({
  markdown,
  customStyles
}) => {
  const parser2 = new MarkdownParser({ customStyles });
  return parser2.parse(markdown);
};

// node_modules/@react-email/markdown/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var __defProp13 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues13 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp13.call(b3, prop))
      __defNormalProp13(a, prop, b3[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b3)) {
      if (__propIsEnum13.call(b3, prop))
        __defNormalProp13(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps13 = (a, b3) => __defProps13(a, __getOwnPropDescs13(b3));
var __objRest13 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp13.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum13.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Markdown = React14.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, markdownContainerStyles, markdownCustomStyles } = _b, props = __objRest13(_b, ["children", "markdownContainerStyles", "markdownCustomStyles"]);
    const parsedMarkdown = parseMarkdownToJSX({
      markdown: children,
      customStyles: markdownCustomStyles
    });
    return (0, import_jsx_runtime14.jsx)(
      "div",
      __spreadProps13(__spreadValues13({}, props), {
        dangerouslySetInnerHTML: { __html: parsedMarkdown },
        "data-id": "react-email-markdown",
        ref,
        style: markdownContainerStyles
      })
    );
  }
);
Markdown.displayName = "Markdown";

// node_modules/@react-email/preview/dist/index.mjs
var React15 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var __defProp14 = Object.defineProperty;
var __defProps14 = Object.defineProperties;
var __getOwnPropDescs14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols14 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues14 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp14.call(b3, prop))
      __defNormalProp14(a, prop, b3[prop]);
  if (__getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(b3)) {
      if (__propIsEnum14.call(b3, prop))
        __defNormalProp14(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps14 = (a, b3) => __defProps14(a, __getOwnPropDescs14(b3));
var __objRest14 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp14.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum14.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var PREVIEW_MAX_LENGTH = 150;
var Preview = React15.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children = "" } = _b, props = __objRest14(_b, ["children"]);
    const text = (Array.isArray(children) ? children.join("") : children).substring(0, PREVIEW_MAX_LENGTH);
    return (0, import_jsx_runtime15.jsxs)(
      "div",
      __spreadProps14(__spreadValues14({
        style: {
          display: "none",
          overflow: "hidden",
          lineHeight: "1px",
          opacity: 0,
          maxHeight: 0,
          maxWidth: 0
        },
        "data-skip-in-text": true
      }, props), {
        ref,
        children: [
          text,
          renderWhiteSpace(text)
        ]
      })
    );
  }
);
Preview.displayName = "Preview";
var whiteSpaceCodes = " ‌​‍‎‏\uFEFF";
var renderWhiteSpace = (text) => {
  if (text.length >= PREVIEW_MAX_LENGTH) {
    return null;
  }
  return (0, import_jsx_runtime15.jsx)("div", { children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text.length) });
};

// node_modules/domelementtype/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name2, data) {
    super(data);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a5;
    return (_a5 = this.children[0]) !== null && _a5 !== void 0 ? _a5 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element2 = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children = [], type = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a5, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a5 = this["x-attribsNamespace"]) === null || _a5 === void 0 ? void 0 : _a5[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element2(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options2, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options2 === "function") {
      elementCB = options2;
      options2 = defaultOpts;
    }
    if (typeof callback === "object") {
      options2 = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser2) {
    this.parser = parser2;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element2(name2, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data) {
    const node = new ProcessingInstruction(name2, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/leac/lib/leac.mjs
var e = /\n/g;
function n(n2) {
  const o2 = [...n2.matchAll(e)].map((e2) => e2.index || 0);
  o2.unshift(-1);
  const s2 = t(o2, 0, o2.length);
  return (e2) => r(s2, e2);
}
function t(e2, n2, r2) {
  if (r2 - n2 == 1) return { offset: e2[n2], index: n2 + 1 };
  const o2 = Math.ceil((n2 + r2) / 2), s2 = t(e2, n2, o2), l2 = t(e2, o2, r2);
  return { offset: s2.offset, low: s2, high: l2 };
}
function r(e2, n2) {
  return function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  }(e2) ? { line: e2.index, column: n2 - e2.offset } : r(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t8 = "", r2 = {}) {
  const o2 = "string" != typeof t8 ? t8 : r2, l2 = "string" == typeof t8 ? t8 : "", c2 = e2.map(s), f = !!o2.lineNumbers;
  return function(e3, t9 = 0) {
    const r3 = f ? n(e3) : () => ({ line: 0, column: 0 });
    let o3 = t9;
    const s2 = [];
    e: for (; o3 < e3.length; ) {
      let n2 = false;
      for (const t10 of c2) {
        t10.regex.lastIndex = o3;
        const c3 = t10.regex.exec(e3);
        if (c3 && c3[0].length > 0) {
          if (!t10.discard) {
            const e4 = r3(o3), n3 = "string" == typeof t10.replace ? c3[0].replace(new RegExp(t10.regex.source, t10.regex.flags), t10.replace) : c3[0];
            s2.push({ state: l2, name: t10.name, text: n3, offset: o3, len: c3[0].length, line: e4.line, column: e4.column });
          }
          if (o3 = t10.regex.lastIndex, n2 = true, t10.push) {
            const n3 = t10.push(e3, o3);
            s2.push(...n3.tokens), o3 = n3.offset;
          }
          if (t10.pop) break e;
          break;
        }
      }
      if (!n2) break;
    }
    return { tokens: s2, offset: o3, complete: e3.length <= o3 };
  };
}
function s(e2, n2) {
  return { ...e2, regex: l(e2, n2) };
}
function l(e2, n2) {
  if (0 === e2.name.length) throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  }(e2)) return function(e3) {
    if (e3.global) throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
    return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
  }(e2.regex);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  }(e2)) {
    if (0 === e2.str.length) throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}

// node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = void 0;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== void 0) {
        position++;
      }
    } else {
      onEnd == null ? void 0 : onEnd(data, i);
    }
    return value === void 0 ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v3, j3) => mapper(v3, data, i, j3));
}
function option(p, def) {
  return (data, i) => {
    const r2 = p(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps3) {
  return (data, i) => {
    for (const p of ps3) {
      const result = p(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa3, pb) {
  return (data, i) => {
    const r1 = pa3(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r2 = p(data, i);
      if (r2.matched && test(r2.value, values.length + 1, data, i, r2.position)) {
        values.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa3, pb, join) {
  return (data, i) => mapOuter(pa3(data, i), (ma3) => mapInner(pb(data, ma3.position), (vb, j3) => join(ma3.value, vb, data, i, j3)));
}
function left(pa3, pb) {
  return ab(pa3, pb, (va3) => va3);
}
function right(pa3, pb) {
  return ab(pa3, pb, (va3, vb) => vb);
}
function abc(pa3, pb, pc2, join) {
  return (data, i) => mapOuter(pa3(data, i), (ma3) => mapOuter(pb(data, ma3.position), (mb) => mapInner(pc2(data, mb.position), (vc2, j3) => join(ma3.value, mb.value, vc2, data, i, j3))));
}
function middle(pa3, pb, pc2) {
  return abc(pa3, pb, pc2, (ra3, rb) => rb);
}
function all(...ps3) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p of ps3) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps3) {
  return flatten1(all(...ps3));
}
function flatten1(p) {
  return map(p, (vs4) => vs4.flatMap((v3) => v3));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v3, data, i, j3) => reducer(acc2, v3, data, i, j3)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y2) => [f, y2]), (acc, [f, y2]) => f(acc, y2)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}

// node_modules/parseley/lib/parseley.mjs
var ast = Object.freeze({
  __proto__: null
});
var ws = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
var name = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
var string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
var lexSelector = o([
  { name: "ws", regex: new RegExp(ws) },
  { name: "hash", regex: new RegExp(`#${name}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string2, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape2, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
function sumSpec([a0, a1, a2], [b0, b1, b22]) {
  return [a0 + b0, a1 + b1, a2 + b22];
}
function sumAllSpec(ss3) {
  return ss3.reduce(sumSpec, [0, 0, 0]);
}
var unicodeEscapedSequence_ = token((t8) => t8.name === "unicode" ? String.fromCodePoint(parseInt(t8.text.slice(1), 16)) : void 0);
var escapedSequence_ = token((t8) => t8.name === "escape" ? t8.text.slice(1) : void 0);
var anyChar_ = token((t8) => t8.name === "any" ? t8.text : void 0);
var escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs3) => cs3.join(""));
function unescape3(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: void 0 }, 0);
  return result.value;
}
function literal(name2) {
  return token((t8) => t8.name === name2 ? true : void 0);
}
var whitespace_ = token((t8) => t8.name === "ws" ? null : void 0);
var optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser2) {
  return middle(optionalWhitespace_, parser2, optionalWhitespace_);
}
var identifier_ = token((t8) => t8.name === "ident" ? unescape3(t8.text) : void 0);
var hashId_ = token((t8) => t8.name === "hash" ? unescape3(t8.text.slice(1)) : void 0);
var string_ = token((t8) => t8.name.startsWith("str") ? unescape3(t8.text.slice(1, -1)) : void 0);
var namespace_ = left(option(identifier_, ""), literal("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns3, name2) => ({ name: name2, namespace: ns3 })), map(identifier_, (name2) => ({ name: name2, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns3) => ({ type: "universal", namespace: ns3, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
var idSelector_ = map(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t8) => {
  if (t8.name === "ident") {
    if (t8.text === "i" || t8.text === "I") {
      return "i";
    }
    if (t8.text === "s" || t8.text === "S") {
      return "s";
    }
  }
  return void 0;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })));
var attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
var attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss3) => {
  return {
    type: "compound",
    list: ss3,
    specificity: sumAllSpec(ss3.map((s2) => s2.specificity))
  };
});
var combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c2) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map(complexSelector_, (s2) => ({ type: "list", list: [s2] })), map(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
function parse_(parser2, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser2)({ tokens: lexerResult.tokens, options: void 0 }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t8, r2) => t8 ? "␉" : r2 ? "␍" : "␊")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node) => {
        if (node.type === "combinator") {
          return serialize(node) + acc;
        } else {
          return acc + serialize(node);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns3) {
  return ns3 || ns3 === "" ? _serIdent(ns3) + "|" : "";
}
function _codePoint(char) {
  return `\\${char.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(
    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g,
    (m, d1, d2, hy, safe, nl3, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl3 ? "�" : ctrl ? _codePoint(ctrl) : "\\" + other
  );
}
function _serStr(str) {
  return str.replace(
    /(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g,
    (m, dq, bs3, nl3, ctrl) => dq ? '\\"' : bs3 ? "\\\\" : nl3 ? "�" : _codePoint(ctrl)
  );
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b3) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b3)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b3) => serialize(a) < serialize(b3) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b3) {
  return _compareArrays(a, b3);
}
function _compareArrays(a, b3) {
  if (!Array.isArray(a) || !Array.isArray(b3)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b3.length ? a.length : b3.length;
  for (let i = 0; i < shorter; i++) {
    if (a[i] === b3[i]) {
      continue;
    }
    return a[i] < b3[i] ? -1 : 1;
  }
  return a.length - b3.length;
}

// node_modules/selderee/lib/selderee.mjs
var Ast = Object.freeze({
  __proto__: null
});
var Types = Object.freeze({
  __proto__: null
});
var treeify = (nodes) => "▽\n" + treeifyArray(nodes, thinLines);
var thinLines = [["├─", "│ "], ["└─", "  "]];
var heavyLines = [["┠─", "┃ "], ["┖─", "  "]];
var doubleLines = [["╟─", "║ "], ["╙─", "  "]];
function treeifyArray(nodes, tpl = heavyLines) {
  return prefixItems(tpl, nodes.map((n2) => treeifyNode(n2)));
}
function treeifyNode(node) {
  switch (node.type) {
    case "terminal": {
      const vctr = node.valueContainer;
      return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
    }
    case "tagName":
      return `◻ Tag name
${treeifyArray(node.variants, doubleLines)}`;
    case "attrValue":
      return `▣ Attr value: ${node.name}
${treeifyArray(node.matchers, doubleLines)}`;
    case "attrPresence":
      return `◨ Attr presence: ${node.name}
${treeifyArray(node.cont)}`;
    case "pushElement":
      return `◉ Push element: ${node.combinator}
${treeifyArray(node.cont, thinLines)}`;
    case "popElement":
      return `◌ Pop element
${treeifyArray(node.cont, thinLines)}`;
    case "variant":
      return `◇ = ${node.value}
${treeifyArray(node.cont)}`;
    case "matcher":
      return `◈ ${node.matcher} "${node.value}"${node.modifier || ""}
${treeifyArray(node.cont)}`;
  }
}
function prefixItems(tpl, items) {
  return items.map((item, i, { length }) => prefixItem(tpl, item, i === length - 1)).join("\n");
}
function prefixItem(tpl, item, tail = true) {
  const tpl1 = tpl[tail ? 1 : 0];
  return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
}
var TreeifyBuilder = Object.freeze({
  __proto__: null,
  treeify
});
var DecisionTree = class {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
};
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0; i < len; i++) {
    const [selectorString, val] = array[i];
    const ast2 = preprocess(parse1(selectorString));
    results[i] = {
      ast: ast2,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast2.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast2) {
  reduceSelectorVariants(ast2);
  normalize(ast2);
  return ast2;
}
function reduceSelectorVariants(ast2) {
  const newList = [];
  ast2.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast2.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
      matches.forEach((node) => results.push(node));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length; i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
var Picker = class {
  constructor(f) {
    this.f = f;
  }
  pickAll(el2) {
    return this.f(el2);
  }
  pick1(el2, preferFirst = false) {
    const results = this.f(el2);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1; i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
};
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el2, ...tail) => matchers.flatMap((m) => m(el2, ...tail));
}
function handleNode(node) {
  switch (node.type) {
    case "terminal": {
      const result = [node.valueContainer];
      return (el2, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node);
    case "attrValue":
      return handleAttrValueName(node);
    case "attrPresence":
      return handleAttrPresenceName(node);
    case "pushElement":
      return handlePushElementNode(node);
    case "popElement":
      return handlePopElementNode(node);
  }
}
function handleTagName(node) {
  const variants = {};
  for (const variant of node.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el2, ...tail) => {
    const continuation = variants[el2.name];
    return continuation ? continuation(el2, ...tail) : [];
  };
}
function handleAttrPresenceName(node) {
  const attrName = node.name;
  const continuation = handleArray(node.cont);
  return (el2, ...tail) => Object.prototype.hasOwnProperty.call(el2.attribs, attrName) ? continuation(el2, ...tail) : [];
}
function handleAttrValueName(node) {
  const callbacks = [];
  for (const matcher of node.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el2, ...tail) => predicate(attr) ? continuation(el2, ...tail) : []);
  }
  const attrName = node.name;
  return (el2, ...tail) => {
    const attr = el2.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb2) => cb2(attr, el2, ...tail)) : [];
  };
}
function handlePushElementNode(node) {
  const continuation = handleArray(node.cont);
  const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el2, ...tail) => {
    const next = leftElementGetter(el2);
    if (next === null) {
      return [];
    }
    return continuation(next, el2, ...tail);
  };
}
var getPrecedingElement = (el2) => {
  const prev = el2.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el2) => {
  const parent = el2.parent;
  return parent && isTag2(parent) ? parent : null;
};
function handlePopElementNode(node) {
  const continuation = handleArray(node.cont);
  return (el2, next, ...tail) => continuation(next, ...tail);
}

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c2) => c2.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c2) => c2.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a2;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a5;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a5 = decodeMap.get(codePoint)) !== null && _a5 !== void 0 ? _a5 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a5;
    if (this.consumed <= expectedLength) {
      (_a5 = this.errors) === null || _a5 === void 0 ? void 0 : _a5.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a5;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a5 = this.errors) === null || _a5 === void 0 ? void 0 : _a5.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a5;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a5 = this.errors) === null || _a5 === void 0 ? void 0 : _a5.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder2 = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder2.startEntity(decodeMode);
      const len = decoder2.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder2.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo4 = nodeIdx;
  let hi3 = lo4 + branchCount - 1;
  while (lo4 <= hi3) {
    const mid = lo4 + hi3 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo4 = mid + 1;
    } else if (midVal > char) {
      hi3 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isNumber2(c2) {
  return c2 >= CharCodes2.Zero && c2 <= CharCodes2.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperF || c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c2)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c2 | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {
    } else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options2 = {}) {
    var _a5, _b, _c, _d, _e3;
    this.options = options2;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a5 = options2.lowerCaseTags) !== null && _a5 !== void 0 ? _a5 : !options2.xmlMode;
    this.lowerCaseAttributeNames = (_b = options2.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options2.xmlMode;
    this.tokenizer = new ((_c = options2.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    (_e3 = (_d = this.cbs).onparserinit) === null || _e3 === void 0 ? void 0 : _e3.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a5, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a5 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a5, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a5, _b;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a5 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a5, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a5, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a5 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a5, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a5, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a5 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a5, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a5, _b, _c, _d, _e3, _f2;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a5 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a5, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f2 = (_e3 = this.cbs).onclosetag) === null || _f2 === void 0 ? void 0 : _f2.call(_e3, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a5, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a5 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a5, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a5, _b;
    this.endIndex = endIndex;
    (_b = (_a5 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a5, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name2 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a5, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a5 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a5, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a5, _b, _c, _d, _e3, _f2, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a5 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a5);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f2 = (_e3 = this.cbs).oncdataend) === null || _f2 === void 0 ? void 0 : _f2.call(_e3);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a5, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b = (_a5 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a5);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a5, _b, _c, _d;
    (_b = (_a5 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a5);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a5, _b;
    if (this.ended) {
      (_b = (_a5 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a5, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a5, _b;
    if (this.ended) {
      (_b = (_a5 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a5, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByClassName: () => getElementsByClassName,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape4(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a5;
  if (!attributes)
    return;
  const encode = ((_a5 = opts.encodeEntities) !== null && _a5 !== void 0 ? _a5 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a6, _b;
    const value = (_a6 = attributes[key]) !== null && _a6 !== void 0 ? _a6 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options2 = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options2);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options2) {
  switch (node.type) {
    case Root:
      return render(node.children, options2);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options2);
    case Text:
      return renderText(node, options2);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a5;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a5 = elementNames.get(elem.name)) !== null && _a5 !== void 0 ? _a5 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a5;
  let data = elem.data || "";
  if (((_a5 = opts.encodeEntities) !== null && _a5 !== void 0 ? _a5 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options2) {
  return esm_default(node, options2);
}
function getInnerHTML(node, options2) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options2)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue(elem, name2) {
  var _a5;
  return (_a5 = elem.attribs) === null || _a5 === void 0 ? void 0 : _a5[name2];
}
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}

// node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

// node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i = 0; i < searchedNodes.length; i++) {
    const node = searchedNodes[i];
    if (isTag2(node) && test(node)) {
      return node;
    }
    if (recurse && hasChildren(node) && node.children.length > 0) {
      const found = findOne(test, node.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne(test, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => isTag2(node) && test(node) || hasChildren(node) && existsOne(test, node.children));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag2(elem) && test(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag2(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name2;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b3) {
  return (elem) => a(elem) || b3(elem);
}
function compileTest(options2) {
  const funcs = Object.keys(options2).map((key) => {
    const value = options2[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options2, node) {
  const test = compileTest(options2);
  return test ? test(node) : true;
}
function getElements(options2, nodes, recurse, limit = Infinity) {
  const test = compileTest(options2);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}

// node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b3) => {
    const relative = compareDocumentPosition(a, b3);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a5;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a6;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a6 = getOneElement("link", children)) === null || _a6 === void 0 ? void 0 : _a6.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a5 = getOneElement("link", childs)) === null || _a5 === void 0 ? void 0 : _a5.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a5, _b;
  const childs = (_b = (_a5 = getOneElement("channel", feedRoot.children)) === null || _a5 === void 0 ? void 0 : _a5.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options2) {
  const handler = new DomHandler(void 0, options2);
  new Parser(handler, options2).end(data);
  return handler.root;
}

// node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs(), 1);
function limitedDepthRecursive(n2, f, g2 = () => void 0) {
  if (n2 === void 0) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g2), ...args);
    };
  }
  return g2;
}
function trimCharacter(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = items.length; i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(
      key,
      map2.has(key) ? (0, import_deepmerge.default)(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item
    );
  }
  return [...map2.values()].reverse();
}
var overwriteMerge$1 = (acc, src, options2) => [...src];
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return void 0;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
var I = ["I", "X", "C", "M"];
var V = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v3, i) => v3 % 5 < 4 ? (v3 < 5 ? "" : V[i]) + I[i].repeat(v3 % 5) : I[i] + (v3 < 5 ? V[i] : I[i + 1])).reverse().join("");
}
var InlineTextBuilder = class {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor(options2, maxLineLength = void 0) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options2.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options2, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options2, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== void 0) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
};
var StackItem = class {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
};
var BlockStackItem = class extends StackItem {
  constructor(options2, next = null, leadingLineBreaks = 1, maxLineLength = void 0) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options2, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var ListStackItem = class extends BlockStackItem {
  constructor(options2, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = void 0,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options2, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
};
var ListItemStackItem = class extends BlockStackItem {
  constructor(options2, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = void 0,
    prefix = ""
  } = {}) {
    super(options2, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
};
var TableStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableRowStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableCellStackItem = class extends StackItem {
  constructor(options2, next = null, maxColumnWidth = void 0) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options2, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TransformerStackItem = class extends StackItem {
  constructor(next = null, transform) {
    super(next);
    this.transform = transform;
  }
};
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
var WhitespaceProcessor = class {
  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor(options2) {
    this.whitespaceChars = options2.preserveNewlines ? options2.whitespaceCharacters.replace(/\n/g, "") : options2.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options2.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    }
  }
  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral(text, inlineTextBuilder, noWrap = true) {
    if (!text) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace(text) {
    return this.leadingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace(text) {
    return this.trailingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords(text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }
  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords(text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
};
var BlockTextBuilder = class {
  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor(options2, picker, metadata = void 0) {
    this.options = options2;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options2);
    this._stackItem = new BlockStackItem(options2);
    this._wordTransformer = void 0;
  }
  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform() {
    if (!this._wordTransformer) {
      return void 0;
    }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }
  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer() {
    const wt4 = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : void 0;
    const ce3 = this.options.encodeCharacters;
    return wt4 ? ce3 ? (str) => ce3(wt4(str)) : wt4 : ce3;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  /**
   * Add a line break into currently built block.
   */
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || // empty string
    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
    !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      noWordTransform ? void 0 : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
    const block2 = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText2(block2)) : getText2(block2);
    addText(this._stackItem, blockText, block2.leadingLineBreaks, Math.max(block2.stashedLineBreaks, trailingLineBreaks));
  }
  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText2(listItem).replace(/\n/g, spacing);
    addText(
      list,
      text,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }
  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText2(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Start building a table.
   */
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  /**
   * Start building a table row.
   */
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell({ maxColumnWidth = void 0 } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText2(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text });
  }
  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString2(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString() {
    return getText2(this._stackItem.getRoot());
  }
};
function getText2(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText2(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options2 = {}) {
  const selectorsWithoutFormat = options2.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      "Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", ")
    );
  }
  const picker = new DecisionTree(
    options2.selectors.map((s2) => [s2.selector, s2])
  ).build(hp2Builder);
  if (typeof options2.encodeCharacters !== "function") {
    options2.encodeCharacters = makeReplacerFromDict(options2.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(
    options2.baseElements.selectors.map((s2, i) => [s2, i + 1])
  ).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options2, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(
    options2.limits.maxDepth,
    recursiveWalk,
    function(dom, builder) {
      builder.addInline(options2.limits.ellipsis || "");
    }
  );
  return function(html, metadata = void 0) {
    return process2(html, metadata, options2, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options2, picker, findBaseElements, walk) {
  const maxInputLength = options2.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(
      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html, { decodeEntities: options2.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options2, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options2, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk2(walk, dom2) {
    dom2 = dom2.slice(0, options2.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options2.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(
    options2.limits.maxDepth,
    recursiveWalk2
  );
  limitedWalk(dom);
  if (options2.baseElements.orderBy !== "occurrence") {
    results.sort((a, b3) => a.selectorIndex - b3.selectorIndex);
  }
  return options2.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options2 = builder.options;
  const tooManyChildNodes = dom.length > options2.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options2.limits.maxChildNodes);
    dom.push({
      data: options2.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options2.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return void 0;
  }
  const entries = Object.entries(dict).filter(([, v3]) => v3 !== false);
  const regex = new RegExp(
    entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"),
    "g"
  );
  const values = entries.map(([, v3]) => v3);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k3, v3]) => v3 === "" ? k3 : `${k3}=${v3.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j3) {
  if (!matrix[j3]) {
    matrix[j3] = [];
  }
  return matrix[j3];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j3 = 0; j3 < i; j3++) {
      const rowJ = getRow(matrix, j3);
      if (rowI[j3] || rowJ[i]) {
        const temp = rowI[j3];
        rowI[j3] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r2 = 0; r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c2 = 0; c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index) {
  if (offsets[index] === void 0) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(
    getOrInitOffset(offsets, base + span),
    getOrInitOffset(offsets, base) + value
  );
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j3 = 0; j3 < rowNumber; j3++) {
    const layoutRow = getRow(layout, j3);
    const cells = tableRows[j3];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j3, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j3, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0; x < colNumber; x++) {
    let y2 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y2 < rowsInThisColumn) {
      cell = layout[x][y2];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j3 = 0; j3 < cell.lines.length; j3++) {
            const line = cell.lines[j3];
            const lineOffset = rowOffsets[y2] + j3;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y2 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y2];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y2++;
      }
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = "";
    builder.pushWordTransform(
      (str) => {
        if (str) {
          text += str;
        }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(
        !text ? href : " " + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: void 0,
    maxChildNodes: void 0,
    maxDepth: void 0,
    maxInputLength: 1 << 24
    // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  // deprecated
  whitespaceCharacters: " 	\r\n\f​",
  wordwrap: 80
};
var concatMerge = (acc, src, options2) => [...acc, ...src];
var overwriteMerge = (acc, src, options2) => [...src];
var selectorsMerge = (acc, src, options2) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options2 = {}) {
  options2 = (0, import_deepmerge.default)(
    DEFAULT_OPTIONS,
    options2,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => key === "selectors" ? selectorsMerge : void 0
    }
  );
  options2.formatters = Object.assign({}, genericFormatters, textFormatters, options2.formatters);
  options2.selectors = mergeDuplicatesPreferLast(options2.selectors, (s2) => s2.selector);
  handleDeprecatedOptions(options2);
  return compile$1(options2);
}
function convert(html, options2 = {}, metadata = void 0) {
  return compile(options2)(html, metadata);
}
function handleDeprecatedOptions(options2) {
  if (options2.tags) {
    const tagDefinitions = Object.entries(options2.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || "*" })
    );
    options2.selectors.push(...tagDefinitions);
    options2.selectors = mergeDuplicatesPreferLast(options2.selectors, (s2) => s2.selector);
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options2["baseElement"]) {
    const baseElement = options2["baseElement"];
    set(
      options2,
      ["baseElements", "selectors"],
      Array.isArray(baseElement) ? baseElement : [baseElement]
    );
  }
  if (options2["returnDomByDefault"] !== void 0) {
    set(options2, ["baseElements", "returnDomByDefault"], options2["returnDomByDefault"]);
  }
  for (const definition of options2.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}

// node_modules/@react-email/components/node_modules/@react-email/render/dist/browser/index.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/prettier/plugins/html.mjs
var html_exports = {};
__export(html_exports, {
  default: () => ym,
  languages: () => Hs,
  options: () => Us,
  parsers: () => tn,
  printers: () => uu
});
var on = Object.defineProperty;
var un = (t8) => {
  throw TypeError(t8);
};
var Ai = (t8, e2, r2) => e2 in t8 ? on(t8, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t8[e2] = r2;
var ln = (t8, e2) => {
  for (var r2 in e2) on(t8, r2, { get: e2[r2], enumerable: true });
};
var lr = (t8, e2, r2) => Ai(t8, typeof e2 != "symbol" ? e2 + "" : e2, r2);
var cn = (t8, e2, r2) => e2.has(t8) || un("Cannot " + r2);
var R = (t8, e2, r2) => (cn(t8, e2, "read from private field"), r2 ? r2.call(t8) : e2.get(t8));
var At = (t8, e2, r2) => e2.has(t8) ? un("Cannot add the same private member more than once") : e2 instanceof WeakSet ? e2.add(t8) : e2.set(t8, r2);
var pn = (t8, e2, r2, n2) => (cn(t8, e2, "write to private field"), n2 ? n2.call(t8, r2) : e2.set(t8, r2), r2);
var rn = {};
ln(rn, { languages: () => Hs, options: () => Us, parsers: () => tn, printers: () => uu });
var Di = (t8, e2, r2, n2) => {
  if (!(t8 && e2 == null)) return e2.replaceAll ? e2.replaceAll(r2, n2) : r2.global ? e2.replace(r2, n2) : e2.split(r2).join(n2);
};
var w = Di;
var we = "string";
var ze = "array";
var Ye = "cursor";
var be = "indent";
var Te = "align";
var je = "trim";
var xe = "group";
var ke = "fill";
var ce = "if-break";
var Be = "indent-if-break";
var Ke = "line-suffix";
var Xe = "line-suffix-boundary";
var j = "line";
var Qe = "label";
var Le = "break-parent";
var Dt = /* @__PURE__ */ new Set([Ye, be, Te, je, xe, ke, ce, Be, Ke, Xe, j, Qe, Le]);
var vi = (t8, e2, r2) => {
  if (!(t8 && e2 == null)) return Array.isArray(e2) || typeof e2 == "string" ? e2[r2 < 0 ? e2.length + r2 : r2] : e2.at(r2);
};
var K = vi;
function yi(t8) {
  if (typeof t8 == "string") return we;
  if (Array.isArray(t8)) return ze;
  if (!t8) return;
  let { type: e2 } = t8;
  if (Dt.has(e2)) return e2;
}
var Fe = yi;
var wi = (t8) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t8);
function bi(t8) {
  let e2 = t8 === null ? "null" : typeof t8;
  if (e2 !== "string" && e2 !== "object") return `Unexpected doc '${e2}', 
Expected it to be 'string' or 'object'.`;
  if (Fe(t8)) throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(t8);
  if (r2 !== "[object Object]") return `Unexpected doc '${r2}'.`;
  let n2 = wi([...Dt].map((s2) => `'${s2}'`));
  return `Unexpected doc.type '${t8.type}'.
Expected it to be ${n2}.`;
}
var cr = class extends Error {
  constructor(e2) {
    super(bi(e2));
    __publicField(this, "name", "InvalidDocError");
    this.doc = e2;
  }
};
var pr = cr;
function hr(t8, e2) {
  if (typeof t8 == "string") return e2(t8);
  let r2 = /* @__PURE__ */ new Map();
  return n2(t8);
  function n2(i) {
    if (r2.has(i)) return r2.get(i);
    let a = s2(i);
    return r2.set(i, a), a;
  }
  function s2(i) {
    switch (Fe(i)) {
      case ze:
        return e2(i.map(n2));
      case ke:
        return e2({ ...i, parts: i.parts.map(n2) });
      case ce:
        return e2({ ...i, breakContents: n2(i.breakContents), flatContents: n2(i.flatContents) });
      case xe: {
        let { expandedStates: a, contents: o2 } = i;
        return a ? (a = a.map(n2), o2 = a[0]) : o2 = n2(o2), e2({ ...i, contents: o2, expandedStates: a });
      }
      case Te:
      case be:
      case Be:
      case Qe:
      case Ke:
        return e2({ ...i, contents: n2(i.contents) });
      case we:
      case Ye:
      case je:
      case Xe:
      case j:
      case Le:
        return e2(i);
      default:
        throw new pr(i);
    }
  }
}
function B(t8, e2 = hn) {
  return hr(t8, (r2) => typeof r2 == "string" ? H(e2, r2.split(`
`)) : r2);
}
var mr = () => {
};
var re = mr;
var fr = mr;
var mn = mr;
function k(t8) {
  return re(t8), { type: be, contents: t8 };
}
function fn(t8, e2) {
  return re(e2), { type: Te, contents: e2, n: t8 };
}
function E(t8, e2 = {}) {
  return re(t8), fr(e2.expandedStates, true), { type: xe, id: e2.id, contents: t8, break: !!e2.shouldBreak, expandedStates: e2.expandedStates };
}
function dn(t8) {
  return fn(Number.NEGATIVE_INFINITY, t8);
}
function gn(t8) {
  return fn({ type: "root" }, t8);
}
function vt(t8) {
  return mn(t8), { type: ke, parts: t8 };
}
function pe(t8, e2 = "", r2 = {}) {
  return re(t8), e2 !== "" && re(e2), { type: ce, breakContents: t8, flatContents: e2, groupId: r2.groupId };
}
function Cn(t8, e2) {
  return re(t8), { type: Be, contents: t8, groupId: e2.groupId, negate: e2.negate };
}
var ne = { type: Le };
var xi = { type: j, hard: true };
var ki = { type: j, hard: true, literal: true };
var _ = { type: j };
var v = { type: j, soft: true };
var S = [xi, ne];
var hn = [ki, ne];
function H(t8, e2) {
  re(t8), fr(e2);
  let r2 = [];
  for (let n2 = 0; n2 < e2.length; n2++) n2 !== 0 && r2.push(t8), r2.push(e2[n2]);
  return r2;
}
var yt = "'";
var Sn = '"';
function Bi(t8, e2) {
  let r2 = e2 === true || e2 === yt ? yt : Sn, n2 = r2 === yt ? Sn : yt, s2 = 0, i = 0;
  for (let a of t8) a === r2 ? s2++ : a === n2 && i++;
  return s2 > i ? n2 : r2;
}
var _n = Bi;
function dr(t8) {
  if (typeof t8 != "string") throw new TypeError("Expected a string");
  return t8.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var V2;
var gr = class {
  constructor(e2) {
    At(this, V2);
    pn(this, V2, new Set(e2));
  }
  getLeadingWhitespaceCount(e2) {
    let r2 = R(this, V2), n2 = 0;
    for (let s2 = 0; s2 < e2.length && r2.has(e2.charAt(s2)); s2++) n2++;
    return n2;
  }
  getTrailingWhitespaceCount(e2) {
    let r2 = R(this, V2), n2 = 0;
    for (let s2 = e2.length - 1; s2 >= 0 && r2.has(e2.charAt(s2)); s2--) n2++;
    return n2;
  }
  getLeadingWhitespace(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(0, r2);
  }
  getTrailingWhitespace(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(e2.length - r2);
  }
  hasLeadingWhitespace(e2) {
    return R(this, V2).has(e2.charAt(0));
  }
  hasTrailingWhitespace(e2) {
    return R(this, V2).has(K(false, e2, -1));
  }
  trimStart(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(r2);
  }
  trimEnd(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(0, e2.length - r2);
  }
  trim(e2) {
    return this.trimEnd(this.trimStart(e2));
  }
  split(e2, r2 = false) {
    let n2 = `[${dr([...R(this, V2)].join(""))}]+`, s2 = new RegExp(r2 ? `(${n2})` : n2, "u");
    return e2.split(s2);
  }
  hasWhitespaceCharacter(e2) {
    let r2 = R(this, V2);
    return Array.prototype.some.call(e2, (n2) => r2.has(n2));
  }
  hasNonWhitespaceCharacter(e2) {
    let r2 = R(this, V2);
    return Array.prototype.some.call(e2, (n2) => !r2.has(n2));
  }
  isWhitespaceOnly(e2) {
    let r2 = R(this, V2);
    return Array.prototype.every.call(e2, (n2) => r2.has(n2));
  }
};
V2 = /* @__PURE__ */ new WeakMap();
var En = gr;
var Li = ["	", `
`, "\f", "\r", " "];
var Fi = new En(Li);
var O = Fi;
var Cr = class extends Error {
  constructor(e2, r2, n2 = "type") {
    super(`Unexpected ${r2} node ${n2}: ${JSON.stringify(e2[n2])}.`);
    __publicField(this, "name", "UnexpectedNodeError");
    this.node = e2;
  }
};
var An = Cr;
function Pi(t8) {
  return (t8 == null ? void 0 : t8.type) === "front-matter";
}
var Pe = Pi;
var Ni = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]);
var Ii = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function Dn(t8, e2) {
  var r2;
  if (t8.type === "text" || t8.type === "comment" || Pe(t8) || t8.type === "yaml" || t8.type === "toml") return null;
  if (t8.type === "attribute" && delete e2.value, t8.type === "docType" && delete e2.value, t8.type === "angularControlFlowBlock" && ((r2 = t8.parameters) != null && r2.children)) for (let n2 of e2.parameters.children) Ii.has(t8.name) ? delete n2.expression : n2.expression = n2.expression.trim();
  t8.type === "angularIcuExpression" && (e2.switchValue = t8.switchValue.trim()), t8.type === "angularLetDeclarationInitializer" && delete e2.value;
}
Dn.ignoredProperties = Ni;
var vn = Dn;
async function Ri(t8, e2) {
  if (t8.language === "yaml") {
    let r2 = t8.value.trim(), n2 = r2 ? await e2(r2, { parser: "yaml" }) : "";
    return gn([t8.startDelimiter, t8.explicitLanguage, S, n2, n2 ? S : "", t8.endDelimiter]);
  }
}
var yn = Ri;
function he(t8, e2 = true) {
  return [k([v, t8]), e2 ? v : ""];
}
function X(t8, e2) {
  let r2 = t8.type === "NGRoot" ? t8.node.type === "NGMicrosyntax" && t8.node.body.length === 1 && t8.node.body[0].type === "NGMicrosyntaxExpression" ? t8.node.body[0].expression : t8.node : t8.type === "JsExpressionRoot" ? t8.node : t8;
  return r2 && (r2.type === "ObjectExpression" || r2.type === "ArrayExpression" || (e2.parser === "__vue_expression" || e2.parser === "__vue_ts_expression") && (r2.type === "TemplateLiteral" || r2.type === "StringLiteral"));
}
async function T(t8, e2, r2, n2) {
  r2 = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r2 };
  let s2 = true;
  n2 && (r2.__onHtmlBindingRoot = (a, o2) => {
    s2 = n2(a, o2);
  });
  let i = await e2(t8, r2, e2);
  return s2 ? E(i) : he(i);
}
function $i(t8, e2, r2, n2) {
  let { node: s2 } = r2, i = n2.originalText.slice(s2.sourceSpan.start.offset, s2.sourceSpan.end.offset);
  return /^\s*$/u.test(i) ? "" : T(i, t8, { parser: "__ng_directive", __isInHtmlAttribute: false }, X);
}
var wn = $i;
var Oi = (t8, e2) => {
  if (!(t8 && e2 == null)) return e2.toReversed || !Array.isArray(e2) ? e2.toReversed() : [...e2].reverse();
};
var bn = Oi;
function Mi(t8) {
  return Array.isArray(t8) && t8.length > 0;
}
var me = Mi;
var Tn;
var xn;
var kn;
var Bn;
var Ln;
var qi = ((Tn = globalThis.Deno) == null ? void 0 : Tn.build.os) === "windows" || ((kn = (xn = globalThis.navigator) == null ? void 0 : xn.platform) == null ? void 0 : kn.startsWith("Win")) || ((Ln = (Bn = globalThis.process) == null ? void 0 : Bn.platform) == null ? void 0 : Ln.startsWith("win")) || false;
function Fn(t8) {
  if (t8 = t8 instanceof URL ? t8 : new URL(t8), t8.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${t8.protocol}"`);
  return t8;
}
function Hi(t8) {
  return t8 = Fn(t8), decodeURIComponent(t8.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Vi(t8) {
  t8 = Fn(t8);
  let e2 = decodeURIComponent(t8.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t8.hostname !== "" && (e2 = `\\\\${t8.hostname}${e2}`), e2;
}
function Pn(t8) {
  return qi ? Vi(t8) : Hi(t8);
}
var Nn = Pn;
var Ui = (t8) => String(t8).split(/[/\\]/u).pop();
function In(t8, e2) {
  if (!e2) return;
  let r2 = Ui(e2).toLowerCase();
  return t8.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((s2) => s2.toLowerCase() === r2)) ?? t8.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((s2) => r2.endsWith(s2)));
}
function Wi(t8, e2) {
  if (e2) return t8.find(({ name: r2 }) => r2.toLowerCase() === e2) ?? t8.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(e2)) ?? t8.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${e2}`));
}
function Rn(t8, e2) {
  if (e2) {
    if (String(e2).startsWith("file:")) try {
      e2 = Nn(e2);
    } catch {
      return;
    }
    if (typeof e2 == "string") return t8.find(({ isSupported: r2 }) => r2 == null ? void 0 : r2({ filepath: e2 }));
  }
}
function Gi(t8, e2) {
  let r2 = bn(false, t8.plugins).flatMap((s2) => s2.languages ?? []), n2 = Wi(r2, e2.language) ?? In(r2, e2.physicalFile) ?? In(r2, e2.file) ?? Rn(r2, e2.physicalFile) ?? Rn(r2, e2.file) ?? (e2.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var Ne = Gi;
var $n = "inline";
var Sr = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" };
var On = "normal";
var _r = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function zi(t8) {
  return t8.type === "element" && !t8.hasExplicitNamespace && !["html", "svg"].includes(t8.namespace);
}
var fe = zi;
var Yi = (t8) => w(false, t8, /^[\t\f\r ]*\n/gu, "");
var Er = (t8) => Yi(O.trimEnd(t8));
var Mn = (t8) => {
  let e2 = t8, r2 = O.getLeadingWhitespace(e2);
  r2 && (e2 = e2.slice(r2.length));
  let n2 = O.getTrailingWhitespace(e2);
  return n2 && (e2 = e2.slice(0, -n2.length)), { leadingWhitespace: r2, trailingWhitespace: n2, text: e2 };
};
function wt(t8, e2) {
  return !!(t8.type === "ieConditionalComment" && t8.lastChild && !t8.lastChild.isSelfClosing && !t8.lastChild.endSourceSpan || t8.type === "ieConditionalComment" && !t8.complete || de(t8) && t8.children.some((r2) => r2.type !== "text" && r2.type !== "interpolation") || xt(t8, e2) && !W(t8, e2) && t8.type !== "interpolation");
}
function ge(t8) {
  return t8.type === "attribute" || !t8.parent || !t8.prev ? false : ji(t8.prev);
}
function ji(t8) {
  return t8.type === "comment" && t8.value.trim() === "prettier-ignore";
}
function $(t8) {
  return t8.type === "text" || t8.type === "comment";
}
function W(t8, e2) {
  return t8.type === "element" && (t8.fullName === "script" || t8.fullName === "style" || t8.fullName === "svg:style" || t8.fullName === "svg:script" || t8.fullName === "mj-style" && e2.parser === "mjml" || fe(t8) && (t8.name === "script" || t8.name === "style"));
}
function qn(t8, e2) {
  return t8.children && !W(t8, e2);
}
function Hn(t8, e2) {
  return W(t8, e2) || t8.type === "interpolation" || Ar(t8);
}
function Ar(t8) {
  return Jn(t8).startsWith("pre");
}
function Vn(t8, e2) {
  var s2, i;
  let r2 = n2();
  if (r2 && !t8.prev && ((i = (s2 = t8.parent) == null ? void 0 : s2.tagDefinition) != null && i.ignoreFirstLf)) return t8.type === "interpolation";
  return r2;
  function n2() {
    return Pe(t8) || t8.type === "angularControlFlowBlock" ? false : (t8.type === "text" || t8.type === "interpolation") && t8.prev && (t8.prev.type === "text" || t8.prev.type === "interpolation") ? true : !t8.parent || t8.parent.cssDisplay === "none" ? false : de(t8.parent) ? true : !(!t8.prev && (t8.parent.type === "root" || de(t8) && t8.parent || W(t8.parent, e2) || et(t8.parent, e2) || !ea(t8.parent.cssDisplay)) || t8.prev && !na(t8.prev.cssDisplay));
  }
}
function Un(t8, e2) {
  return Pe(t8) || t8.type === "angularControlFlowBlock" ? false : (t8.type === "text" || t8.type === "interpolation") && t8.next && (t8.next.type === "text" || t8.next.type === "interpolation") ? true : !t8.parent || t8.parent.cssDisplay === "none" ? false : de(t8.parent) ? true : !(!t8.next && (t8.parent.type === "root" || de(t8) && t8.parent || W(t8.parent, e2) || et(t8.parent, e2) || !ta(t8.parent.cssDisplay)) || t8.next && !ra(t8.next.cssDisplay));
}
function Wn(t8, e2) {
  return sa(t8.cssDisplay) && !W(t8, e2);
}
function Je(t8) {
  return Pe(t8) || t8.next && t8.sourceSpan.end && t8.sourceSpan.end.line + 1 < t8.next.sourceSpan.start.line;
}
function Gn(t8) {
  return Dr(t8) || t8.type === "element" && t8.children.length > 0 && (["body", "script", "style"].includes(t8.name) || t8.children.some((e2) => Xi(e2))) || t8.firstChild && t8.firstChild === t8.lastChild && t8.firstChild.type !== "text" && Yn(t8.firstChild) && (!t8.lastChild.isTrailingSpaceSensitive || jn(t8.lastChild));
}
function Dr(t8) {
  return t8.type === "element" && t8.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t8.name) || t8.cssDisplay.startsWith("table") && t8.cssDisplay !== "table-cell");
}
function bt(t8) {
  return Kn(t8) || t8.prev && Ki(t8.prev) || zn(t8);
}
function Ki(t8) {
  return Kn(t8) || t8.type === "element" && t8.fullName === "br" || zn(t8);
}
function zn(t8) {
  return Yn(t8) && jn(t8);
}
function Yn(t8) {
  return t8.hasLeadingSpaces && (t8.prev ? t8.prev.sourceSpan.end.line < t8.sourceSpan.start.line : t8.parent.type === "root" || t8.parent.startSourceSpan.end.line < t8.sourceSpan.start.line);
}
function jn(t8) {
  return t8.hasTrailingSpaces && (t8.next ? t8.next.sourceSpan.start.line > t8.sourceSpan.end.line : t8.parent.type === "root" || t8.parent.endSourceSpan && t8.parent.endSourceSpan.start.line > t8.sourceSpan.end.line);
}
function Kn(t8) {
  switch (t8.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(t8.name);
  }
  return false;
}
function Tt(t8) {
  return t8.lastChild ? Tt(t8.lastChild) : t8;
}
function Xi(t8) {
  var e2;
  return (e2 = t8.children) == null ? void 0 : e2.some((r2) => r2.type !== "text");
}
function Xn(t8) {
  if (t8) switch (t8) {
    case "module":
    case "text/javascript":
    case "text/babel":
    case "text/jsx":
    case "application/javascript":
      return "babel";
    case "application/x-typescript":
      return "typescript";
    case "text/markdown":
      return "markdown";
    case "text/html":
      return "html";
    case "text/x-handlebars-template":
      return "glimmer";
    default:
      if (t8.endsWith("json") || t8.endsWith("importmap") || t8 === "speculationrules") return "json";
  }
}
function Qi(t8, e2) {
  let { name: r2, attrMap: n2 } = t8;
  if (r2 !== "script" || Object.prototype.hasOwnProperty.call(n2, "src")) return;
  let { type: s2, lang: i } = t8.attrMap;
  return !i && !s2 ? "babel" : Ne(e2, { language: i }) ?? Xn(s2);
}
function Ji(t8, e2) {
  if (!xt(t8, e2)) return;
  let { attrMap: r2 } = t8;
  if (Object.prototype.hasOwnProperty.call(r2, "src")) return;
  let { type: n2, lang: s2 } = r2;
  return Ne(e2, { language: s2 }) ?? Xn(n2);
}
function Zi(t8, e2) {
  if (t8.name === "style") {
    let { lang: r2 } = t8.attrMap;
    return r2 ? Ne(e2, { language: r2 }) : "css";
  }
  if (t8.name === "mj-style" && e2.parser === "mjml") return "css";
}
function vr(t8, e2) {
  return Qi(t8, e2) ?? Zi(t8, e2) ?? Ji(t8, e2);
}
function Ze(t8) {
  return t8 === "block" || t8 === "list-item" || t8.startsWith("table");
}
function ea(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function ta(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function ra(t8) {
  return !Ze(t8);
}
function na(t8) {
  return !Ze(t8);
}
function sa(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function de(t8) {
  return Jn(t8).startsWith("pre");
}
function ia(t8, e2) {
  let r2 = t8;
  for (; r2; ) {
    if (e2(r2)) return true;
    r2 = r2.parent;
  }
  return false;
}
function Qn(t8, e2) {
  var n2;
  if (Ce(t8, e2)) return "block";
  if (((n2 = t8.prev) == null ? void 0 : n2.type) === "comment") {
    let s2 = t8.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (s2) return s2[1];
  }
  let r2 = false;
  if (t8.type === "element" && t8.namespace === "svg") if (ia(t8, (s2) => s2.fullName === "svg:foreignObject")) r2 = true;
  else return t8.name === "svg" ? "inline-block" : "block";
  switch (e2.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (t8.type === "element" && (!t8.namespace || r2 || fe(t8)) && Object.prototype.hasOwnProperty.call(Sr, t8.name)) return Sr[t8.name];
  }
  return $n;
}
function Jn(t8) {
  return t8.type === "element" && (!t8.namespace || fe(t8)) && Object.prototype.hasOwnProperty.call(_r, t8.name) ? _r[t8.name] : On;
}
function aa(t8) {
  let e2 = Number.POSITIVE_INFINITY;
  for (let r2 of t8.split(`
`)) {
    if (r2.length === 0) continue;
    let n2 = O.getLeadingWhitespaceCount(r2);
    if (n2 === 0) return 0;
    r2.length !== n2 && n2 < e2 && (e2 = n2);
  }
  return e2 === Number.POSITIVE_INFINITY ? 0 : e2;
}
function yr(t8, e2 = aa(t8)) {
  return e2 === 0 ? t8 : t8.split(`
`).map((r2) => r2.slice(e2)).join(`
`);
}
function wr(t8) {
  return w(false, w(false, t8, "&apos;", "'"), "&quot;", '"');
}
function P(t8) {
  return wr(t8.value);
}
var oa = /* @__PURE__ */ new Set(["template", "style", "script"]);
function et(t8, e2) {
  return Ce(t8, e2) && !oa.has(t8.fullName);
}
function Ce(t8, e2) {
  return e2.parser === "vue" && t8.type === "element" && t8.parent.type === "root" && t8.fullName.toLowerCase() !== "html";
}
function xt(t8, e2) {
  return Ce(t8, e2) && (et(t8, e2) || t8.attrMap.lang && t8.attrMap.lang !== "html");
}
function Zn(t8) {
  let e2 = t8.fullName;
  return e2.charAt(0) === "#" || e2 === "slot-scope" || e2 === "v-slot" || e2.startsWith("v-slot:");
}
function es(t8, e2) {
  let r2 = t8.parent;
  if (!Ce(r2, e2)) return false;
  let n2 = r2.fullName, s2 = t8.fullName;
  return n2 === "script" && s2 === "setup" || n2 === "style" && s2 === "vars";
}
function kt(t8, e2 = t8.value) {
  return t8.parent.isWhitespaceSensitive ? t8.parent.isIndentationSensitive ? B(e2) : B(yr(Er(e2)), S) : H(_, O.split(e2));
}
function Bt(t8, e2) {
  return Ce(t8, e2) && t8.name === "script";
}
var br = /\{\{(.+?)\}\}/su;
async function ts(t8, e2) {
  let r2 = [];
  for (let [n2, s2] of t8.split(br).entries()) if (n2 % 2 === 0) r2.push(B(s2));
  else try {
    r2.push(E(["{{", k([_, await T(s2, e2, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _, "}}"]));
  } catch {
    r2.push("{{", B(s2), "}}");
  }
  return r2;
}
function Tr({ parser: t8 }) {
  return (e2, r2, n2) => T(P(n2.node), e2, { parser: t8 }, X);
}
var ua = Tr({ parser: "__ng_action" });
var la = Tr({ parser: "__ng_binding" });
var ca = Tr({ parser: "__ng_directive" });
function pa(t8, e2) {
  if (e2.parser !== "angular") return;
  let { node: r2 } = t8, n2 = r2.fullName;
  if (n2.startsWith("(") && n2.endsWith(")") || n2.startsWith("on-")) return ua;
  if (n2.startsWith("[") && n2.endsWith("]") || /^bind(?:on)?-/u.test(n2) || /^ng-(?:if|show|hide|class|style)$/u.test(n2)) return la;
  if (n2.startsWith("*")) return ca;
  let s2 = P(r2);
  if (/^i18n(?:-.+)?$/u.test(n2)) return () => he(vt(kt(r2, s2.trim())), !s2.includes("@@"));
  if (br.test(s2)) return (i) => ts(s2, i);
}
var rs = pa;
function ha(t8, e2) {
  let { node: r2 } = t8, n2 = P(r2);
  if (r2.fullName === "class" && !e2.parentParser && !n2.includes("{{")) return () => n2.trim().split(/\s+/u).join(" ");
}
var ns = ha;
function ss(t8) {
  return t8 === "	" || t8 === `
` || t8 === "\f" || t8 === "\r" || t8 === " ";
}
var ma = /^[ \t\n\r\u000c]+/;
var fa = /^[, \t\n\r\u000c]+/;
var da = /^[^ \t\n\r\u000c]+/;
var ga = /[,]+$/;
var is = /^\d+$/;
var Ca = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function Sa(t8) {
  let e2 = t8.length, r2, n2, s2, i, a, o2 = 0, u;
  function p(C) {
    let A, D = C.exec(t8.substring(o2));
    if (D) return [A] = D, o2 += A.length, A;
  }
  let l2 = [];
  for (; ; ) {
    if (p(fa), o2 >= e2) {
      if (l2.length === 0) throw new Error("Must contain one or more image candidate strings.");
      return l2;
    }
    u = o2, r2 = p(da), n2 = [], r2.slice(-1) === "," ? (r2 = r2.replace(ga, ""), f()) : m();
  }
  function m() {
    for (p(ma), s2 = "", i = "in descriptor"; ; ) {
      if (a = t8.charAt(o2), i === "in descriptor") if (ss(a)) s2 && (n2.push(s2), s2 = "", i = "after descriptor");
      else if (a === ",") {
        o2 += 1, s2 && n2.push(s2), f();
        return;
      } else if (a === "(") s2 += a, i = "in parens";
      else if (a === "") {
        s2 && n2.push(s2), f();
        return;
      } else s2 += a;
      else if (i === "in parens") if (a === ")") s2 += a, i = "in descriptor";
      else if (a === "") {
        n2.push(s2), f();
        return;
      } else s2 += a;
      else if (i === "after descriptor" && !ss(a)) if (a === "") {
        f();
        return;
      } else i = "in descriptor", o2 -= 1;
      o2 += 1;
    }
  }
  function f() {
    let C = false, A, D, I3, F, c2 = {}, g2, y2, q2, x, U2;
    for (F = 0; F < n2.length; F++) g2 = n2[F], y2 = g2[g2.length - 1], q2 = g2.substring(0, g2.length - 1), x = parseInt(q2, 10), U2 = parseFloat(q2), is.test(q2) && y2 === "w" ? ((A || D) && (C = true), x === 0 ? C = true : A = x) : Ca.test(q2) && y2 === "x" ? ((A || D || I3) && (C = true), U2 < 0 ? C = true : D = U2) : is.test(q2) && y2 === "h" ? ((I3 || D) && (C = true), x === 0 ? C = true : I3 = x) : C = true;
    if (!C) c2.source = { value: r2, startOffset: u }, A && (c2.width = { value: A }), D && (c2.density = { value: D }), I3 && (c2.height = { value: I3 }), l2.push(c2);
    else throw new Error(`Invalid srcset descriptor found in "${t8}" at "${g2}".`);
  }
}
var as = Sa;
function _a3(t8) {
  if (t8.node.fullName === "srcset" && (t8.parent.fullName === "img" || t8.parent.fullName === "source")) return () => Aa(P(t8.node));
}
var os = { width: "w", height: "h", density: "x" };
var Ea = Object.keys(os);
function Aa(t8) {
  let e2 = as(t8), r2 = Ea.filter((l2) => e2.some((m) => Object.prototype.hasOwnProperty.call(m, l2)));
  if (r2.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
  let [n2] = r2, s2 = os[n2], i = e2.map((l2) => l2.source.value), a = Math.max(...i.map((l2) => l2.length)), o2 = e2.map((l2) => l2[n2] ? String(l2[n2].value) : ""), u = o2.map((l2) => {
    let m = l2.indexOf(".");
    return m === -1 ? l2.length : m;
  }), p = Math.max(...u);
  return he(H([",", _], i.map((l2, m) => {
    let f = [l2], C = o2[m];
    if (C) {
      let A = a - l2.length + 1, D = p - u[m], I3 = " ".repeat(A + D);
      f.push(pe(I3, " "), C + s2);
    }
    return f;
  })));
}
var us = _a3;
function ls(t8, e2) {
  let { node: r2 } = t8, n2 = P(t8.node).trim();
  if (r2.fullName === "style" && !e2.parentParser && !n2.includes("{{")) return async (s2) => he(await s2(n2, { parser: "css", __isHTMLStyleAttribute: true }));
}
var xr = /* @__PURE__ */ new WeakMap();
function Da(t8, e2) {
  let { root: r2 } = t8;
  return xr.has(r2) || xr.set(r2, r2.children.some((n2) => Bt(n2, e2) && ["ts", "typescript"].includes(n2.attrMap.lang))), xr.get(r2);
}
var Ie = Da;
function cs(t8, e2, r2) {
  let { node: n2 } = r2, s2 = P(n2);
  return T(`type T<${s2}> = any`, t8, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, X);
}
function ps(t8, e2, { parseWithTs: r2 }) {
  return T(`function _(${t8}) {}`, e2, { parser: r2 ? "babel-ts" : "babel", __isVueBindings: true });
}
async function hs(t8, e2, r2, n2) {
  let s2 = P(r2.node), { left: i, operator: a, right: o2 } = va(s2), u = Ie(r2, n2);
  return [E(await T(`function _(${i}) {}`, t8, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T(o2, t8, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function va(t8) {
  let e2 = /(.*?)\s+(in|of)\s+(.*)/su, r2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n2 = /^\(|\)$/gu, s2 = t8.match(e2);
  if (!s2) return;
  let i = {};
  if (i.for = s2[3].trim(), !i.for) return;
  let a = w(false, s2[1].trim(), n2, ""), o2 = a.match(r2);
  o2 ? (i.alias = a.replace(r2, ""), i.iterator1 = o2[1].trim(), o2[2] && (i.iterator2 = o2[2].trim())) : i.alias = a;
  let u = [i.alias, i.iterator1, i.iterator2];
  if (!u.some((p, l2) => !p && (l2 === 0 || u.slice(l2 + 1).some(Boolean)))) return { left: u.filter(Boolean).join(","), operator: s2[2], right: i.for };
}
function ya(t8, e2) {
  if (e2.parser !== "vue") return;
  let { node: r2 } = t8, n2 = r2.fullName;
  if (n2 === "v-for") return hs;
  if (n2 === "generic" && Bt(r2.parent, e2)) return cs;
  let s2 = P(r2), i = Ie(t8, e2);
  if (Zn(r2) || es(r2, e2)) return (a) => ps(s2, a, { parseWithTs: i });
  if (n2.startsWith("@") || n2.startsWith("v-on:")) return (a) => wa(s2, a, { parseWithTs: i });
  if (n2.startsWith(":") || n2.startsWith(".") || n2.startsWith("v-bind:")) return (a) => ba(s2, a, { parseWithTs: i });
  if (n2.startsWith("v-")) return (a) => ms(s2, a, { parseWithTs: i });
}
async function wa(t8, e2, { parseWithTs: r2 }) {
  var n2;
  try {
    return await ms(t8, e2, { parseWithTs: r2 });
  } catch (s2) {
    if (((n2 = s2.cause) == null ? void 0 : n2.code) !== "BABEL_PARSER_SYNTAX_ERROR") throw s2;
  }
  return T(t8, e2, { parser: r2 ? "__vue_ts_event_binding" : "__vue_event_binding" }, X);
}
function ba(t8, e2, { parseWithTs: r2 }) {
  return T(t8, e2, { parser: r2 ? "__vue_ts_expression" : "__vue_expression" }, X);
}
function ms(t8, e2, { parseWithTs: r2 }) {
  return T(t8, e2, { parser: r2 ? "__ts_expression" : "__js_expression" }, X);
}
var fs = ya;
function Ta(t8, e2) {
  let { node: r2 } = t8;
  if (r2.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e2.originalText.slice(r2.valueSpan.start.offset, r2.valueSpan.end.offset)) || e2.parser === "lwc" && r2.value.startsWith("{") && r2.value.endsWith("}")) return [r2.rawName, "=", r2.value];
    for (let n2 of [us, ls, ns, fs, rs]) {
      let s2 = n2(t8, e2);
      if (s2) return xa(s2);
    }
  }
}
function xa(t8) {
  return async (e2, r2, n2, s2) => {
    let i = await t8(e2, r2, n2, s2);
    if (i) return i = hr(i, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n2.node.rawName, '="', E(i), '"'];
  };
}
var ds = Ta;
var ka = new Proxy(() => {
}, { get: () => ka });
function J(t8) {
  return t8.sourceSpan.start.offset;
}
function se(t8) {
  return t8.sourceSpan.end.offset;
}
function tt(t8, e2) {
  return [t8.isSelfClosing ? "" : Ba(t8, e2), Se(t8, e2)];
}
function Ba(t8, e2) {
  return t8.lastChild && Ae(t8.lastChild) ? "" : [La(t8, e2), Lt(t8, e2)];
}
function Se(t8, e2) {
  return (t8.next ? Q(t8.next) : Ee(t8.parent)) ? "" : [_e(t8, e2), G(t8, e2)];
}
function La(t8, e2) {
  return Ee(t8) ? _e(t8.lastChild, e2) : "";
}
function G(t8, e2) {
  return Ae(t8) ? Lt(t8.parent, e2) : rt(t8) ? Ft(t8.next, e2) : "";
}
function Lt(t8, e2) {
  if (Cs(t8, e2)) return "";
  switch (t8.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t8.hasHtmComponentClosingTag) return "<//";
    default:
      return `</${t8.rawName}`;
  }
}
function _e(t8, e2) {
  if (Cs(t8, e2)) return "";
  switch (t8.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t8.isSelfClosing) return "/>";
    default:
      return ">";
  }
}
function Cs(t8, e2) {
  return !t8.isSelfClosing && !t8.endSourceSpan && (ge(t8) || wt(t8.parent, e2));
}
function Q(t8) {
  return t8.prev && t8.prev.type !== "docType" && t8.type !== "angularControlFlowBlock" && !$(t8.prev) && t8.isLeadingSpaceSensitive && !t8.hasLeadingSpaces;
}
function Ee(t8) {
  var e2;
  return ((e2 = t8.lastChild) == null ? void 0 : e2.isTrailingSpaceSensitive) && !t8.lastChild.hasTrailingSpaces && !$(Tt(t8.lastChild)) && !de(t8);
}
function Ae(t8) {
  return !t8.next && !t8.hasTrailingSpaces && t8.isTrailingSpaceSensitive && $(Tt(t8));
}
function rt(t8) {
  return t8.next && !$(t8.next) && $(t8) && t8.isTrailingSpaceSensitive && !t8.hasTrailingSpaces;
}
function Fa(t8) {
  let e2 = t8.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e2 ? e2[1] ? e2[1].split(/\s+/u) : true : false;
}
function nt(t8) {
  return !t8.prev && t8.isLeadingSpaceSensitive && !t8.hasLeadingSpaces;
}
function Pa(t8, e2, r2) {
  var m;
  let { node: n2 } = t8;
  if (!me(n2.attrs)) return n2.isSelfClosing ? " " : "";
  let s2 = ((m = n2.prev) == null ? void 0 : m.type) === "comment" && Fa(n2.prev.value), i = typeof s2 == "boolean" ? () => s2 : Array.isArray(s2) ? (f) => s2.includes(f.rawName) : () => false, a = t8.map(({ node: f }) => i(f) ? B(e2.originalText.slice(J(f), se(f))) : r2(), "attrs"), o2 = n2.type === "element" && n2.fullName === "script" && n2.attrs.length === 1 && n2.attrs[0].fullName === "src" && n2.children.length === 0, p = e2.singleAttributePerLine && n2.attrs.length > 1 && !Ce(n2, e2) ? S : _, l2 = [k([o2 ? " " : _, H(p, a)])];
  return n2.firstChild && nt(n2.firstChild) || n2.isSelfClosing && Ee(n2.parent) || o2 ? l2.push(n2.isSelfClosing ? " " : "") : l2.push(e2.bracketSameLine ? n2.isSelfClosing ? " " : "" : n2.isSelfClosing ? _ : v), l2;
}
function Na(t8) {
  return t8.firstChild && nt(t8.firstChild) ? "" : Pt(t8);
}
function st(t8, e2, r2) {
  let { node: n2 } = t8;
  return [De(n2, e2), Pa(t8, e2, r2), n2.isSelfClosing ? "" : Na(n2)];
}
function De(t8, e2) {
  return t8.prev && rt(t8.prev) ? "" : [z(t8, e2), Ft(t8, e2)];
}
function z(t8, e2) {
  return nt(t8) ? Pt(t8.parent) : Q(t8) ? _e(t8.prev, e2) : "";
}
var gs = "<!doctype";
function Ft(t8, e2) {
  switch (t8.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t8.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t8.value === "html") {
        let { filepath: n2 } = e2;
        if (n2 && /\.html?$/u.test(n2)) return gs;
      }
      let r2 = J(t8);
      return e2.originalText.slice(r2, r2 + gs.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t8.condition) return `<!--[if ${t8.condition}]><!--><${t8.rawName}`;
    default:
      return `<${t8.rawName}`;
  }
}
function Pt(t8) {
  switch (t8.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t8.condition) return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function Ia(t8, e2) {
  if (!t8.endSourceSpan) return "";
  let r2 = t8.startSourceSpan.end.offset;
  t8.firstChild && nt(t8.firstChild) && (r2 -= Pt(t8).length);
  let n2 = t8.endSourceSpan.start.offset;
  return t8.lastChild && Ae(t8.lastChild) ? n2 += Lt(t8, e2).length : Ee(t8) && (n2 -= _e(t8.lastChild, e2).length), e2.originalText.slice(r2, n2);
}
var Nt = Ia;
var Ra = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function $a(t8, e2) {
  let { node: r2 } = t8;
  switch (r2.type) {
    case "element":
      if (W(r2, e2) || r2.type === "interpolation") return;
      if (!r2.isSelfClosing && xt(r2, e2)) {
        let n2 = vr(r2, e2);
        return n2 ? async (s2, i) => {
          let a = Nt(r2, e2), o2 = /^\s*$/u.test(a), u = "";
          return o2 || (u = await s2(Er(a), { parser: n2, __embeddedInHtml: true }), o2 = u === ""), [z(r2, e2), E(st(t8, e2, i)), o2 ? "" : S, u, o2 ? "" : S, tt(r2, e2), G(r2, e2)];
        } : void 0;
      }
      break;
    case "text":
      if (W(r2.parent, e2)) {
        let n2 = vr(r2.parent, e2);
        if (n2) return async (s2) => {
          let i = n2 === "markdown" ? yr(r2.value.replace(/^[^\S\n]*\n/u, "")) : r2.value, a = { parser: n2, __embeddedInHtml: true };
          if (e2.parser === "html" && n2 === "babel") {
            let o2 = "script", { attrMap: u } = r2.parent;
            u && (u.type === "module" || (u.type === "text/babel" || u.type === "text/jsx") && u["data-type"] === "module") && (o2 = "module"), a.__babelSourceType = o2;
          }
          return [ne, z(r2, e2), await s2(i, a), G(r2, e2)];
        };
      } else if (r2.parent.type === "interpolation") return async (n2) => {
        let s2 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
        return e2.parser === "angular" ? s2.parser = "__ng_interpolation" : e2.parser === "vue" ? s2.parser = Ie(t8, e2) ? "__vue_ts_expression" : "__vue_expression" : s2.parser = "__js_expression", [k([_, await n2(r2.value, s2)]), r2.parent.next && Q(r2.parent.next) ? " " : _];
      };
      break;
    case "attribute":
      return ds(t8, e2);
    case "front-matter":
      return (n2) => yn(r2, n2);
    case "angularControlFlowBlockParameters":
      return Ra.has(t8.parent.name) ? wn : void 0;
    case "angularLetDeclarationInitializer":
      return (n2) => T(r2.value, n2, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
var Ss = $a;
var it = null;
function at(t8) {
  if (it !== null && typeof it.property) {
    let e2 = it;
    return it = at.prototype = null, e2;
  }
  return it = at.prototype = t8 ?? /* @__PURE__ */ Object.create(null), new at();
}
var Oa = 10;
for (let t8 = 0; t8 <= Oa; t8++) at();
function kr(t8) {
  return at(t8);
}
function Ma(t8, e2 = "type") {
  kr(t8);
  function r2(n2) {
    let s2 = n2[e2], i = t8[s2];
    if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${s2}'.`), { node: n2 });
    return i;
  }
  return r2;
}
var _s = Ma;
var qa = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
var Es = qa;
var Ha = _s(Es);
var As = Ha;
var Ds = "format";
var vs2 = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u;
var ys = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
function ws2(t8) {
  return ys.test(t8);
}
function bs(t8) {
  return vs2.test(t8);
}
function Ts(t8) {
  return `<!-- @${Ds} -->

${t8}`;
}
var xs = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function ks(t8) {
  let e2 = se(t8);
  return t8.type === "element" && !t8.endSourceSpan && me(t8.children) ? Math.max(e2, ks(K(false, t8.children, -1))) : e2;
}
function ot(t8, e2, r2) {
  let n2 = t8.node;
  if (ge(n2)) {
    let s2 = ks(n2);
    return [z(n2, e2), B(O.trimEnd(e2.originalText.slice(J(n2) + (n2.prev && rt(n2.prev) ? Ft(n2).length : 0), s2 - (n2.next && Q(n2.next) ? _e(n2, e2).length : 0)))), G(n2, e2)];
  }
  return r2();
}
function It(t8, e2) {
  return $(t8) && $(e2) ? t8.isTrailingSpaceSensitive ? t8.hasTrailingSpaces ? bt(e2) ? S : _ : "" : bt(e2) ? S : v : rt(t8) && (ge(e2) || e2.firstChild || e2.isSelfClosing || e2.type === "element" && e2.attrs.length > 0) || t8.type === "element" && t8.isSelfClosing && Q(e2) ? "" : !e2.isLeadingSpaceSensitive || bt(e2) || Q(e2) && t8.lastChild && Ae(t8.lastChild) && t8.lastChild.lastChild && Ae(t8.lastChild.lastChild) ? S : e2.hasLeadingSpaces ? _ : v;
}
function Re(t8, e2, r2) {
  let { node: n2 } = t8;
  if (Dr(n2)) return [ne, ...t8.map((i) => {
    let a = i.node, o2 = a.prev ? It(a.prev, a) : "";
    return [o2 ? [o2, Je(a.prev) ? S : ""] : "", ot(i, e2, r2)];
  }, "children")];
  let s2 = n2.children.map(() => Symbol(""));
  return t8.map((i, a) => {
    let o2 = i.node;
    if ($(o2)) {
      if (o2.prev && $(o2.prev)) {
        let A = It(o2.prev, o2);
        if (A) return Je(o2.prev) ? [S, S, ot(i, e2, r2)] : [A, ot(i, e2, r2)];
      }
      return ot(i, e2, r2);
    }
    let u = [], p = [], l2 = [], m = [], f = o2.prev ? It(o2.prev, o2) : "", C = o2.next ? It(o2, o2.next) : "";
    return f && (Je(o2.prev) ? u.push(S, S) : f === S ? u.push(S) : $(o2.prev) ? p.push(f) : p.push(pe("", v, { groupId: s2[a - 1] }))), C && (Je(o2) ? $(o2.next) && m.push(S, S) : C === S ? $(o2.next) && m.push(S) : l2.push(C)), [...u, E([...p, E([ot(i, e2, r2), ...l2], { id: s2[a] })]), ...m];
  }, "children");
}
function Bs(t8, e2, r2) {
  let { node: n2 } = t8, s2 = [];
  Va(t8) && s2.push("} "), s2.push("@", n2.name), n2.parameters && s2.push(" (", E(r2("parameters")), ")"), s2.push(" {");
  let i = Ls(n2);
  return n2.children.length > 0 ? (n2.firstChild.hasLeadingSpaces = true, n2.lastChild.hasTrailingSpaces = true, s2.push(k([S, Re(t8, e2, r2)])), i && s2.push(S, "}")) : i && s2.push("}"), E(s2, { shouldBreak: true });
}
function Ls(t8) {
  var e2, r2;
  return !(((e2 = t8.next) == null ? void 0 : e2.type) === "angularControlFlowBlock" && ((r2 = xs.get(t8.name)) != null && r2.has(t8.next.name)));
}
function Va(t8) {
  let { previous: e2 } = t8;
  return (e2 == null ? void 0 : e2.type) === "angularControlFlowBlock" && !ge(e2) && !Ls(e2);
}
function Fs(t8, e2, r2) {
  return [k([v, H([";", _], t8.map(r2, "children"))]), v];
}
function Ps(t8, e2, r2) {
  let { node: n2 } = t8;
  return [De(n2, e2), E([n2.switchValue.trim(), ", ", n2.clause, n2.cases.length > 0 ? [",", k([_, H(_, t8.map(r2, "cases"))])] : "", v]), Se(n2, e2)];
}
function Ns(t8, e2, r2) {
  let { node: n2 } = t8;
  return [n2.value, " {", E([k([v, t8.map(({ node: s2, isLast: i }) => {
    let a = [r2()];
    return s2.type === "text" && (s2.hasLeadingSpaces && a.unshift(_), s2.hasTrailingSpaces && !i && a.push(_)), a;
  }, "expression")]), v]), "}"];
}
function Is(t8, e2, r2) {
  let { node: n2 } = t8;
  if (wt(n2, e2)) return [z(n2, e2), E(st(t8, e2, r2)), B(Nt(n2, e2)), ...tt(n2, e2), G(n2, e2)];
  let s2 = n2.children.length === 1 && (n2.firstChild.type === "interpolation" || n2.firstChild.type === "angularIcuExpression") && n2.firstChild.isLeadingSpaceSensitive && !n2.firstChild.hasLeadingSpaces && n2.lastChild.isTrailingSpaceSensitive && !n2.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l2) => E([E(st(t8, e2, r2), { id: i }), l2, tt(n2, e2)]), o2 = (l2) => s2 ? Cn(l2, { groupId: i }) : (W(n2, e2) || et(n2, e2)) && n2.parent.type === "root" && e2.parser === "vue" && !e2.vueIndentScriptAndStyle ? l2 : k(l2), u = () => s2 ? pe(v, "", { groupId: i }) : n2.firstChild.hasLeadingSpaces && n2.firstChild.isLeadingSpaceSensitive ? _ : n2.firstChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive ? dn(v) : v, p = () => (n2.next ? Q(n2.next) : Ee(n2.parent)) ? n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? " " : "" : s2 ? pe(v, "", { groupId: i }) : n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? _ : (n2.lastChild.type === "comment" || n2.lastChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e2.tabWidth * (t8.ancestors.length - 1)}}$`, "u").test(n2.lastChild.value) ? "" : v;
  return n2.children.length === 0 ? a(n2.hasDanglingSpaces && n2.isDanglingSpaceSensitive ? _ : "") : a([Gn(n2) ? ne : "", o2([u(), Re(t8, e2, r2)]), p()]);
}
function ut(t8) {
  return t8 >= 9 && t8 <= 32 || t8 == 160;
}
function Rt(t8) {
  return 48 <= t8 && t8 <= 57;
}
function lt(t8) {
  return t8 >= 97 && t8 <= 122 || t8 >= 65 && t8 <= 90;
}
function Rs(t8) {
  return t8 >= 97 && t8 <= 102 || t8 >= 65 && t8 <= 70 || Rt(t8);
}
function $t(t8) {
  return t8 === 10 || t8 === 13;
}
function Br(t8) {
  return 48 <= t8 && t8 <= 55;
}
function Ot(t8) {
  return t8 === 39 || t8 === 34 || t8 === 96;
}
var Ua = /-+([a-z0-9])/g;
function Os(t8) {
  return t8.replace(Ua, (...e2) => e2[1].toUpperCase());
}
var ie = class t2 {
  constructor(e2, r2, n2, s2) {
    this.file = e2, this.offset = r2, this.line = n2, this.col = s2;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e2) {
    let r2 = this.file.content, n2 = r2.length, s2 = this.offset, i = this.line, a = this.col;
    for (; s2 > 0 && e2 < 0; ) if (s2--, e2++, r2.charCodeAt(s2) == 10) {
      i--;
      let u = r2.substring(0, s2 - 1).lastIndexOf(String.fromCharCode(10));
      a = u > 0 ? s2 - u : s2;
    } else a--;
    for (; s2 < n2 && e2 > 0; ) {
      let o2 = r2.charCodeAt(s2);
      s2++, e2--, o2 == 10 ? (i++, a = 0) : a++;
    }
    return new t2(this.file, s2, i, a);
  }
  getContext(e2, r2) {
    let n2 = this.file.content, s2 = this.offset;
    if (s2 != null) {
      s2 > n2.length - 1 && (s2 = n2.length - 1);
      let i = s2, a = 0, o2 = 0;
      for (; a < e2 && s2 > 0 && (s2--, a++, !(n2[s2] == `
` && ++o2 == r2)); ) ;
      for (a = 0, o2 = 0; a < e2 && i < n2.length - 1 && (i++, a++, !(n2[i] == `
` && ++o2 == r2)); ) ;
      return { before: n2.substring(s2, this.offset), after: n2.substring(this.offset, i + 1) };
    }
    return null;
  }
};
var ve = class {
  constructor(e2, r2) {
    this.content = e2, this.url = r2;
  }
};
var h = class {
  constructor(e2, r2, n2 = e2, s2 = null) {
    this.start = e2, this.end = r2, this.fullStart = n2, this.details = s2;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
};
var Mt;
(function(t8) {
  t8[t8.WARNING = 0] = "WARNING", t8[t8.ERROR = 1] = "ERROR";
})(Mt || (Mt = {}));
var Oe = class {
  constructor(e2, r2, n2 = Mt.ERROR, s2) {
    this.span = e2, this.msg = r2, this.level = n2, this.relatedError = s2;
  }
  contextualMessage() {
    let e2 = this.span.start.getContext(100, 3);
    return e2 ? `${this.msg} ("${e2.before}[${Mt[this.level]} ->]${e2.after}")` : this.msg;
  }
  toString() {
    let e2 = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e2}`;
  }
};
var Wa = [za, Ya, Ka, Qa, Ja, to, Za, eo, ro, Xa];
function Ga(t8, e2) {
  for (let r2 of Wa) r2(t8, e2);
  return t8;
}
function za(t8) {
  t8.walk((e2) => {
    if (e2.type === "element" && e2.tagDefinition.ignoreFirstLf && e2.children.length > 0 && e2.children[0].type === "text" && e2.children[0].value[0] === `
`) {
      let r2 = e2.children[0];
      r2.value.length === 1 ? e2.removeChild(r2) : r2.value = r2.value.slice(1);
    }
  });
}
function Ya(t8) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && ((n2 = r2.prev) == null ? void 0 : n2.type) === "ieConditionalStartComment" && r2.prev.sourceSpan.end.offset === r2.startSourceSpan.start.offset && ((s2 = r2.firstChild) == null ? void 0 : s2.type) === "ieConditionalEndComment" && r2.firstChild.sourceSpan.start.offset === r2.startSourceSpan.end.offset;
  };
  t8.walk((r2) => {
    if (r2.children) for (let n2 = 0; n2 < r2.children.length; n2++) {
      let s2 = r2.children[n2];
      if (!e2(s2)) continue;
      let i = s2.prev, a = s2.firstChild;
      r2.removeChild(i), n2--;
      let o2 = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o2.start, s2.sourceSpan.end);
      s2.condition = i.condition, s2.sourceSpan = u, s2.startSourceSpan = o2, s2.removeChild(a);
    }
  });
}
function ja(t8, e2, r2) {
  t8.walk((n2) => {
    if (n2.children) for (let s2 = 0; s2 < n2.children.length; s2++) {
      let i = n2.children[s2];
      if (i.type !== "text" && !e2(i)) continue;
      i.type !== "text" && (i.type = "text", i.value = r2(i));
      let a = i.prev;
      !a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n2.removeChild(i), s2--);
    }
  });
}
function Ka(t8) {
  return ja(t8, (e2) => e2.type === "cdata", (e2) => `<![CDATA[${e2.value}]]>`);
}
function Xa(t8) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && r2.attrs.length === 0 && r2.children.length === 1 && r2.firstChild.type === "text" && !O.hasWhitespaceCharacter(r2.children[0].value) && !r2.firstChild.hasLeadingSpaces && !r2.firstChild.hasTrailingSpaces && r2.isLeadingSpaceSensitive && !r2.hasLeadingSpaces && r2.isTrailingSpaceSensitive && !r2.hasTrailingSpaces && ((n2 = r2.prev) == null ? void 0 : n2.type) === "text" && ((s2 = r2.next) == null ? void 0 : s2.type) === "text";
  };
  t8.walk((r2) => {
    if (r2.children) for (let n2 = 0; n2 < r2.children.length; n2++) {
      let s2 = r2.children[n2];
      if (!e2(s2)) continue;
      let i = s2.prev, a = s2.next;
      i.value += `<${s2.rawName}>` + s2.firstChild.value + `</${s2.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r2.removeChild(s2), n2--, r2.removeChild(a);
    }
  });
}
function Qa(t8, e2) {
  if (e2.parser === "html") return;
  let r2 = /\{\{(.+?)\}\}/su;
  t8.walk((n2) => {
    if (qn(n2, e2)) for (let s2 of n2.children) {
      if (s2.type !== "text") continue;
      let i = s2.sourceSpan.start, a = null, o2 = s2.value.split(r2);
      for (let u = 0; u < o2.length; u++, i = a) {
        let p = o2[u];
        if (u % 2 === 0) {
          a = i.moveBy(p.length), p.length > 0 && n2.insertChildBefore(s2, { type: "text", value: p, sourceSpan: new h(i, a) });
          continue;
        }
        a = i.moveBy(p.length + 4), n2.insertChildBefore(s2, { type: "interpolation", sourceSpan: new h(i, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i.moveBy(2), a.moveBy(-2)) }] });
      }
      n2.removeChild(s2);
    }
  });
}
function Ja(t8, e2) {
  t8.walk((r2) => {
    let n2 = r2.$children;
    if (!n2) return;
    if (n2.length === 0 || n2.length === 1 && n2[0].type === "text" && O.trim(n2[0].value).length === 0) {
      r2.hasDanglingSpaces = n2.length > 0, r2.$children = [];
      return;
    }
    let s2 = Hn(r2, e2), i = Ar(r2);
    if (!s2) for (let a = 0; a < n2.length; a++) {
      let o2 = n2[a];
      if (o2.type !== "text") continue;
      let { leadingWhitespace: u, text: p, trailingWhitespace: l2 } = Mn(o2.value), m = o2.prev, f = o2.next;
      p ? (o2.value = p, o2.sourceSpan = new h(o2.sourceSpan.start.moveBy(u.length), o2.sourceSpan.end.moveBy(-l2.length)), u && (m && (m.hasTrailingSpaces = true), o2.hasLeadingSpaces = true), l2 && (o2.hasTrailingSpaces = true, f && (f.hasLeadingSpaces = true))) : (r2.removeChild(o2), a--, (u || l2) && (m && (m.hasTrailingSpaces = true), f && (f.hasLeadingSpaces = true)));
    }
    r2.isWhitespaceSensitive = s2, r2.isIndentationSensitive = i;
  });
}
function Za(t8) {
  t8.walk((e2) => {
    e2.isSelfClosing = !e2.children || e2.type === "element" && (e2.tagDefinition.isVoid || e2.endSourceSpan && e2.startSourceSpan.start === e2.endSourceSpan.start && e2.startSourceSpan.end === e2.endSourceSpan.end);
  });
}
function eo(t8, e2) {
  t8.walk((r2) => {
    r2.type === "element" && (r2.hasHtmComponentClosingTag = r2.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e2.originalText.slice(r2.endSourceSpan.start.offset, r2.endSourceSpan.end.offset)));
  });
}
function to(t8, e2) {
  t8.walk((r2) => {
    r2.cssDisplay = Qn(r2, e2);
  });
}
function ro(t8, e2) {
  t8.walk((r2) => {
    let { children: n2 } = r2;
    if (n2) {
      if (n2.length === 0) {
        r2.isDanglingSpaceSensitive = Wn(r2, e2);
        return;
      }
      for (let s2 of n2) s2.isLeadingSpaceSensitive = Vn(s2, e2), s2.isTrailingSpaceSensitive = Un(s2, e2);
      for (let s2 = 0; s2 < n2.length; s2++) {
        let i = n2[s2];
        i.isLeadingSpaceSensitive = (s2 === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s2 === n2.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
      }
    }
  });
}
var Ms = Ga;
function no(t8, e2, r2) {
  let { node: n2 } = t8;
  switch (n2.type) {
    case "front-matter":
      return B(n2.raw);
    case "root":
      return e2.__onHtmlRoot && e2.__onHtmlRoot(n2), [E(Re(t8, e2, r2)), S];
    case "element":
    case "ieConditionalComment":
      return Is(t8, e2, r2);
    case "angularControlFlowBlock":
      return Bs(t8, e2, r2);
    case "angularControlFlowBlockParameters":
      return Fs(t8, e2, r2);
    case "angularControlFlowBlockParameter":
      return O.trim(n2.expression);
    case "angularLetDeclaration":
      return E(["@let ", E([n2.id, " =", E(k([_, r2("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n2.value;
    case "angularIcuExpression":
      return Ps(t8, e2, r2);
    case "angularIcuCase":
      return Ns(t8, e2, r2);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [De(n2), Se(n2)];
    case "interpolation":
      return [De(n2, e2), ...t8.map(r2, "children"), Se(n2, e2)];
    case "text": {
      if (n2.parent.type === "interpolation") {
        let o2 = /\n[^\S\n]*$/u, u = o2.test(n2.value), p = u ? n2.value.replace(o2, "") : n2.value;
        return [B(p), u ? S : ""];
      }
      let s2 = z(n2, e2), i = kt(n2), a = G(n2, e2);
      return i[0] = [s2, i[0]], i.push([i.pop(), a]), vt(i);
    }
    case "docType":
      return [E([De(n2, e2), " ", w(false, n2.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), Se(n2, e2)];
    case "comment":
      return [z(n2, e2), B(e2.originalText.slice(J(n2), se(n2))), G(n2, e2)];
    case "attribute": {
      if (n2.value === null) return n2.rawName;
      let s2 = wr(n2.value), i = _n(s2, '"');
      return [n2.rawName, "=", i, B(i === '"' ? w(false, s2, '"', "&quot;") : w(false, s2, "'", "&apos;")), i];
    }
    case "cdata":
    default:
      throw new An(n2, "HTML");
  }
}
var so = { preprocess: Ms, print: no, insertPragma: Ts, massageAstNode: vn, embed: Ss, getVisitorKeys: As };
var qs = so;
var Hs = [{ name: "Angular", type: "markup", extensions: [".component.html"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", extensions: [], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", extensions: [".mjml"], tmScope: "text.mjml.basic", aceMode: "html", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", extensions: [".vue"], tmScope: "source.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }];
var Lr = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var Vs = "HTML";
var io = { bracketSameLine: Lr.bracketSameLine, htmlWhitespaceSensitivity: { category: Vs, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Lr.singleAttributePerLine, vueIndentScriptAndStyle: { category: Vs, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
var Us = io;
var tn = {};
ln(tn, { angular: () => iu, html: () => ru, lwc: () => ou, mjml: () => su, vue: () => au });
var ah = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
var Ws;
(function(t8) {
  t8[t8.Emulated = 0] = "Emulated", t8[t8.None = 2] = "None", t8[t8.ShadowDom = 3] = "ShadowDom";
})(Ws || (Ws = {}));
var Gs;
(function(t8) {
  t8[t8.OnPush = 0] = "OnPush", t8[t8.Default = 1] = "Default";
})(Gs || (Gs = {}));
var zs;
(function(t8) {
  t8[t8.None = 0] = "None", t8[t8.SignalBased = 1] = "SignalBased", t8[t8.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
})(zs || (zs = {}));
var Fr = { name: "custom-elements" };
var Pr = { name: "no-errors-schema" };
var Z;
(function(t8) {
  t8[t8.NONE = 0] = "NONE", t8[t8.HTML = 1] = "HTML", t8[t8.STYLE = 2] = "STYLE", t8[t8.SCRIPT = 3] = "SCRIPT", t8[t8.URL = 4] = "URL", t8[t8.RESOURCE_URL = 5] = "RESOURCE_URL";
})(Z || (Z = {}));
var Ys;
(function(t8) {
  t8[t8.Error = 0] = "Error", t8[t8.Warning = 1] = "Warning", t8[t8.Ignore = 2] = "Ignore";
})(Ys || (Ys = {}));
var N;
(function(t8) {
  t8[t8.RAW_TEXT = 0] = "RAW_TEXT", t8[t8.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t8[t8.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(N || (N = {}));
function ct(t8, e2 = true) {
  if (t8[0] != ":") return [null, t8];
  let r2 = t8.indexOf(":", 1);
  if (r2 === -1) {
    if (e2) throw new Error(`Unsupported format "${t8}" expecting ":namespace:name"`);
    return [null, t8];
  }
  return [t8.slice(1, r2), t8.slice(r2 + 1)];
}
function Nr(t8) {
  return ct(t8)[1] === "ng-container";
}
function Ir(t8) {
  return ct(t8)[1] === "ng-content";
}
function Me(t8) {
  return t8 === null ? null : ct(t8)[0];
}
function qe(t8, e2) {
  return t8 ? `:${t8}:${e2}` : e2;
}
var Ht;
function Rr() {
  return Ht || (Ht = {}, qt(Z.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), qt(Z.STYLE, ["*|style"]), qt(Z.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), qt(Z.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Ht;
}
function qt(t8, e2) {
  for (let r2 of e2) Ht[r2.toLowerCase()] = t8;
}
var Vt = class {
};
var ao = "boolean";
var oo = "number";
var uo = "string";
var lo = "object";
var co = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"];
var js = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }));
var po = Array.from(js).reduce((t8, [e2, r2]) => (t8.set(e2, r2), t8), /* @__PURE__ */ new Map());
var Ut = class extends Vt {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), co.forEach((e2) => {
      let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), [s2, i] = e2.split("|"), a = i.split(","), [o2, u] = s2.split("^");
      o2.split(",").forEach((l2) => {
        this._schema.set(l2.toLowerCase(), r2), this._eventSchema.set(l2.toLowerCase(), n2);
      });
      let p = u && this._schema.get(u.toLowerCase());
      if (p) {
        for (let [l2, m] of p) r2.set(l2, m);
        for (let l2 of this._eventSchema.get(u.toLowerCase())) n2.add(l2);
      }
      a.forEach((l2) => {
        if (l2.length > 0) switch (l2[0]) {
          case "*":
            n2.add(l2.substring(1));
            break;
          case "!":
            r2.set(l2.substring(1), ao);
            break;
          case "#":
            r2.set(l2.substring(1), oo);
            break;
          case "%":
            r2.set(l2.substring(1), lo);
            break;
          default:
            r2.set(l2, uo);
        }
      });
    });
  }
  hasProperty(e2, r2, n2) {
    if (n2.some((i) => i.name === Pr.name)) return true;
    if (e2.indexOf("-") > -1) {
      if (Nr(e2) || Ir(e2)) return false;
      if (n2.some((i) => i.name === Fr.name)) return true;
    }
    return (this._schema.get(e2.toLowerCase()) || this._schema.get("unknown")).has(r2);
  }
  hasElement(e2, r2) {
    return r2.some((n2) => n2.name === Pr.name) || e2.indexOf("-") > -1 && (Nr(e2) || Ir(e2) || r2.some((n2) => n2.name === Fr.name)) ? true : this._schema.has(e2.toLowerCase());
  }
  securityContext(e2, r2, n2) {
    n2 && (r2 = this.getMappedPropName(r2)), e2 = e2.toLowerCase(), r2 = r2.toLowerCase();
    let s2 = Rr()[e2 + "|" + r2];
    return s2 || (s2 = Rr()["*|" + r2], s2 || Z.NONE);
  }
  getMappedPropName(e2) {
    return js.get(e2) ?? e2;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e2) {
    return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...
If '${e2}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
  }
  validateAttribute(e2) {
    return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...` } : { error: false };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e2) {
    let r2 = this._schema.get(e2.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r2.keys()).map((n2) => po.get(n2) ?? n2);
  }
  allKnownEventsOfElement(e2) {
    return Array.from(this._eventSchema.get(e2.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e2) {
    return Os(e2);
  }
  normalizeAnimationStyleValue(e2, r2, n2) {
    let s2 = "", i = n2.toString().trim(), a = null;
    if (ho(e2) && n2 !== 0 && n2 !== "0") if (typeof n2 == "number") s2 = "px";
    else {
      let o2 = n2.match(/^[+-]?[\d\.]+([a-z]*)$/);
      o2 && o2[1].length == 0 && (a = `Please provide a CSS unit value for ${r2}:${n2}`);
    }
    return { error: a, value: i + s2 };
  }
};
function ho(t8) {
  switch (t8) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
var d = class {
  constructor({ closedByChildren: e2, implicitNamespacePrefix: r2, contentType: n2 = N.PARSABLE_DATA, closedByParent: s2 = false, isVoid: i = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o2 = false, canSelfClose: u = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e2 && e2.length > 0 && e2.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = s2 || i, this.implicitNamespacePrefix = r2 || null, this.contentType = n2, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o2, this.canSelfClose = u ?? i;
  }
  isClosedByChild(e2) {
    return this.isVoid || e2.toLowerCase() in this.closedByChildren;
  }
  getContentType(e2) {
    return typeof this.contentType == "object" ? (e2 === void 0 ? void 0 : this.contentType[e2]) ?? this.contentType.default : this.contentType;
  }
};
var Ks;
var pt;
function He(t8) {
  return pt || (Ks = new d({ canSelfClose: true }), pt = Object.assign(/* @__PURE__ */ Object.create(null), { base: new d({ isVoid: true }), meta: new d({ isVoid: true }), area: new d({ isVoid: true }), embed: new d({ isVoid: true }), link: new d({ isVoid: true }), img: new d({ isVoid: true }), input: new d({ isVoid: true }), param: new d({ isVoid: true }), hr: new d({ isVoid: true }), br: new d({ isVoid: true }), source: new d({ isVoid: true }), track: new d({ isVoid: true }), wbr: new d({ isVoid: true }), p: new d({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new d({ closedByChildren: ["tbody", "tfoot"] }), tbody: new d({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new d({ closedByChildren: ["tbody"], closedByParent: true }), tr: new d({ closedByChildren: ["tr"], closedByParent: true }), td: new d({ closedByChildren: ["td", "th"], closedByParent: true }), th: new d({ closedByChildren: ["td", "th"], closedByParent: true }), col: new d({ isVoid: true }), svg: new d({ implicitNamespacePrefix: "svg" }), foreignObject: new d({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new d({ implicitNamespacePrefix: "math" }), li: new d({ closedByChildren: ["li"], closedByParent: true }), dt: new d({ closedByChildren: ["dt", "dd"] }), dd: new d({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new d({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new d({ closedByChildren: ["optgroup"], closedByParent: true }), option: new d({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new d({ ignoreFirstLf: true }), listing: new d({ ignoreFirstLf: true }), style: new d({ contentType: N.RAW_TEXT }), script: new d({ contentType: N.RAW_TEXT }), title: new d({ contentType: { default: N.ESCAPABLE_RAW_TEXT, svg: N.PARSABLE_DATA } }), textarea: new d({ contentType: N.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Ut().allKnownElementNames().forEach((e2) => {
    !pt[e2] && Me(e2) === null && (pt[e2] = new d({ canSelfClose: false }));
  })), pt[t8] ?? Ks;
}
var ae = class {
  constructor(e2, r2) {
    this.sourceSpan = e2, this.i18n = r2;
  }
};
var Wt = class extends ae {
  constructor(e2, r2, n2, s2) {
    super(r2, s2), this.value = e2, this.tokens = n2, this.type = "text";
  }
  visit(e2, r2) {
    return e2.visitText(this, r2);
  }
};
var Gt = class extends ae {
  constructor(e2, r2, n2, s2) {
    super(r2, s2), this.value = e2, this.tokens = n2, this.type = "cdata";
  }
  visit(e2, r2) {
    return e2.visitCdata(this, r2);
  }
};
var zt = class extends ae {
  constructor(e2, r2, n2, s2, i, a) {
    super(s2, a), this.switchValue = e2, this.type = r2, this.cases = n2, this.switchValueSourceSpan = i;
  }
  visit(e2, r2) {
    return e2.visitExpansion(this, r2);
  }
};
var Yt = class {
  constructor(e2, r2, n2, s2, i) {
    this.value = e2, this.expression = r2, this.sourceSpan = n2, this.valueSourceSpan = s2, this.expSourceSpan = i, this.type = "expansionCase";
  }
  visit(e2, r2) {
    return e2.visitExpansionCase(this, r2);
  }
};
var jt = class extends ae {
  constructor(e2, r2, n2, s2, i, a, o2) {
    super(n2, o2), this.name = e2, this.value = r2, this.keySpan = s2, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
  }
  visit(e2, r2) {
    return e2.visitAttribute(this, r2);
  }
  get nameSpan() {
    return this.keySpan;
  }
};
var Y = class extends ae {
  constructor(e2, r2, n2, s2, i, a = null, o2 = null, u) {
    super(s2, u), this.name = e2, this.attrs = r2, this.children = n2, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o2, this.type = "element";
  }
  visit(e2, r2) {
    return e2.visitElement(this, r2);
  }
};
var Kt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "comment";
  }
  visit(e2, r2) {
    return e2.visitComment(this, r2);
  }
};
var Xt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "docType";
  }
  visit(e2, r2) {
    return e2.visitDocType(this, r2);
  }
};
var ee = class extends ae {
  constructor(e2, r2, n2, s2, i, a, o2 = null, u) {
    super(s2, u), this.name = e2, this.parameters = r2, this.children = n2, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o2, this.type = "block";
  }
  visit(e2, r2) {
    return e2.visitBlock(this, r2);
  }
};
var ht = class {
  constructor(e2, r2) {
    this.expression = e2, this.sourceSpan = r2, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitBlockParameter(this, r2);
  }
};
var mt = class {
  constructor(e2, r2, n2, s2, i) {
    this.name = e2, this.value = r2, this.sourceSpan = n2, this.nameSpan = s2, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitLetDeclaration(this, r2);
  }
};
function Qt(t8, e2, r2 = null) {
  let n2 = [], s2 = t8.visit ? (i) => t8.visit(i, r2) || i.visit(t8, r2) : (i) => i.visit(t8, r2);
  return e2.forEach((i) => {
    let a = s2(i);
    a && n2.push(a);
  }), n2;
}
var ft = class {
  constructor() {
  }
  visitElement(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.attrs), n2(e2.children);
    });
  }
  visitAttribute(e2, r2) {
  }
  visitText(e2, r2) {
  }
  visitCdata(e2, r2) {
  }
  visitComment(e2, r2) {
  }
  visitDocType(e2, r2) {
  }
  visitExpansion(e2, r2) {
    return this.visitChildren(r2, (n2) => {
      n2(e2.cases);
    });
  }
  visitExpansionCase(e2, r2) {
  }
  visitBlock(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.parameters), n2(e2.children);
    });
  }
  visitBlockParameter(e2, r2) {
  }
  visitLetDeclaration(e2, r2) {
  }
  visitChildren(e2, r2) {
    let n2 = [], s2 = this;
    function i(a) {
      a && n2.push(Qt(s2, a, e2));
    }
    return r2(i), Array.prototype.concat.apply([], n2);
  }
};
var Ve = { AElig: "Æ", AMP: "&", amp: "&", Aacute: "Á", Abreve: "Ă", Acirc: "Â", Acy: "А", Afr: "𝔄", Agrave: "À", Alpha: "Α", Amacr: "Ā", And: "⩓", Aogon: "Ą", Aopf: "𝔸", ApplyFunction: "⁡", af: "⁡", Aring: "Å", angst: "Å", Ascr: "𝒜", Assign: "≔", colone: "≔", coloneq: "≔", Atilde: "Ã", Auml: "Ä", Backslash: "∖", setminus: "∖", setmn: "∖", smallsetminus: "∖", ssetmn: "∖", Barv: "⫧", Barwed: "⌆", doublebarwedge: "⌆", Bcy: "Б", Because: "∵", becaus: "∵", because: "∵", Bernoullis: "ℬ", Bscr: "ℬ", bernou: "ℬ", Beta: "Β", Bfr: "𝔅", Bopf: "𝔹", Breve: "˘", breve: "˘", Bumpeq: "≎", HumpDownHump: "≎", bump: "≎", CHcy: "Ч", COPY: "©", copy: "©", Cacute: "Ć", Cap: "⋒", CapitalDifferentialD: "ⅅ", DD: "ⅅ", Cayleys: "ℭ", Cfr: "ℭ", Ccaron: "Č", Ccedil: "Ç", Ccirc: "Ĉ", Cconint: "∰", Cdot: "Ċ", Cedilla: "¸", cedil: "¸", CenterDot: "·", centerdot: "·", middot: "·", Chi: "Χ", CircleDot: "⊙", odot: "⊙", CircleMinus: "⊖", ominus: "⊖", CirclePlus: "⊕", oplus: "⊕", CircleTimes: "⊗", otimes: "⊗", ClockwiseContourIntegral: "∲", cwconint: "∲", CloseCurlyDoubleQuote: "”", rdquo: "”", rdquor: "”", CloseCurlyQuote: "’", rsquo: "’", rsquor: "’", Colon: "∷", Proportion: "∷", Colone: "⩴", Congruent: "≡", equiv: "≡", Conint: "∯", DoubleContourIntegral: "∯", ContourIntegral: "∮", conint: "∮", oint: "∮", Copf: "ℂ", complexes: "ℂ", Coproduct: "∐", coprod: "∐", CounterClockwiseContourIntegral: "∳", awconint: "∳", Cross: "⨯", Cscr: "𝒞", Cup: "⋓", CupCap: "≍", asympeq: "≍", DDotrahd: "⤑", DJcy: "Ђ", DScy: "Ѕ", DZcy: "Џ", Dagger: "‡", ddagger: "‡", Darr: "↡", Dashv: "⫤", DoubleLeftTee: "⫤", Dcaron: "Ď", Dcy: "Д", Del: "∇", nabla: "∇", Delta: "Δ", Dfr: "𝔇", DiacriticalAcute: "´", acute: "´", DiacriticalDot: "˙", dot: "˙", DiacriticalDoubleAcute: "˝", dblac: "˝", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "˜", tilde: "˜", Diamond: "⋄", diam: "⋄", diamond: "⋄", DifferentialD: "ⅆ", dd: "ⅆ", Dopf: "𝔻", Dot: "¨", DoubleDot: "¨", die: "¨", uml: "¨", DotDot: "⃜", DotEqual: "≐", doteq: "≐", esdot: "≐", DoubleDownArrow: "⇓", Downarrow: "⇓", dArr: "⇓", DoubleLeftArrow: "⇐", Leftarrow: "⇐", lArr: "⇐", DoubleLeftRightArrow: "⇔", Leftrightarrow: "⇔", hArr: "⇔", iff: "⇔", DoubleLongLeftArrow: "⟸", Longleftarrow: "⟸", xlArr: "⟸", DoubleLongLeftRightArrow: "⟺", Longleftrightarrow: "⟺", xhArr: "⟺", DoubleLongRightArrow: "⟹", Longrightarrow: "⟹", xrArr: "⟹", DoubleRightArrow: "⇒", Implies: "⇒", Rightarrow: "⇒", rArr: "⇒", DoubleRightTee: "⊨", vDash: "⊨", DoubleUpArrow: "⇑", Uparrow: "⇑", uArr: "⇑", DoubleUpDownArrow: "⇕", Updownarrow: "⇕", vArr: "⇕", DoubleVerticalBar: "∥", par: "∥", parallel: "∥", shortparallel: "∥", spar: "∥", DownArrow: "↓", ShortDownArrow: "↓", darr: "↓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", duarr: "⇵", DownBreve: "̑", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", leftharpoondown: "↽", lhard: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", rhard: "⇁", rightharpoondown: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", top: "⊤", DownTeeArrow: "↧", mapstodown: "↧", Dscr: "𝒟", Dstrok: "Đ", ENG: "Ŋ", ETH: "Ð", Eacute: "É", Ecaron: "Ě", Ecirc: "Ê", Ecy: "Э", Edot: "Ė", Efr: "𝔈", Egrave: "È", Element: "∈", in: "∈", isin: "∈", isinv: "∈", Emacr: "Ē", EmptySmallSquare: "◻", EmptyVerySmallSquare: "▫", Eogon: "Ę", Eopf: "𝔼", Epsilon: "Ε", Equal: "⩵", EqualTilde: "≂", eqsim: "≂", esim: "≂", Equilibrium: "⇌", rightleftharpoons: "⇌", rlhar: "⇌", Escr: "ℰ", expectation: "ℰ", Esim: "⩳", Eta: "Η", Euml: "Ë", Exists: "∃", exist: "∃", ExponentialE: "ⅇ", ee: "ⅇ", exponentiale: "ⅇ", Fcy: "Ф", Ffr: "𝔉", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", blacksquare: "▪", squarf: "▪", squf: "▪", Fopf: "𝔽", ForAll: "∀", forall: "∀", Fouriertrf: "ℱ", Fscr: "ℱ", GJcy: "Ѓ", GT: ">", gt: ">", Gamma: "Γ", Gammad: "Ϝ", Gbreve: "Ğ", Gcedil: "Ģ", Gcirc: "Ĝ", Gcy: "Г", Gdot: "Ġ", Gfr: "𝔊", Gg: "⋙", ggg: "⋙", Gopf: "𝔾", GreaterEqual: "≥", ge: "≥", geq: "≥", GreaterEqualLess: "⋛", gel: "⋛", gtreqless: "⋛", GreaterFullEqual: "≧", gE: "≧", geqq: "≧", GreaterGreater: "⪢", GreaterLess: "≷", gl: "≷", gtrless: "≷", GreaterSlantEqual: "⩾", geqslant: "⩾", ges: "⩾", GreaterTilde: "≳", gsim: "≳", gtrsim: "≳", Gscr: "𝒢", Gt: "≫", NestedGreaterGreater: "≫", gg: "≫", HARDcy: "Ъ", Hacek: "ˇ", caron: "ˇ", Hat: "^", Hcirc: "Ĥ", Hfr: "ℌ", Poincareplane: "ℌ", HilbertSpace: "ℋ", Hscr: "ℋ", hamilt: "ℋ", Hopf: "ℍ", quaternions: "ℍ", HorizontalLine: "─", boxh: "─", Hstrok: "Ħ", HumpEqual: "≏", bumpe: "≏", bumpeq: "≏", IEcy: "Е", IJlig: "Ĳ", IOcy: "Ё", Iacute: "Í", Icirc: "Î", Icy: "И", Idot: "İ", Ifr: "ℑ", Im: "ℑ", image: "ℑ", imagpart: "ℑ", Igrave: "Ì", Imacr: "Ī", ImaginaryI: "ⅈ", ii: "ⅈ", Int: "∬", Integral: "∫", int: "∫", Intersection: "⋂", bigcap: "⋂", xcap: "⋂", InvisibleComma: "⁣", ic: "⁣", InvisibleTimes: "⁢", it: "⁢", Iogon: "Į", Iopf: "𝕀", Iota: "Ι", Iscr: "ℐ", imagline: "ℐ", Itilde: "Ĩ", Iukcy: "І", Iuml: "Ï", Jcirc: "Ĵ", Jcy: "Й", Jfr: "𝔍", Jopf: "𝕁", Jscr: "𝒥", Jsercy: "Ј", Jukcy: "Є", KHcy: "Х", KJcy: "Ќ", Kappa: "Κ", Kcedil: "Ķ", Kcy: "К", Kfr: "𝔎", Kopf: "𝕂", Kscr: "𝒦", LJcy: "Љ", LT: "<", lt: "<", Lacute: "Ĺ", Lambda: "Λ", Lang: "⟪", Laplacetrf: "ℒ", Lscr: "ℒ", lagran: "ℒ", Larr: "↞", twoheadleftarrow: "↞", Lcaron: "Ľ", Lcedil: "Ļ", Lcy: "Л", LeftAngleBracket: "⟨", lang: "⟨", langle: "⟨", LeftArrow: "←", ShortLeftArrow: "←", larr: "←", leftarrow: "←", slarr: "←", LeftArrowBar: "⇤", larrb: "⇤", LeftArrowRightArrow: "⇆", leftrightarrows: "⇆", lrarr: "⇆", LeftCeiling: "⌈", lceil: "⌈", LeftDoubleBracket: "⟦", lobrk: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", dharl: "⇃", downharpoonleft: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", lfloor: "⌊", LeftRightArrow: "↔", harr: "↔", leftrightarrow: "↔", LeftRightVector: "⥎", LeftTee: "⊣", dashv: "⊣", LeftTeeArrow: "↤", mapstoleft: "↤", LeftTeeVector: "⥚", LeftTriangle: "⊲", vartriangleleft: "⊲", vltri: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", ltrie: "⊴", trianglelefteq: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", uharl: "↿", upharpoonleft: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", leftharpoonup: "↼", lharu: "↼", LeftVectorBar: "⥒", LessEqualGreater: "⋚", leg: "⋚", lesseqgtr: "⋚", LessFullEqual: "≦", lE: "≦", leqq: "≦", LessGreater: "≶", lessgtr: "≶", lg: "≶", LessLess: "⪡", LessSlantEqual: "⩽", leqslant: "⩽", les: "⩽", LessTilde: "≲", lesssim: "≲", lsim: "≲", Lfr: "𝔏", Ll: "⋘", Lleftarrow: "⇚", lAarr: "⇚", Lmidot: "Ŀ", LongLeftArrow: "⟵", longleftarrow: "⟵", xlarr: "⟵", LongLeftRightArrow: "⟷", longleftrightarrow: "⟷", xharr: "⟷", LongRightArrow: "⟶", longrightarrow: "⟶", xrarr: "⟶", Lopf: "𝕃", LowerLeftArrow: "↙", swarr: "↙", swarrow: "↙", LowerRightArrow: "↘", searr: "↘", searrow: "↘", Lsh: "↰", lsh: "↰", Lstrok: "Ł", Lt: "≪", NestedLessLess: "≪", ll: "≪", Map: "⤅", Mcy: "М", MediumSpace: " ", Mellintrf: "ℳ", Mscr: "ℳ", phmmat: "ℳ", Mfr: "𝔐", MinusPlus: "∓", mnplus: "∓", mp: "∓", Mopf: "𝕄", Mu: "Μ", NJcy: "Њ", Nacute: "Ń", Ncaron: "Ň", Ncedil: "Ņ", Ncy: "Н", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", ZeroWidthSpace: "​", NewLine: `
`, Nfr: "𝔑", NoBreak: "⁠", NonBreakingSpace: " ", nbsp: " ", Nopf: "ℕ", naturals: "ℕ", Not: "⫬", NotCongruent: "≢", nequiv: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", npar: "∦", nparallel: "∦", nshortparallel: "∦", nspar: "∦", NotElement: "∉", notin: "∉", notinva: "∉", NotEqual: "≠", ne: "≠", NotEqualTilde: "≂̸", nesim: "≂̸", NotExists: "∄", nexist: "∄", nexists: "∄", NotGreater: "≯", ngt: "≯", ngtr: "≯", NotGreaterEqual: "≱", nge: "≱", ngeq: "≱", NotGreaterFullEqual: "≧̸", ngE: "≧̸", ngeqq: "≧̸", NotGreaterGreater: "≫̸", nGtv: "≫̸", NotGreaterLess: "≹", ntgl: "≹", NotGreaterSlantEqual: "⩾̸", ngeqslant: "⩾̸", nges: "⩾̸", NotGreaterTilde: "≵", ngsim: "≵", NotHumpDownHump: "≎̸", nbump: "≎̸", NotHumpEqual: "≏̸", nbumpe: "≏̸", NotLeftTriangle: "⋪", nltri: "⋪", ntriangleleft: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", nltrie: "⋬", ntrianglelefteq: "⋬", NotLess: "≮", nless: "≮", nlt: "≮", NotLessEqual: "≰", nle: "≰", nleq: "≰", NotLessGreater: "≸", ntlg: "≸", NotLessLess: "≪̸", nLtv: "≪̸", NotLessSlantEqual: "⩽̸", nleqslant: "⩽̸", nles: "⩽̸", NotLessTilde: "≴", nlsim: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", NotPrecedes: "⊀", npr: "⊀", nprec: "⊀", NotPrecedesEqual: "⪯̸", npre: "⪯̸", npreceq: "⪯̸", NotPrecedesSlantEqual: "⋠", nprcue: "⋠", NotReverseElement: "∌", notni: "∌", notniva: "∌", NotRightTriangle: "⋫", nrtri: "⋫", ntriangleright: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", nrtrie: "⋭", ntrianglerighteq: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", nsqsube: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", nsqsupe: "⋣", NotSubset: "⊂⃒", nsubset: "⊂⃒", vnsub: "⊂⃒", NotSubsetEqual: "⊈", nsube: "⊈", nsubseteq: "⊈", NotSucceeds: "⊁", nsc: "⊁", nsucc: "⊁", NotSucceedsEqual: "⪰̸", nsce: "⪰̸", nsucceq: "⪰̸", NotSucceedsSlantEqual: "⋡", nsccue: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", nsupset: "⊃⃒", vnsup: "⊃⃒", NotSupersetEqual: "⊉", nsupe: "⊉", nsupseteq: "⊉", NotTilde: "≁", nsim: "≁", NotTildeEqual: "≄", nsime: "≄", nsimeq: "≄", NotTildeFullEqual: "≇", ncong: "≇", NotTildeTilde: "≉", nap: "≉", napprox: "≉", NotVerticalBar: "∤", nmid: "∤", nshortmid: "∤", nsmid: "∤", Nscr: "𝒩", Ntilde: "Ñ", Nu: "Ν", OElig: "Œ", Oacute: "Ó", Ocirc: "Ô", Ocy: "О", Odblac: "Ő", Ofr: "𝔒", Ograve: "Ò", Omacr: "Ō", Omega: "Ω", ohm: "Ω", Omicron: "Ο", Oopf: "𝕆", OpenCurlyDoubleQuote: "“", ldquo: "“", OpenCurlyQuote: "‘", lsquo: "‘", Or: "⩔", Oscr: "𝒪", Oslash: "Ø", Otilde: "Õ", Otimes: "⨷", Ouml: "Ö", OverBar: "‾", oline: "‾", OverBrace: "⏞", OverBracket: "⎴", tbrk: "⎴", OverParenthesis: "⏜", PartialD: "∂", part: "∂", Pcy: "П", Pfr: "𝔓", Phi: "Φ", Pi: "Π", PlusMinus: "±", plusmn: "±", pm: "±", Popf: "ℙ", primes: "ℙ", Pr: "⪻", Precedes: "≺", pr: "≺", prec: "≺", PrecedesEqual: "⪯", pre: "⪯", preceq: "⪯", PrecedesSlantEqual: "≼", prcue: "≼", preccurlyeq: "≼", PrecedesTilde: "≾", precsim: "≾", prsim: "≾", Prime: "″", Product: "∏", prod: "∏", Proportional: "∝", prop: "∝", propto: "∝", varpropto: "∝", vprop: "∝", Pscr: "𝒫", Psi: "Ψ", QUOT: '"', quot: '"', Qfr: "𝔔", Qopf: "ℚ", rationals: "ℚ", Qscr: "𝒬", RBarr: "⤐", drbkarow: "⤐", REG: "®", circledR: "®", reg: "®", Racute: "Ŕ", Rang: "⟫", Rarr: "↠", twoheadrightarrow: "↠", Rarrtl: "⤖", Rcaron: "Ř", Rcedil: "Ŗ", Rcy: "Р", Re: "ℜ", Rfr: "ℜ", real: "ℜ", realpart: "ℜ", ReverseElement: "∋", SuchThat: "∋", ni: "∋", niv: "∋", ReverseEquilibrium: "⇋", leftrightharpoons: "⇋", lrhar: "⇋", ReverseUpEquilibrium: "⥯", duhar: "⥯", Rho: "Ρ", RightAngleBracket: "⟩", rang: "⟩", rangle: "⟩", RightArrow: "→", ShortRightArrow: "→", rarr: "→", rightarrow: "→", srarr: "→", RightArrowBar: "⇥", rarrb: "⇥", RightArrowLeftArrow: "⇄", rightleftarrows: "⇄", rlarr: "⇄", RightCeiling: "⌉", rceil: "⌉", RightDoubleBracket: "⟧", robrk: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", dharr: "⇂", downharpoonright: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rfloor: "⌋", RightTee: "⊢", vdash: "⊢", RightTeeArrow: "↦", map: "↦", mapsto: "↦", RightTeeVector: "⥛", RightTriangle: "⊳", vartriangleright: "⊳", vrtri: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", rtrie: "⊵", trianglerighteq: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", uharr: "↾", upharpoonright: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", rharu: "⇀", rightharpoonup: "⇀", RightVectorBar: "⥓", Ropf: "ℝ", reals: "ℝ", RoundImplies: "⥰", Rrightarrow: "⇛", rAarr: "⇛", Rscr: "ℛ", realine: "ℛ", Rsh: "↱", rsh: "↱", RuleDelayed: "⧴", SHCHcy: "Щ", SHcy: "Ш", SOFTcy: "Ь", Sacute: "Ś", Sc: "⪼", Scaron: "Š", Scedil: "Ş", Scirc: "Ŝ", Scy: "С", Sfr: "𝔖", ShortUpArrow: "↑", UpArrow: "↑", uarr: "↑", uparrow: "↑", Sigma: "Σ", SmallCircle: "∘", compfn: "∘", Sopf: "𝕊", Sqrt: "√", radic: "√", Square: "□", squ: "□", square: "□", SquareIntersection: "⊓", sqcap: "⊓", SquareSubset: "⊏", sqsub: "⊏", sqsubset: "⊏", SquareSubsetEqual: "⊑", sqsube: "⊑", sqsubseteq: "⊑", SquareSuperset: "⊐", sqsup: "⊐", sqsupset: "⊐", SquareSupersetEqual: "⊒", sqsupe: "⊒", sqsupseteq: "⊒", SquareUnion: "⊔", sqcup: "⊔", Sscr: "𝒮", Star: "⋆", sstarf: "⋆", Sub: "⋐", Subset: "⋐", SubsetEqual: "⊆", sube: "⊆", subseteq: "⊆", Succeeds: "≻", sc: "≻", succ: "≻", SucceedsEqual: "⪰", sce: "⪰", succeq: "⪰", SucceedsSlantEqual: "≽", sccue: "≽", succcurlyeq: "≽", SucceedsTilde: "≿", scsim: "≿", succsim: "≿", Sum: "∑", sum: "∑", Sup: "⋑", Supset: "⋑", Superset: "⊃", sup: "⊃", supset: "⊃", SupersetEqual: "⊇", supe: "⊇", supseteq: "⊇", THORN: "Þ", TRADE: "™", trade: "™", TSHcy: "Ћ", TScy: "Ц", Tab: "	", Tau: "Τ", Tcaron: "Ť", Tcedil: "Ţ", Tcy: "Т", Tfr: "𝔗", Therefore: "∴", there4: "∴", therefore: "∴", Theta: "Θ", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", Tilde: "∼", sim: "∼", thicksim: "∼", thksim: "∼", TildeEqual: "≃", sime: "≃", simeq: "≃", TildeFullEqual: "≅", cong: "≅", TildeTilde: "≈", ap: "≈", approx: "≈", asymp: "≈", thickapprox: "≈", thkap: "≈", Topf: "𝕋", TripleDot: "⃛", tdot: "⃛", Tscr: "𝒯", Tstrok: "Ŧ", Uacute: "Ú", Uarr: "↟", Uarrocir: "⥉", Ubrcy: "Ў", Ubreve: "Ŭ", Ucirc: "Û", Ucy: "У", Udblac: "Ű", Ufr: "𝔘", Ugrave: "Ù", Umacr: "Ū", UnderBar: "_", lowbar: "_", UnderBrace: "⏟", UnderBracket: "⎵", bbrk: "⎵", UnderParenthesis: "⏝", Union: "⋃", bigcup: "⋃", xcup: "⋃", UnionPlus: "⊎", uplus: "⊎", Uogon: "Ų", Uopf: "𝕌", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", udarr: "⇅", UpDownArrow: "↕", updownarrow: "↕", varr: "↕", UpEquilibrium: "⥮", udhar: "⥮", UpTee: "⊥", bot: "⊥", bottom: "⊥", perp: "⊥", UpTeeArrow: "↥", mapstoup: "↥", UpperLeftArrow: "↖", nwarr: "↖", nwarrow: "↖", UpperRightArrow: "↗", nearr: "↗", nearrow: "↗", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", Uring: "Ů", Uscr: "𝒰", Utilde: "Ũ", Uuml: "Ü", VDash: "⊫", Vbar: "⫫", Vcy: "В", Vdash: "⊩", Vdashl: "⫦", Vee: "⋁", bigvee: "⋁", xvee: "⋁", Verbar: "‖", Vert: "‖", VerticalBar: "∣", mid: "∣", shortmid: "∣", smid: "∣", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "❘", VerticalTilde: "≀", wr: "≀", wreath: "≀", VeryThinSpace: " ", hairsp: " ", Vfr: "𝔙", Vopf: "𝕍", Vscr: "𝒱", Vvdash: "⊪", Wcirc: "Ŵ", Wedge: "⋀", bigwedge: "⋀", xwedge: "⋀", Wfr: "𝔚", Wopf: "𝕎", Wscr: "𝒲", Xfr: "𝔛", Xi: "Ξ", Xopf: "𝕏", Xscr: "𝒳", YAcy: "Я", YIcy: "Ї", YUcy: "Ю", Yacute: "Ý", Ycirc: "Ŷ", Ycy: "Ы", Yfr: "𝔜", Yopf: "𝕐", Yscr: "𝒴", Yuml: "Ÿ", ZHcy: "Ж", Zacute: "Ź", Zcaron: "Ž", Zcy: "З", Zdot: "Ż", Zeta: "Ζ", Zfr: "ℨ", zeetrf: "ℨ", Zopf: "ℤ", integers: "ℤ", Zscr: "𝒵", aacute: "á", abreve: "ă", ac: "∾", mstpos: "∾", acE: "∾̳", acd: "∿", acirc: "â", acy: "а", aelig: "æ", afr: "𝔞", agrave: "à", alefsym: "ℵ", aleph: "ℵ", alpha: "α", amacr: "ā", amalg: "⨿", and: "∧", wedge: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", angle: "∠", ange: "⦤", angmsd: "∡", measuredangle: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angzarr: "⍼", aogon: "ą", aopf: "𝕒", apE: "⩰", apacir: "⩯", ape: "≊", approxeq: "≊", apid: "≋", apos: "'", aring: "å", ascr: "𝒶", ast: "*", midast: "*", atilde: "ã", auml: "ä", awint: "⨑", bNot: "⫭", backcong: "≌", bcong: "≌", backepsilon: "϶", bepsi: "϶", backprime: "‵", bprime: "‵", backsim: "∽", bsim: "∽", backsimeq: "⋍", bsime: "⋍", barvee: "⊽", barwed: "⌅", barwedge: "⌅", bbrktbrk: "⎶", bcy: "б", bdquo: "„", ldquor: "„", bemptyv: "⦰", beta: "β", beth: "ℶ", between: "≬", twixt: "≬", bfr: "𝔟", bigcirc: "◯", xcirc: "◯", bigodot: "⨀", xodot: "⨀", bigoplus: "⨁", xoplus: "⨁", bigotimes: "⨂", xotime: "⨂", bigsqcup: "⨆", xsqcup: "⨆", bigstar: "★", starf: "★", bigtriangledown: "▽", xdtri: "▽", bigtriangleup: "△", xutri: "△", biguplus: "⨄", xuplus: "⨄", bkarow: "⤍", rbarr: "⤍", blacklozenge: "⧫", lozf: "⧫", blacktriangle: "▴", utrif: "▴", blacktriangledown: "▾", dtrif: "▾", blacktriangleleft: "◂", ltrif: "◂", blacktriangleright: "▸", rtrif: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bnot: "⌐", bopf: "𝕓", bowtie: "⋈", boxDL: "╗", boxDR: "╔", boxDl: "╖", boxDr: "╓", boxH: "═", boxHD: "╦", boxHU: "╩", boxHd: "╤", boxHu: "╧", boxUL: "╝", boxUR: "╚", boxUl: "╜", boxUr: "╙", boxV: "║", boxVH: "╬", boxVL: "╣", boxVR: "╠", boxVh: "╫", boxVl: "╢", boxVr: "╟", boxbox: "⧉", boxdL: "╕", boxdR: "╒", boxdl: "┐", boxdr: "┌", boxhD: "╥", boxhU: "╨", boxhd: "┬", boxhu: "┴", boxminus: "⊟", minusb: "⊟", boxplus: "⊞", plusb: "⊞", boxtimes: "⊠", timesb: "⊠", boxuL: "╛", boxuR: "╘", boxul: "┘", boxur: "└", boxv: "│", boxvH: "╪", boxvL: "╡", boxvR: "╞", boxvh: "┼", boxvl: "┤", boxvr: "├", brvbar: "¦", bscr: "𝒷", bsemi: "⁏", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bumpE: "⪮", cacute: "ć", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", caps: "∩︀", caret: "⁁", ccaps: "⩍", ccaron: "č", ccedil: "ç", ccirc: "ĉ", ccups: "⩌", ccupssm: "⩐", cdot: "ċ", cemptyv: "⦲", cent: "¢", cfr: "𝔠", chcy: "ч", check: "✓", checkmark: "✓", chi: "χ", cir: "○", cirE: "⧃", circ: "ˆ", circeq: "≗", cire: "≗", circlearrowleft: "↺", olarr: "↺", circlearrowright: "↻", orarr: "↻", circledS: "Ⓢ", oS: "Ⓢ", circledast: "⊛", oast: "⊛", circledcirc: "⊚", ocir: "⊚", circleddash: "⊝", odash: "⊝", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", clubs: "♣", clubsuit: "♣", colon: ":", comma: ",", commat: "@", comp: "∁", complement: "∁", congdot: "⩭", copf: "𝕔", copysr: "℗", crarr: "↵", cross: "✗", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", curlyeqprec: "⋞", cuesc: "⋟", curlyeqsucc: "⋟", cularr: "↶", curvearrowleft: "↶", cularrp: "⤽", cup: "∪", cupbrcap: "⩈", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curvearrowright: "↷", curarrm: "⤼", curlyvee: "⋎", cuvee: "⋎", curlywedge: "⋏", cuwed: "⋏", curren: "¤", cwint: "∱", cylcty: "⌭", dHar: "⥥", dagger: "†", daleth: "ℸ", dash: "‐", hyphen: "‐", dbkarow: "⤏", rBarr: "⤏", dcaron: "ď", dcy: "д", ddarr: "⇊", downdownarrows: "⇊", ddotseq: "⩷", eDDot: "⩷", deg: "°", delta: "δ", demptyv: "⦱", dfisht: "⥿", dfr: "𝔡", diamondsuit: "♦", diams: "♦", digamma: "ϝ", gammad: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", djcy: "ђ", dlcorn: "⌞", llcorner: "⌞", dlcrop: "⌍", dollar: "$", dopf: "𝕕", doteqdot: "≑", eDot: "≑", dotminus: "∸", minusd: "∸", dotplus: "∔", plusdo: "∔", dotsquare: "⊡", sdotb: "⊡", drcorn: "⌟", lrcorner: "⌟", drcrop: "⌌", dscr: "𝒹", dscy: "ѕ", dsol: "⧶", dstrok: "đ", dtdot: "⋱", dtri: "▿", triangledown: "▿", dwangle: "⦦", dzcy: "џ", dzigrarr: "⟿", eacute: "é", easter: "⩮", ecaron: "ě", ecir: "≖", eqcirc: "≖", ecirc: "ê", ecolon: "≕", eqcolon: "≕", ecy: "э", edot: "ė", efDot: "≒", fallingdotseq: "≒", efr: "𝔢", eg: "⪚", egrave: "è", egs: "⪖", eqslantgtr: "⪖", egsdot: "⪘", el: "⪙", elinters: "⏧", ell: "ℓ", els: "⪕", eqslantless: "⪕", elsdot: "⪗", emacr: "ē", empty: "∅", emptyset: "∅", emptyv: "∅", varnothing: "∅", emsp13: " ", emsp14: " ", emsp: " ", eng: "ŋ", ensp: " ", eogon: "ę", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", epsilon: "ε", epsiv: "ϵ", straightepsilon: "ϵ", varepsilon: "ϵ", equals: "=", equest: "≟", questeq: "≟", equivDD: "⩸", eqvparsl: "⧥", erDot: "≓", risingdotseq: "≓", erarr: "⥱", escr: "ℯ", eta: "η", eth: "ð", euml: "ë", euro: "€", excl: "!", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", ffr: "𝔣", filig: "ﬁ", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", fopf: "𝕗", fork: "⋔", pitchfork: "⋔", forkv: "⫙", fpartint: "⨍", frac12: "½", half: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", sfrown: "⌢", fscr: "𝒻", gEl: "⪌", gtreqqless: "⪌", gacute: "ǵ", gamma: "γ", gap: "⪆", gtrapprox: "⪆", gbreve: "ğ", gcirc: "ĝ", gcy: "г", gdot: "ġ", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", gfr: "𝔤", gimel: "ℷ", gjcy: "ѓ", glE: "⪒", gla: "⪥", glj: "⪤", gnE: "≩", gneqq: "≩", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gneq: "⪈", gnsim: "⋧", gopf: "𝕘", gscr: "ℊ", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtrdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrarr: "⥸", gvertneqq: "≩︀", gvnE: "≩︀", hardcy: "ъ", harrcir: "⥈", harrw: "↭", leftrightsquigarrow: "↭", hbar: "ℏ", hslash: "ℏ", planck: "ℏ", plankv: "ℏ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", mldr: "…", hercon: "⊹", hfr: "𝔥", hksearow: "⤥", searhk: "⤥", hkswarow: "⤦", swarhk: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", larrhk: "↩", hookrightarrow: "↪", rarrhk: "↪", hopf: "𝕙", horbar: "―", hscr: "𝒽", hstrok: "ħ", hybull: "⁃", iacute: "í", icirc: "î", icy: "и", iecy: "е", iexcl: "¡", ifr: "𝔦", igrave: "ì", iiiint: "⨌", qint: "⨌", iiint: "∭", tint: "∭", iinfin: "⧜", iiota: "℩", ijlig: "ĳ", imacr: "ī", imath: "ı", inodot: "ı", imof: "⊷", imped: "Ƶ", incare: "℅", infin: "∞", infintie: "⧝", intcal: "⊺", intercal: "⊺", intlarhk: "⨗", intprod: "⨼", iprod: "⨼", iocy: "ё", iogon: "į", iopf: "𝕚", iota: "ι", iquest: "¿", iscr: "𝒾", isinE: "⋹", isindot: "⋵", isins: "⋴", isinsv: "⋳", itilde: "ĩ", iukcy: "і", iuml: "ï", jcirc: "ĵ", jcy: "й", jfr: "𝔧", jmath: "ȷ", jopf: "𝕛", jscr: "𝒿", jsercy: "ј", jukcy: "є", kappa: "κ", kappav: "ϰ", varkappa: "ϰ", kcedil: "ķ", kcy: "к", kfr: "𝔨", kgreen: "ĸ", khcy: "х", kjcy: "ќ", kopf: "𝕜", kscr: "𝓀", lAtail: "⤛", lBarr: "⤎", lEg: "⪋", lesseqqgtr: "⪋", lHar: "⥢", lacute: "ĺ", laemptyv: "⦴", lambda: "λ", langd: "⦑", lap: "⪅", lessapprox: "⪅", laquo: "«", larrbfs: "⤟", larrfs: "⤝", larrlp: "↫", looparrowleft: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", leftarrowtail: "↢", lat: "⪫", latail: "⤙", late: "⪭", lates: "⪭︀", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", lcaron: "ľ", lcedil: "ļ", lcy: "л", ldca: "⤶", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", leq: "≤", leftleftarrows: "⇇", llarr: "⇇", leftthreetimes: "⋋", lthree: "⋋", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessdot: "⋖", ltdot: "⋖", lfisht: "⥼", lfr: "𝔩", lgE: "⪑", lharul: "⥪", lhblk: "▄", ljcy: "љ", llhard: "⥫", lltri: "◺", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnE: "≨", lneqq: "≨", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lneq: "⪇", lnsim: "⋦", loang: "⟬", loarr: "⇽", longmapsto: "⟼", xmap: "⟼", looparrowright: "↬", rarrlp: "↬", lopar: "⦅", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", loz: "◊", lozenge: "◊", lpar: "(", lparlt: "⦓", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", lsime: "⪍", lsimg: "⪏", lsquor: "‚", sbquo: "‚", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltrPar: "⦖", ltri: "◃", triangleleft: "◃", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", mDDot: "∺", macr: "¯", strns: "¯", male: "♂", malt: "✠", maltese: "✠", marker: "▮", mcomma: "⨩", mcy: "м", mdash: "—", mfr: "𝔪", mho: "℧", micro: "µ", midcir: "⫰", minus: "−", minusdu: "⨪", mlcp: "⫛", models: "⊧", mopf: "𝕞", mscr: "𝓂", mu: "μ", multimap: "⊸", mumap: "⊸", nGg: "⋙̸", nGt: "≫⃒", nLeftarrow: "⇍", nlArr: "⇍", nLeftrightarrow: "⇎", nhArr: "⇎", nLl: "⋘̸", nLt: "≪⃒", nRightarrow: "⇏", nrArr: "⇏", nVDash: "⊯", nVdash: "⊮", nacute: "ń", nang: "∠⃒", napE: "⩰̸", napid: "≋̸", napos: "ŉ", natur: "♮", natural: "♮", ncap: "⩃", ncaron: "ň", ncedil: "ņ", ncongdot: "⩭̸", ncup: "⩂", ncy: "н", ndash: "–", neArr: "⇗", nearhk: "⤤", nedot: "≐̸", nesear: "⤨", toea: "⤨", nfr: "𝔫", nharr: "↮", nleftrightarrow: "↮", nhpar: "⫲", nis: "⋼", nisd: "⋺", njcy: "њ", nlE: "≦̸", nleqq: "≦̸", nlarr: "↚", nleftarrow: "↚", nldr: "‥", nopf: "𝕟", not: "¬", notinE: "⋹̸", notindot: "⋵̸", notinvb: "⋷", notinvc: "⋶", notnivb: "⋾", notnivc: "⋽", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", nrarr: "↛", nrightarrow: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nscr: "𝓃", nsub: "⊄", nsubE: "⫅̸", nsubseteqq: "⫅̸", nsup: "⊅", nsupE: "⫆̸", nsupseteqq: "⫆̸", ntilde: "ñ", nu: "ν", num: "#", numero: "№", numsp: " ", nvDash: "⊭", nvHarr: "⤄", nvap: "≍⃒", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwArr: "⇖", nwarhk: "⤣", nwnear: "⤧", oacute: "ó", ocirc: "ô", ocy: "о", odblac: "ő", odiv: "⨸", odsold: "⦼", oelig: "œ", ofcir: "⦿", ofr: "𝔬", ogon: "˛", ograve: "ò", ogt: "⧁", ohbar: "⦵", olcir: "⦾", olcross: "⦻", olt: "⧀", omacr: "ō", omega: "ω", omicron: "ο", omid: "⦶", oopf: "𝕠", opar: "⦷", operp: "⦹", or: "∨", vee: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", oscr: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oslash: "ø", osol: "⊘", otilde: "õ", otimesas: "⨶", ouml: "ö", ovbar: "⌽", para: "¶", parsim: "⫳", parsl: "⫽", pcy: "п", percnt: "%", period: ".", permil: "‰", pertenk: "‱", pfr: "𝔭", phi: "φ", phiv: "ϕ", straightphi: "ϕ", varphi: "ϕ", phone: "☎", pi: "π", piv: "ϖ", varpi: "ϖ", planckh: "ℎ", plus: "+", plusacir: "⨣", pluscir: "⨢", plusdu: "⨥", pluse: "⩲", plussim: "⨦", plustwo: "⨧", pointint: "⨕", popf: "𝕡", pound: "£", prE: "⪳", prap: "⪷", precapprox: "⪷", precnapprox: "⪹", prnap: "⪹", precneqq: "⪵", prnE: "⪵", precnsim: "⋨", prnsim: "⋨", prime: "′", profalar: "⌮", profline: "⌒", profsurf: "⌓", prurel: "⊰", pscr: "𝓅", psi: "ψ", puncsp: " ", qfr: "𝔮", qopf: "𝕢", qprime: "⁗", qscr: "𝓆", quatint: "⨖", quest: "?", rAtail: "⤜", rHar: "⥤", race: "∽̱", racute: "ŕ", raemptyv: "⦳", rangd: "⦒", range: "⦥", raquo: "»", rarrap: "⥵", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrpl: "⥅", rarrsim: "⥴", rarrtl: "↣", rightarrowtail: "↣", rarrw: "↝", rightsquigarrow: "↝", ratail: "⤚", ratio: "∶", rbbrk: "❳", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", rcaron: "ř", rcedil: "ŗ", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdsh: "↳", rect: "▭", rfisht: "⥽", rfr: "𝔯", rharul: "⥬", rho: "ρ", rhov: "ϱ", varrho: "ϱ", rightrightarrows: "⇉", rrarr: "⇉", rightthreetimes: "⋌", rthree: "⋌", ring: "˚", rlm: "‏", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", ropar: "⦆", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", rpar: ")", rpargt: "⦔", rppolint: "⨒", rsaquo: "›", rscr: "𝓇", rtimes: "⋊", rtri: "▹", triangleright: "▹", rtriltri: "⧎", ruluhar: "⥨", rx: "℞", sacute: "ś", scE: "⪴", scap: "⪸", succapprox: "⪸", scaron: "š", scedil: "ş", scirc: "ŝ", scnE: "⪶", succneqq: "⪶", scnap: "⪺", succnapprox: "⪺", scnsim: "⋩", succnsim: "⋩", scpolint: "⨓", scy: "с", sdot: "⋅", sdote: "⩦", seArr: "⇘", sect: "§", semi: ";", seswar: "⤩", tosa: "⤩", sext: "✶", sfr: "𝔰", sharp: "♯", shchcy: "щ", shcy: "ш", shy: "­", sigma: "σ", sigmaf: "ς", sigmav: "ς", varsigma: "ς", simdot: "⩪", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", smashp: "⨳", smeparsl: "⧤", smile: "⌣", ssmile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", sopf: "𝕤", spades: "♠", spadesuit: "♠", sqcaps: "⊓︀", sqcups: "⊔︀", sscr: "𝓈", star: "☆", sub: "⊂", subset: "⊂", subE: "⫅", subseteqq: "⫅", subdot: "⪽", subedot: "⫃", submult: "⫁", subnE: "⫋", subsetneqq: "⫋", subne: "⊊", subsetneq: "⊊", subplus: "⪿", subrarr: "⥹", subsim: "⫇", subsub: "⫕", subsup: "⫓", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", supE: "⫆", supseteqq: "⫆", supdot: "⪾", supdsub: "⫘", supedot: "⫄", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supsetneqq: "⫌", supne: "⊋", supsetneq: "⊋", supplus: "⫀", supsim: "⫈", supsub: "⫔", supsup: "⫖", swArr: "⇙", swnwar: "⤪", szlig: "ß", target: "⌖", tau: "τ", tcaron: "ť", tcedil: "ţ", tcy: "т", telrec: "⌕", tfr: "𝔱", theta: "θ", thetasym: "ϑ", thetav: "ϑ", vartheta: "ϑ", thorn: "þ", times: "×", timesbar: "⨱", timesd: "⨰", topbot: "⌶", topcir: "⫱", topf: "𝕥", topfork: "⫚", tprime: "‴", triangle: "▵", utri: "▵", triangleq: "≜", trie: "≜", tridot: "◬", triminus: "⨺", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", tscr: "𝓉", tscy: "ц", tshcy: "ћ", tstrok: "ŧ", uHar: "⥣", uacute: "ú", ubrcy: "ў", ubreve: "ŭ", ucirc: "û", ucy: "у", udblac: "ű", ufisht: "⥾", ufr: "𝔲", ugrave: "ù", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", umacr: "ū", uogon: "ų", uopf: "𝕦", upsi: "υ", upsilon: "υ", upuparrows: "⇈", uuarr: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", uring: "ů", urtri: "◹", uscr: "𝓊", utdot: "⋰", utilde: "ũ", uuml: "ü", uwangle: "⦧", vBar: "⫨", vBarv: "⫩", vangrt: "⦜", varsubsetneq: "⊊︀", vsubne: "⊊︀", varsubsetneqq: "⫋︀", vsubnE: "⫋︀", varsupsetneq: "⊋︀", vsupne: "⊋︀", varsupsetneqq: "⫌︀", vsupnE: "⫌︀", vcy: "в", veebar: "⊻", veeeq: "≚", vellip: "⋮", vfr: "𝔳", vopf: "𝕧", vscr: "𝓋", vzigzag: "⦚", wcirc: "ŵ", wedbar: "⩟", wedgeq: "≙", weierp: "℘", wp: "℘", wfr: "𝔴", wopf: "𝕨", wscr: "𝓌", xfr: "𝔵", xi: "ξ", xnis: "⋻", xopf: "𝕩", xscr: "𝓍", yacute: "ý", yacy: "я", ycirc: "ŷ", ycy: "ы", yen: "¥", yfr: "𝔶", yicy: "ї", yopf: "𝕪", yscr: "𝓎", yucy: "ю", yuml: "ÿ", zacute: "ź", zcaron: "ž", zcy: "з", zdot: "ż", zeta: "ζ", zfr: "𝔷", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
var fo = "";
Ve.ngsp = fo;
var go = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function Xs(t8, e2) {
  if (e2 != null && !(Array.isArray(e2) && e2.length == 2)) throw new Error(`Expected '${t8}' to be an array, [start, end].`);
  if (e2 != null) {
    let r2 = e2[0], n2 = e2[1];
    go.forEach((s2) => {
      if (s2.test(r2) || s2.test(n2)) throw new Error(`['${r2}', '${n2}'] contains unusable interpolation symbol.`);
    });
  }
}
var $r = class t3 {
  static fromArray(e2) {
    return e2 ? (Xs("interpolation", e2), new t3(e2[0], e2[1])) : Or;
  }
  constructor(e2, r2) {
    this.start = e2, this.end = r2;
  }
};
var Or = new $r("{{", "}}");
var gt = class extends Oe {
  constructor(e2, r2, n2) {
    super(n2, e2), this.tokenType = r2;
  }
};
var Ur = class {
  constructor(e2, r2, n2) {
    this.tokens = e2, this.errors = r2, this.nonNormalizedIcuExpressions = n2;
  }
};
function li(t8, e2, r2, n2 = {}) {
  let s2 = new Wr(new ve(t8, e2), r2, n2);
  return s2.tokenize(), new Ur(Vo(s2.tokens), s2.errors, s2.nonNormalizedIcuExpressions);
}
var Io = /\r\n?/g;
function Ue(t8) {
  return `Unexpected character "${t8 === 0 ? "EOF" : String.fromCharCode(t8)}"`;
}
function ti(t8) {
  return `Unknown entity "${t8}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Ro(t8, e2) {
  return `Unable to parse entity "${e2}" - ${t8} character reference entities must end with ";"`;
}
var rr;
(function(t8) {
  t8.HEX = "hexadecimal", t8.DEC = "decimal";
})(rr || (rr = {}));
var Ct = class {
  constructor(e2) {
    this.error = e2;
  }
};
var Wr = class {
  constructor(e2, r2, n2) {
    this._getTagContentType = r2, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n2.tokenizeExpansionForms || false, this._interpolationConfig = n2.interpolationConfig || Or, this._leadingTriviaCodePoints = n2.leadingTriviaChars && n2.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n2.canSelfClose || false, this._allowHtmComponentClosingTags = n2.allowHtmComponentClosingTags || false;
    let s2 = n2.range || { endPos: e2.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n2.escapedString ? new Gr(e2, s2) : new nr(e2, s2), this._preserveLineEndings = n2.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n2.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n2.tokenizeBlocks ?? true, this._tokenizeLet = n2.tokenizeLet ?? true;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(e2) {
    return this._preserveLineEndings ? e2 : e2.replace(Io, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e2 = this._cursor.clone();
      try {
        if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e2) : this._attemptStr("--") ? this._consumeComment(e2) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e2) : this._consumeBogusComment(e2);
        else if (this._attemptCharCode(47)) this._consumeTagClose(e2);
        else {
          let r2 = this._cursor.clone();
          this._attemptCharCode(63) ? (this._cursor = r2, this._consumeBogusComment(e2)) : this._consumeTagOpen(e2);
        }
        else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e2) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e2) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e2) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r2) {
        this.handleError(r2);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e2 = false, r2 = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n2) => ut(n2) ? !e2 : si(n2) ? (e2 = true, false) : true), this._cursor.getChars(r2).trim();
  }
  _consumeBlockStart(e2) {
    this._beginToken(25, e2);
    let r2 = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(b);
    else {
      r2.type = 29;
      return;
    }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r2.type = 29;
  }
  _consumeBlockEnd(e2) {
    this._beginToken(27, e2), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(ii); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e2 = this._cursor.clone(), r2 = null, n2 = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r2 !== null; ) {
        let s2 = this._cursor.peek();
        if (s2 === 92) this._cursor.advance();
        else if (s2 === r2) r2 = null;
        else if (r2 === null && Ot(s2)) r2 = s2;
        else if (s2 === 40 && r2 === null) n2++;
        else if (s2 === 41 && r2 === null) {
          if (n2 === 0) break;
          n2 > 0 && n2--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e2)]), this._attemptCharCodeUntilFn(ii);
    }
  }
  _consumeLetDeclaration(e2) {
    if (this._beginToken(30, e2), ut(this._cursor.peek())) this._attemptCharCodeUntilFn(b);
    else {
      let s2 = this._endToken([this._cursor.getChars(e2)]);
      s2.type = 33;
      return;
    }
    let r2 = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(b), !this._attemptCharCode(61)) {
      r2.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s2) => b(s2) && !$t(s2)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r2.type = 33, r2.sourceSpan = this._cursor.getSpan(e2));
  }
  _getLetDeclarationName() {
    let e2 = this._cursor.clone(), r2 = false;
    return this._attemptCharCodeUntilFn((n2) => lt(n2) || n2 === 36 || n2 === 95 || r2 && Rt(n2) ? (r2 = true, false) : true), this._cursor.getChars(e2).trim();
  }
  _consumeLetDeclarationValue() {
    let e2 = this._cursor.clone();
    for (this._beginToken(31, e2); this._cursor.peek() !== 0; ) {
      let r2 = this._cursor.peek();
      if (r2 === 59) break;
      Ot(r2) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n2) => n2 === 92 ? (this._cursor.advance(), false) : n2 === r2)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e2)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), true;
    if (qo(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e2, r2 = this._cursor.clone()) {
    this._currentTokenStart = r2, this._currentTokenType = e2;
  }
  _endToken(e2, r2) {
    if (this._currentTokenStart === null) throw new gt("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r2));
    if (this._currentTokenType === null) throw new gt("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n2 = { type: this._currentTokenType, parts: e2, sourceSpan: (r2 ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n2), this._currentTokenStart = null, this._currentTokenType = null, n2;
  }
  _createError(e2, r2) {
    this._isInExpansionForm() && (e2 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n2 = new gt(e2, this._currentTokenType, r2);
    return this._currentTokenStart = null, this._currentTokenType = null, new Ct(n2);
  }
  handleError(e2) {
    if (e2 instanceof St && (e2 = this._createError(e2.msg, this._cursor.getSpan(e2.cursor))), e2 instanceof Ct) this.errors.push(e2.error);
    else throw e2;
  }
  _attemptCharCode(e2) {
    return this._cursor.peek() === e2 ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e2) {
    return Ho(this._cursor.peek(), e2) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptCharCode(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptStr(e2) {
    let r2 = e2.length;
    if (this._cursor.charsLeft() < r2) return false;
    let n2 = this._cursor.clone();
    for (let s2 = 0; s2 < r2; s2++) if (!this._attemptCharCode(e2.charCodeAt(s2))) return this._cursor = n2, false;
    return true;
  }
  _attemptStrCaseInsensitive(e2) {
    for (let r2 = 0; r2 < e2.length; r2++) if (!this._attemptCharCodeCaseInsensitive(e2.charCodeAt(r2))) return false;
    return true;
  }
  _requireStr(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStr(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _requireStrCaseInsensitive(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptCharCodeUntilFn(e2) {
    for (; !e2(this._cursor.peek()); ) this._cursor.advance();
  }
  _requireCharCodeUntilFn(e2, r2) {
    let n2 = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e2), this._cursor.diff(n2) < r2) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(n2));
  }
  _attemptUntilChar(e2) {
    for (; this._cursor.peek() !== e2; ) this._cursor.advance();
  }
  _readChar() {
    let e2 = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e2;
  }
  _consumeEntity(e2) {
    this._beginToken(9);
    let r2 = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n2 = this._attemptCharCode(120) || this._attemptCharCode(88), s2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Oo), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n2 ? rr.HEX : rr.DEC;
        throw this._createError(Ro(a, this._cursor.getChars(r2)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(s2);
      this._cursor.advance();
      try {
        let a = parseInt(i, n2 ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r2)]);
      } catch {
        throw this._createError(ti(this._cursor.getChars(r2)), this._cursor.getSpan());
      }
    } else {
      let n2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Mo), this._cursor.peek() != 59) this._beginToken(e2, r2), this._cursor = n2, this._endToken(["&"]);
      else {
        let s2 = this._cursor.getChars(n2);
        this._cursor.advance();
        let i = Ve[s2];
        if (!i) throw this._createError(ti(s2), this._cursor.getSpan(r2));
        this._endToken([i, `&${s2};`]);
      }
    }
  }
  _consumeRawText(e2, r2) {
    this._beginToken(e2 ? 6 : 7);
    let n2 = [];
    for (; ; ) {
      let s2 = this._cursor.clone(), i = r2();
      if (this._cursor = s2, i) break;
      e2 && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n2.join(""))]), n2.length = 0, this._consumeEntity(6), this._beginToken(6)) : n2.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n2.join(""))]);
  }
  _consumeComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e2) {
    this._beginToken(12, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e2) {
    this._beginToken(18, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e2 = this._cursor.clone(), r2 = "";
    for (; this._cursor.peek() !== 58 && !$o(this._cursor.peek()); ) this._cursor.advance();
    let n2;
    this._cursor.peek() === 58 ? (r2 = this._cursor.getChars(e2), this._cursor.advance(), n2 = this._cursor.clone()) : n2 = e2, this._requireCharCodeUntilFn(ri, r2 === "" ? 0 : 1);
    let s2 = this._cursor.getChars(n2);
    return [r2, s2];
  }
  _consumeTagOpen(e2) {
    let r2, n2, s2, i = [];
    try {
      if (!lt(this._cursor.peek())) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(e2));
      for (s2 = this._consumeTagOpenStart(e2), n2 = s2.parts[0], r2 = s2.parts[1], this._attemptCharCodeUntilFn(b); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o2, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(b), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(b);
          let p = this._consumeAttributeValue();
          i.push({ prefix: o2, name: u, value: p });
        } else i.push({ prefix: o2, name: u });
        this._attemptCharCodeUntilFn(b);
      }
      this._consumeTagOpenEnd();
    } catch (o2) {
      if (o2 instanceof Ct) {
        s2 ? s2.type = 4 : (this._beginToken(5, e2), this._endToken(["<"]));
        return;
      }
      throw o2;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2) return;
    let a = this._getTagContentType(r2, n2, this._fullNameStack.length > 0, i);
    this._handleFullNameStackForTagOpen(n2, r2), a === N.RAW_TEXT ? this._consumeRawTextWithTagClose(n2, r2, false) : a === N.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n2, r2, true);
  }
  _consumeRawTextWithTagClose(e2, r2, n2) {
    this._consumeRawText(n2, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b), !this._attemptStrCaseInsensitive(e2 ? `${e2}:${r2}` : r2)) ? false : (this._attemptCharCodeUntilFn(b), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s2) => s2 === 62, 3), this._cursor.advance(), this._endToken([e2, r2]), this._handleFullNameStackForTagClose(e2, r2);
  }
  _consumeTagOpenStart(e2) {
    this._beginToken(0, e2);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2);
  }
  _consumeAttributeName() {
    let e2 = this._cursor.peek();
    if (e2 === 39 || e2 === 34) throw this._createError(Ue(e2), this._cursor.getSpan());
    this._beginToken(14);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2), r2;
  }
  _consumeAttributeValue() {
    let e2;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r2 = this._cursor.peek();
      this._consumeQuote(r2);
      let n2 = () => this._cursor.peek() === r2;
      e2 = this._consumeWithInterpolation(16, 17, n2, n2), this._consumeQuote(r2);
    } else {
      let r2 = () => ri(this._cursor.peek());
      e2 = this._consumeWithInterpolation(16, 17, r2, r2);
    }
    return e2;
  }
  _consumeQuote(e2) {
    this._beginToken(15), this._requireCharCode(e2), this._endToken([String.fromCodePoint(e2)]);
  }
  _consumeTagOpenEnd() {
    let e2 = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e2), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e2) {
    if (this._beginToken(3, e2), this._attemptCharCodeUntilFn(b), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([]);
    else {
      let [r2, n2] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([r2, n2]), this._handleFullNameStackForTagClose(r2, n2);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e2 = this._readUntil(44), r2 = this._processCarriageReturns(e2);
    if (this._i18nNormalizeLineEndingsInICUs) this._endToken([r2]);
    else {
      let s2 = this._endToken([e2]);
      r2 !== e2 && this.nonNormalizedIcuExpressions.push(s2);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(b), this._beginToken(7);
    let n2 = this._readUntil(44);
    this._endToken([n2]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e2 = this._readUntil(123).trim();
    this._endToken([e2]), this._attemptCharCodeUntilFn(b), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e2, r2, n2, s2) {
    this._beginToken(e2);
    let i = [];
    for (; !n2(); ) {
      let o2 = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o2), i.length = 0, this._consumeInterpolation(r2, o2, s2), this._beginToken(e2)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e2), this._beginToken(e2)) : i.push(this._readChar());
    }
    this._inInterpolation = false;
    let a = this._processCarriageReturns(i.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e2, r2, n2) {
    let s2 = [];
    this._beginToken(e2, r2), s2.push(this._interpolationConfig.start);
    let i = this._cursor.clone(), a = null, o2 = false;
    for (; this._cursor.peek() !== 0 && (n2 === null || !n2()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, s2.push(this._getProcessedChars(i, u)), this._endToken(s2);
        return;
      }
      if (a === null) if (this._attemptStr(this._interpolationConfig.end)) {
        s2.push(this._getProcessedChars(i, u)), s2.push(this._interpolationConfig.end), this._endToken(s2);
        return;
      } else this._attemptStr("//") && (o2 = true);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o2 && a === null && Ot(p) && (a = p);
    }
    s2.push(this._getProcessedChars(i, this._cursor)), this._endToken(s2);
  }
  _getProcessedChars(e2, r2) {
    return this._processCarriageReturns(r2.getChars(e2));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e2 = this._cursor.clone();
      e2.advance();
      let r2 = e2.peek();
      if (97 <= r2 && r2 <= 122 || 65 <= r2 && r2 <= 90 || r2 === 47 || r2 === 33) return true;
    }
    return false;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e2 = this._cursor.clone();
      if (e2.advance(), si(e2.peek())) return true;
    }
    return false;
  }
  _readUntil(e2) {
    let r2 = this._cursor.clone();
    return this._attemptUntilChar(e2), this._cursor.getChars(r2);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123) return false;
    if (this._interpolationConfig) {
      let e2 = this._cursor.clone(), r2 = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e2, !r2;
    }
    return true;
  }
  _handleFullNameStackForTagOpen(e2, r2) {
    let n2 = qe(e2, r2);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n2) && this._fullNameStack.push(n2);
  }
  _handleFullNameStackForTagClose(e2, r2) {
    let n2 = qe(e2, r2);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n2 && this._fullNameStack.pop();
  }
};
function b(t8) {
  return !ut(t8) || t8 === 0;
}
function ri(t8) {
  return ut(t8) || t8 === 62 || t8 === 60 || t8 === 47 || t8 === 39 || t8 === 34 || t8 === 61 || t8 === 0;
}
function $o(t8) {
  return (t8 < 97 || 122 < t8) && (t8 < 65 || 90 < t8) && (t8 < 48 || t8 > 57);
}
function Oo(t8) {
  return t8 === 59 || t8 === 0 || !Rs(t8);
}
function Mo(t8) {
  return t8 === 59 || t8 === 0 || !lt(t8);
}
function qo(t8) {
  return t8 !== 125;
}
function Ho(t8, e2) {
  return ni(t8) === ni(e2);
}
function ni(t8) {
  return t8 >= 97 && t8 <= 122 ? t8 - 97 + 65 : t8;
}
function si(t8) {
  return lt(t8) || Rt(t8) || t8 === 95;
}
function ii(t8) {
  return t8 !== 59 && b(t8);
}
function Vo(t8) {
  let e2 = [], r2;
  for (let n2 = 0; n2 < t8.length; n2++) {
    let s2 = t8[n2];
    r2 && r2.type === 5 && s2.type === 5 || r2 && r2.type === 16 && s2.type === 16 ? (r2.parts[0] += s2.parts[0], r2.sourceSpan.end = s2.sourceSpan.end) : (r2 = s2, e2.push(r2));
  }
  return e2;
}
var nr = class t4 {
  constructor(e2, r2) {
    if (e2 instanceof t4) {
      this.file = e2.file, this.input = e2.input, this.end = e2.end;
      let n2 = e2.state;
      this.state = { peek: n2.peek, offset: n2.offset, line: n2.line, column: n2.column };
    } else {
      if (!r2) throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e2, this.input = e2.content, this.end = r2.endPos, this.state = { peek: -1, offset: r2.startPos, line: r2.startLine, column: r2.startCol };
    }
  }
  clone() {
    return new t4(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e2) {
    return this.state.offset - e2.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e2, r2) {
    e2 = e2 || this;
    let n2 = e2;
    if (r2) for (; this.diff(e2) > 0 && r2.indexOf(e2.peek()) !== -1; ) n2 === e2 && (e2 = e2.clone()), e2.advance();
    let s2 = this.locationFromCursor(e2), i = this.locationFromCursor(this), a = n2 !== e2 ? this.locationFromCursor(n2) : s2;
    return new h(s2, i, a);
  }
  getChars(e2) {
    return this.input.substring(e2.state.offset, this.state.offset);
  }
  charAt(e2) {
    return this.input.charCodeAt(e2);
  }
  advanceState(e2) {
    if (e2.offset >= this.end) throw this.state = e2, new St('Unexpected character "EOF"', this);
    let r2 = this.charAt(e2.offset);
    r2 === 10 ? (e2.line++, e2.column = 0) : $t(r2) || e2.column++, e2.offset++, this.updatePeek(e2);
  }
  updatePeek(e2) {
    e2.peek = e2.offset >= this.end ? 0 : this.charAt(e2.offset);
  }
  locationFromCursor(e2) {
    return new ie(e2.file, e2.state.offset, e2.state.line, e2.state.column);
  }
};
var Gr = class t5 extends nr {
  constructor(e2, r2) {
    e2 instanceof t5 ? (super(e2), this.internalState = { ...e2.internalState }) : (super(e2, r2), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new t5(this);
  }
  getChars(e2) {
    let r2 = e2.clone(), n2 = "";
    for (; r2.internalState.offset < this.internalState.offset; ) n2 += String.fromCodePoint(r2.peek()), r2.advance();
    return n2;
  }
  processEscapeSequence() {
    let e2 = () => this.internalState.peek;
    if (e2() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e2() === 110) this.state.peek = 10;
    else if (e2() === 114) this.state.peek = 13;
    else if (e2() === 118) this.state.peek = 11;
    else if (e2() === 116) this.state.peek = 9;
    else if (e2() === 98) this.state.peek = 8;
    else if (e2() === 102) this.state.peek = 12;
    else if (e2() === 117) if (this.advanceState(this.internalState), e2() === 123) {
      this.advanceState(this.internalState);
      let r2 = this.clone(), n2 = 0;
      for (; e2() !== 125; ) this.advanceState(this.internalState), n2++;
      this.state.peek = this.decodeHexDigits(r2, n2);
    } else {
      let r2 = this.clone();
      this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 4);
    }
    else if (e2() === 120) {
      this.advanceState(this.internalState);
      let r2 = this.clone();
      this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 2);
    } else if (Br(e2())) {
      let r2 = "", n2 = 0, s2 = this.clone();
      for (; Br(e2()) && n2 < 3; ) s2 = this.clone(), r2 += String.fromCodePoint(e2()), this.advanceState(this.internalState), n2++;
      this.state.peek = parseInt(r2, 8), this.internalState = s2.internalState;
    } else $t(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e2, r2) {
    let n2 = this.input.slice(e2.internalState.offset, e2.internalState.offset + r2), s2 = parseInt(n2, 16);
    if (isNaN(s2)) throw e2.state = e2.internalState, new St("Invalid hexadecimal escape sequence", e2);
    return s2;
  }
};
var St = class {
  constructor(e2, r2) {
    this.msg = e2, this.cursor = r2;
  }
};
var L = class t6 extends Oe {
  static create(e2, r2, n2) {
    return new t6(e2, r2, n2);
  }
  constructor(e2, r2, n2) {
    super(r2, n2), this.elementName = e2;
  }
};
var jr = class {
  constructor(e2, r2) {
    this.rootNodes = e2, this.errors = r2;
  }
};
var sr = class {
  constructor(e2) {
    this.getTagDefinition = e2;
  }
  parse(e2, r2, n2, s2 = false, i) {
    let a = (D) => (I3, ...F) => D(I3.toLowerCase(), ...F), o2 = s2 ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o2(D).getContentType(), p = s2 ? i : a(i), m = li(e2, r2, i ? (D, I3, F, c2) => {
      let g2 = p(D, I3, F, c2);
      return g2 !== void 0 ? g2 : u(D);
    } : u, n2), f = n2 && n2.canSelfClose || false, C = n2 && n2.allowHtmComponentClosingTags || false, A = new Kr(m.tokens, o2, f, C, s2);
    return A.build(), new jr(A.rootNodes, m.errors.concat(A.errors));
  }
};
var Kr = class t7 {
  constructor(e2, r2, n2, s2, i) {
    this.tokens = e2, this.getTagDefinition = r2, this.canSelfClose = n2, this.allowHtmComponentClosingTags = s2, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 34; ) this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e2 of this._containerStack) e2 instanceof ee && this.errors.push(L.create(e2.name, e2.sourceSpan, `Unclosed block "${e2.name}"`));
  }
  _advance() {
    let e2 = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e2;
  }
  _advanceIf(e2) {
    return this._peek.type === e2 ? this._advance() : null;
  }
  _consumeCdata(e2) {
    let r2 = this._advance(), n2 = this._getText(r2), s2 = this._advanceIf(13);
    this._addToParent(new Gt(n2, new h(e2.sourceSpan.start, (s2 || r2).sourceSpan.end), [r2]));
  }
  _consumeComment(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(11), s2 = r2 != null ? r2.parts[0].trim() : null, i = n2 == null ? e2.sourceSpan : new h(e2.sourceSpan.start, n2.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new Kt(s2, i));
  }
  _consumeDocType(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(19), s2 = r2 != null ? r2.parts[0].trim() : null, i = new h(e2.sourceSpan.start, (n2 || r2 || e2).sourceSpan.end);
    this._addToParent(new Xt(s2, i));
  }
  _consumeExpansion(e2) {
    let r2 = this._advance(), n2 = this._advance(), s2 = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a) return;
      s2.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let i = new h(e2.sourceSpan.start, this._peek.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new zt(r2.parts[0], n2.parts[0], s2, i, r2.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e2 = this._advance();
    if (this._peek.type !== 22) return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r2 = this._advance(), n2 = this._collectExpansionExpTokens(r2);
    if (!n2) return null;
    let s2 = this._advance();
    n2.push({ type: 34, parts: [], sourceSpan: s2.sourceSpan });
    let i = new t7(n2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (i.build(), i.errors.length > 0) return this.errors = this.errors.concat(i.errors), null;
    let a = new h(e2.sourceSpan.start, s2.sourceSpan.end, e2.sourceSpan.fullStart), o2 = new h(r2.sourceSpan.start, s2.sourceSpan.end, r2.sourceSpan.fullStart);
    return new Yt(e2.parts[0], i.rootNodes, a, e2.sourceSpan, o2);
  }
  _collectExpansionExpTokens(e2) {
    let r2 = [], n2 = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n2.push(this._peek.type), this._peek.type === 23) if (ci(n2, 22)) {
        if (n2.pop(), n2.length === 0) return r2;
      } else return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24) if (ci(n2, 20)) n2.pop();
      else return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34) return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r2.push(this._advance());
    }
  }
  _getText(e2) {
    let r2 = e2.parts[0];
    if (r2.length > 0 && r2[0] == `
`) {
      let n2 = this._getClosestParentElement();
      n2 != null && n2.children.length == 0 && this.getTagDefinition(n2.name).ignoreFirstLf && (r2 = r2.substring(1));
    }
    return r2;
  }
  _consumeText(e2) {
    let r2 = [e2], n2 = e2.sourceSpan, s2 = e2.parts[0];
    if (s2.length > 0 && s2[0] === `
`) {
      let i = this._getContainer();
      i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s2 = s2.substring(1), r2[0] = { type: e2.type, sourceSpan: e2.sourceSpan, parts: [s2] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; ) e2 = this._advance(), r2.push(e2), e2.type === 8 ? s2 += e2.parts.join("").replace(/&([^;]+);/g, pi) : e2.type === 9 ? s2 += e2.parts[0] : s2 += e2.parts.join("");
    if (s2.length > 0) {
      let i = e2.sourceSpan;
      this._addToParent(new Wt(s2, new h(n2.start, i.end, n2.fullStart, n2.details), r2));
    }
  }
  _closeVoidElement() {
    let e2 = this._getContainer();
    e2 instanceof Y && this.getTagDefinition(e2.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e2) {
    let [r2, n2] = e2.parts, s2 = [];
    for (; this._peek.type === 14; ) s2.push(this._consumeAttr(this._advance()));
    let i = this._getElementFullName(r2, n2, this._getClosestParentElement()), a = false;
    if (this._peek.type === 2) {
      this._advance(), a = true;
      let C = this.getTagDefinition(i);
      this.canSelfClose || C.canSelfClose || Me(i) !== null || C.isVoid || this.errors.push(L.create(i, e2.sourceSpan, `Only void, custom and foreign elements can be self closed "${e2.parts[1]}"`));
    } else this._peek.type === 1 && (this._advance(), a = false);
    let o2 = this._peek.sourceSpan.fullStart, u = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), p = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), l2 = new h(e2.sourceSpan.start.moveBy(1), e2.sourceSpan.end), m = new Y(i, s2, [], u, p, void 0, l2), f = this._getContainer();
    this._pushContainer(m, f instanceof Y && this.getTagDefinition(f.name).isClosedByChild(m.name)), a ? this._popContainer(i, Y, u) : e2.type === 4 && (this._popContainer(i, Y, null), this.errors.push(L.create(i, u, `Opening tag "${i}" not terminated.`)));
  }
  _pushContainer(e2, r2) {
    r2 && this._containerStack.pop(), this._addToParent(e2), this._containerStack.push(e2);
  }
  _consumeEndTag(e2) {
    let r2 = this.allowHtmComponentClosingTags && e2.parts.length === 0 ? null : this._getElementFullName(e2.parts[0], e2.parts[1], this._getClosestParentElement());
    if (r2 && this.getTagDefinition(r2).isVoid) this.errors.push(L.create(r2, e2.sourceSpan, `Void elements do not have end tags "${e2.parts[1]}"`));
    else if (!this._popContainer(r2, Y, e2.sourceSpan)) {
      let n2 = `Unexpected closing tag "${r2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(L.create(r2, e2.sourceSpan, n2));
    }
  }
  _popContainer(e2, r2, n2) {
    let s2 = false;
    for (let i = this._containerStack.length - 1; i >= 0; i--) {
      let a = this._containerStack[i];
      if (Me(a.name) ? a.name === e2 : (e2 == null || a.name.toLowerCase() === e2.toLowerCase()) && a instanceof r2) return a.endSourceSpan = n2, a.sourceSpan.end = n2 !== null ? n2.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s2;
      (a instanceof ee || a instanceof Y && !this.getTagDefinition(a.name).closedByParent) && (s2 = true);
    }
    return false;
  }
  _consumeAttr(e2) {
    let r2 = qe(e2.parts[0], e2.parts[1]), n2 = e2.sourceSpan.end, s2;
    this._peek.type === 15 && (s2 = this._advance());
    let i = "", a = [], o2, u;
    if (this._peek.type === 16) for (o2 = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
      let m = this._advance();
      a.push(m), m.type === 17 ? i += m.parts.join("").replace(/&([^;]+);/g, pi) : m.type === 9 ? i += m.parts[0] : i += m.parts.join(""), u = n2 = m.sourceSpan.end;
    }
    this._peek.type === 15 && (u = n2 = this._advance().sourceSpan.end);
    let l2 = o2 && u && new h((s2 == null ? void 0 : s2.sourceSpan.start) ?? o2.start, u, (s2 == null ? void 0 : s2.sourceSpan.fullStart) ?? o2.fullStart);
    return new jt(r2, i, new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), e2.sourceSpan, l2, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e2) {
    let r2 = [];
    for (; this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new ee(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(e2) {
    this._popContainer(null, ee, e2.sourceSpan) || this.errors.push(L.create(null, e2.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e2) {
    let r2 = [];
    for (; this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new ee(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false), this._popContainer(null, ee, null), this.errors.push(L.create(e2.parts[0], s2, `Incomplete block "${e2.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e2) {
    let r2 = e2.parts[0], n2, s2;
    if (this._peek.type !== 31) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Invalid @let declaration "${r2}". Declaration must have a value.`));
      return;
    } else n2 = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Unterminated @let declaration "${r2}". Declaration must be terminated with a semicolon.`));
      return;
    } else s2 = this._advance();
    let i = s2.sourceSpan.fullStart, a = new h(e2.sourceSpan.start, i, e2.sourceSpan.fullStart), o2 = e2.sourceSpan.toString().lastIndexOf(r2), u = e2.sourceSpan.start.moveBy(o2), p = new h(u, e2.sourceSpan.end), l2 = new mt(r2, n2.parts[0], a, p, n2.sourceSpan);
    this._addToParent(l2);
  }
  _consumeIncompleteLet(e2) {
    let r2 = e2.parts[0] ?? "", n2 = r2 ? ` "${r2}"` : "";
    if (r2.length > 0) {
      let s2 = e2.sourceSpan.toString().lastIndexOf(r2), i = e2.sourceSpan.start.moveBy(s2), a = new h(i, e2.sourceSpan.end), o2 = new h(e2.sourceSpan.start, e2.sourceSpan.start.moveBy(0)), u = new mt(r2, "", e2.sourceSpan, a, o2);
      this._addToParent(u);
    }
    this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Incomplete @let declaration${n2}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e2 = this._containerStack.length - 1; e2 > -1; e2--) if (this._containerStack[e2] instanceof Y) return this._containerStack[e2];
    return null;
  }
  _addToParent(e2) {
    let r2 = this._getContainer();
    r2 === null ? this.rootNodes.push(e2) : r2.children.push(e2);
  }
  _getElementFullName(e2, r2, n2) {
    if (e2 === "" && (e2 = this.getTagDefinition(r2).implicitNamespacePrefix || "", e2 === "" && n2 != null)) {
      let s2 = ct(n2.name)[1];
      this.getTagDefinition(s2).preventNamespaceInheritance || (e2 = Me(n2.name));
    }
    return qe(e2, r2);
  }
};
function ci(t8, e2) {
  return t8.length > 0 && t8[t8.length - 1] === e2;
}
function pi(t8, e2) {
  return Ve[e2] !== void 0 ? Ve[e2] || t8 : /^#x[a-f0-9]+$/i.test(e2) ? String.fromCodePoint(parseInt(e2.slice(2), 16)) : /^#\d+$/.test(e2) ? String.fromCodePoint(parseInt(e2.slice(1), 10)) : t8;
}
var ir = class extends sr {
  constructor() {
    super(He);
  }
  parse(e2, r2, n2, s2 = false, i) {
    return super.parse(e2, r2, n2, s2, i);
  }
};
var Xr = null;
var Uo = () => (Xr || (Xr = new ir()), Xr);
function Qr(t8, e2 = {}) {
  let { canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: s2 = false, getTagContentType: i, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o2 = false } = e2;
  return Uo().parse(t8, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2, tokenizeBlocks: a, tokenizeLet: o2 }, s2, i);
}
function Wo(t8, e2) {
  let r2 = new SyntaxError(t8 + " (" + e2.loc.start.line + ":" + e2.loc.start.column + ")");
  return Object.assign(r2, e2);
}
var hi = Wo;
var _t = 3;
function Go(t8) {
  let e2 = t8.slice(0, _t);
  if (e2 !== "---" && e2 !== "+++") return;
  let r2 = t8.indexOf(`
`, _t);
  if (r2 === -1) return;
  let n2 = t8.slice(_t, r2).trim(), s2 = t8.indexOf(`
${e2}`, r2), i = n2;
  if (i || (i = e2 === "+++" ? "toml" : "yaml"), s2 === -1 && e2 === "---" && i === "yaml" && (s2 = t8.indexOf(`
...`, r2)), s2 === -1) return;
  let a = s2 + 1 + _t, o2 = t8.charAt(a + 1);
  if (!/\s?/u.test(o2)) return;
  let u = t8.slice(0, a);
  return { type: "front-matter", language: i, explicitLanguage: n2, value: t8.slice(r2 + 1, s2), startDelimiter: e2, endDelimiter: u.slice(-_t), raw: u };
}
function zo(t8) {
  let e2 = Go(t8);
  if (!e2) return { content: t8 };
  let { raw: r2 } = e2;
  return { frontMatter: e2, content: w(false, r2, /[^\n]/gu, " ") + t8.slice(r2.length) };
}
var mi = zo;
var ar = { attrs: true, children: true, cases: true, expression: true };
var fi = /* @__PURE__ */ new Set(["parent"]);
var le;
var Jr;
var Zr;
var Ge = class Ge2 {
  constructor(e2 = {}) {
    At(this, le);
    lr(this, "type");
    lr(this, "parent");
    for (let r2 of /* @__PURE__ */ new Set([...fi, ...Object.keys(e2)])) this.setProperty(r2, e2[r2]);
  }
  setProperty(e2, r2) {
    if (this[e2] !== r2) {
      if (e2 in ar && (r2 = r2.map((n2) => this.createChild(n2))), !fi.has(e2)) {
        this[e2] = r2;
        return;
      }
      Object.defineProperty(this, e2, { value: r2, enumerable: false, configurable: true });
    }
  }
  map(e2) {
    let r2;
    for (let n2 in ar) {
      let s2 = this[n2];
      if (s2) {
        let i = Yo(s2, (a) => a.map(e2));
        r2 !== s2 && (r2 || (r2 = new Ge2({ parent: this.parent })), r2.setProperty(n2, i));
      }
    }
    if (r2) for (let n2 in this) n2 in ar || (r2[n2] = this[n2]);
    return e2(r2 || this);
  }
  walk(e2) {
    for (let r2 in ar) {
      let n2 = this[r2];
      if (n2) for (let s2 = 0; s2 < n2.length; s2++) n2[s2].walk(e2);
    }
    e2(this);
  }
  createChild(e2) {
    let r2 = e2 instanceof Ge2 ? e2.clone() : new Ge2(e2);
    return r2.setProperty("parent", this), r2;
  }
  insertChildBefore(e2, r2) {
    let n2 = this.$children;
    n2.splice(n2.indexOf(e2), 0, this.createChild(r2));
  }
  removeChild(e2) {
    let r2 = this.$children;
    r2.splice(r2.indexOf(e2), 1);
  }
  replaceChild(e2, r2) {
    let n2 = this.$children;
    n2[n2.indexOf(e2)] = this.createChild(r2);
  }
  clone() {
    return new Ge2(this);
  }
  get $children() {
    return this[R(this, le, Jr)];
  }
  set $children(e2) {
    this[R(this, le, Jr)] = e2;
  }
  get firstChild() {
    var e2;
    return (e2 = this.$children) == null ? void 0 : e2[0];
  }
  get lastChild() {
    return K(true, this.$children, -1);
  }
  get prev() {
    let e2 = R(this, le, Zr);
    return e2[e2.indexOf(this) - 1];
  }
  get next() {
    let e2 = R(this, le, Zr);
    return e2[e2.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e2) => [e2.fullName, e2.value]));
  }
};
le = /* @__PURE__ */ new WeakSet(), Jr = function() {
  return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
}, Zr = function() {
  var e2;
  return ((e2 = this.parent) == null ? void 0 : e2.$children) ?? [];
};
var or = Ge;
function Yo(t8, e2) {
  let r2 = t8.map(e2);
  return r2.some((n2, s2) => n2 !== t8[s2]) ? r2 : t8;
}
var jo = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Ko }, { regex: /^\[if([^\]]*)\]><!$/u, parse: Xo }, { regex: /^<!\s*\[endif\]$/u, parse: Qo }];
function di(t8, e2) {
  if (t8.value) for (let { regex: r2, parse: n2 } of jo) {
    let s2 = t8.value.match(r2);
    if (s2) return n2(t8, e2, s2);
  }
  return null;
}
function Ko(t8, e2, r2) {
  let [, n2, s2, i] = r2, a = 4 + n2.length, o2 = t8.sourceSpan.start.moveBy(a), u = o2.moveBy(i.length), [p, l2] = (() => {
    try {
      return [true, e2(i, o2).children];
    } catch {
      return [false, [{ type: "text", value: i, sourceSpan: new h(o2, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: l2, condition: w(false, s2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan, startSourceSpan: new h(t8.sourceSpan.start, o2), endSourceSpan: new h(u, t8.sourceSpan.end) };
}
function Xo(t8, e2, r2) {
  let [, n2] = r2;
  return { type: "ieConditionalStartComment", condition: w(false, n2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan };
}
function Qo(t8) {
  return { type: "ieConditionalEndComment", sourceSpan: t8.sourceSpan };
}
var ur = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
var gi = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function Jo(t8) {
  if (t8.type === "block") {
    if (t8.name = w(false, t8.name.toLowerCase(), /\s+/gu, " ").trim(), t8.type = "angularControlFlowBlock", !me(t8.parameters)) {
      delete t8.parameters;
      return;
    }
    for (let e2 of t8.parameters) e2.type = "angularControlFlowBlockParameter";
    t8.parameters = { type: "angularControlFlowBlockParameters", children: t8.parameters, sourceSpan: new h(t8.parameters[0].sourceSpan.start, K(false, t8.parameters, -1).sourceSpan.end) };
  }
}
function Zo(t8) {
  t8.type === "letDeclaration" && (t8.type = "angularLetDeclaration", t8.id = t8.name, t8.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t8.valueSpan.start, t8.valueSpan.end), value: t8.value }, delete t8.name, delete t8.value);
}
function eu(t8) {
  (t8.type === "plural" || t8.type === "select") && (t8.clause = t8.type, t8.type = "angularIcuExpression"), t8.type === "expansionCase" && (t8.type = "angularIcuCase");
}
function Si(t8, e2, r2) {
  let { name: n2, canSelfClose: s2 = true, normalizeTagName: i = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o2 = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e2, { rootNodes: l2, errors: m } = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u, getTagContentType: p ? (...c2) => p(...c2) ? N.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n2 === "angular" ? true : void 0, tokenizeAngularLetDeclaration: n2 === "angular" ? true : void 0 });
  if (n2 === "vue") {
    if (l2.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html")) return Si(t8, en, r2);
    let g2, y2 = () => g2 ?? (g2 = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u })), q2 = (x) => y2().rootNodes.find(({ startSourceSpan: U2 }) => U2 && U2.start.offset === x.startSourceSpan.start.offset) ?? x;
    for (let [x, U2] of l2.entries()) {
      let { endSourceSpan: nn3, startSourceSpan: Ei2 } = U2;
      if (nn3 === null) m = y2().errors, l2[x] = q2(U2);
      else if (tu(U2, r2)) {
        let sn3 = y2().errors.find((an3) => an3.span.start.offset > Ei2.start.offset && an3.span.start.offset < nn3.end.offset);
        sn3 && Ci(sn3), l2[x] = q2(U2);
      }
    }
  }
  m.length > 0 && Ci(m[0]);
  let f = (c2) => {
    let g2 = c2.name.startsWith(":") ? c2.name.slice(1).split(":")[0] : null, y2 = c2.nameSpan.toString(), q2 = g2 !== null && y2.startsWith(`${g2}:`), x = q2 ? y2.slice(g2.length + 1) : y2;
    c2.name = x, c2.namespace = g2, c2.hasExplicitNamespace = q2;
  }, C = (c2) => {
    switch (c2.type) {
      case "element":
        f(c2);
        for (let g2 of c2.attrs) f(g2), g2.valueSpan ? (g2.value = g2.valueSpan.toString(), /["']/u.test(g2.value[0]) && (g2.value = g2.value.slice(1, -1))) : g2.value = null;
        break;
      case "comment":
        c2.value = c2.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        c2.value = c2.sourceSpan.toString();
        break;
    }
  }, A = (c2, g2) => {
    let y2 = c2.toLowerCase();
    return g2(y2) ? y2 : c2;
  }, D = (c2) => {
    if (c2.type === "element" && (i && (!c2.namespace || c2.namespace === c2.tagDefinition.implicitNamespacePrefix || fe(c2)) && (c2.name = A(c2.name, (g2) => gi.has(g2))), a)) for (let g2 of c2.attrs) g2.namespace || (g2.name = A(g2.name, (y2) => ur.has(c2.name) && (ur.get("*").has(y2) || ur.get(c2.name).has(y2))));
  }, I3 = (c2) => {
    c2.sourceSpan && c2.endSourceSpan && (c2.sourceSpan = new h(c2.sourceSpan.start, c2.endSourceSpan.end));
  }, F = (c2) => {
    if (c2.type === "element") {
      let g2 = He(u ? c2.name : c2.name.toLowerCase());
      !c2.namespace || c2.namespace === g2.implicitNamespacePrefix || fe(c2) ? c2.tagDefinition = g2 : c2.tagDefinition = He("");
    }
  };
  return Qt(new class extends ft {
    visitExpansionCase(c2, g2) {
      n2 === "angular" && this.visitChildren(g2, (y2) => {
        y2(c2.expression);
      });
    }
    visit(c2) {
      C(c2), F(c2), D(c2), I3(c2);
    }
  }(), l2), l2;
}
function tu(t8, e2) {
  var n2;
  if (t8.type !== "element" || t8.name !== "template") return false;
  let r2 = (n2 = t8.attrs.find((s2) => s2.name === "lang")) == null ? void 0 : n2.value;
  return !r2 || Ne(e2, { language: r2 }) === "html";
}
function Ci(t8) {
  let { msg: e2, span: { start: r2, end: n2 } } = t8;
  throw hi(e2, { loc: { start: { line: r2.line + 1, column: r2.col + 1 }, end: { line: n2.line + 1, column: n2.col + 1 } }, cause: t8 });
}
function _i(t8, e2, r2 = {}, n2 = true) {
  let { frontMatter: s2, content: i } = n2 ? mi(t8) : { frontMatter: null, content: t8 }, a = new ve(t8, r2.filepath), o2 = new ie(a, 0, 0, 0), u = o2.moveBy(t8.length), p = { type: "root", sourceSpan: new h(o2, u), children: Si(i, e2, r2) };
  if (s2) {
    let f = new ie(a, 0, 0, 0), C = f.moveBy(s2.raw.length);
    s2.sourceSpan = new h(f, C), p.children.unshift(s2);
  }
  let l2 = new or(p), m = (f, C) => {
    let { offset: A } = C, D = w(false, t8.slice(0, A), /[^\n\r]/gu, " "), F = _i(D + f, e2, r2, false);
    F.sourceSpan = new h(C, K(false, F.children, -1).sourceSpan.end);
    let c2 = F.children[0];
    return c2.length === A ? F.children.shift() : (c2.sourceSpan = new h(c2.sourceSpan.start.moveBy(A), c2.sourceSpan.end), c2.value = c2.value.slice(A)), F;
  };
  return l2.walk((f) => {
    if (f.type === "comment") {
      let C = di(f, m);
      C && f.parent.replaceChild(f, C);
    }
    Jo(f), Zo(f), eu(f);
  }), l2;
}
function Et(t8) {
  return { parse: (e2, r2) => _i(e2, t8, r2), hasPragma: ws2, hasIgnorePragma: bs, astFormat: "html", locStart: J, locEnd: se };
}
var en = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true };
var ru = Et(en);
var nu = /* @__PURE__ */ new Set(["mj-style", "mj-raw"]);
var su = Et({ ...en, name: "mjml", shouldParseAsRawText: (t8) => nu.has(t8) });
var iu = Et({ name: "angular" });
var au = Et({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t8, e2, r2, n2) {
  return t8.toLowerCase() !== "html" && !r2 && (t8 !== "template" || n2.some(({ name: s2, value: i }) => s2 === "lang" && i !== "html" && i !== "" && i !== void 0));
} });
var ou = Et({ name: "lwc", canSelfClose: false });
var uu = { html: qs };
var ym = rn;

// node_modules/prettier/standalone.mjs
var Fu = Object.create;
var pt2 = Object.defineProperty;
var pu = Object.getOwnPropertyDescriptor;
var du = Object.getOwnPropertyNames;
var mu = Object.getPrototypeOf;
var Eu = Object.prototype.hasOwnProperty;
var er = (e2) => {
  throw TypeError(e2);
};
var Cu = (e2, t8) => () => (t8 || e2((t8 = { exports: {} }).exports, t8), t8.exports);
var dt = (e2, t8) => {
  for (var r2 in t8) pt2(e2, r2, { get: t8[r2], enumerable: true });
};
var hu = (e2, t8, r2, n2) => {
  if (t8 && typeof t8 == "object" || typeof t8 == "function") for (let u of du(t8)) !Eu.call(e2, u) && u !== r2 && pt2(e2, u, { get: () => t8[u], enumerable: !(n2 = pu(t8, u)) || n2.enumerable });
  return e2;
};
var gu = (e2, t8, r2) => (r2 = e2 != null ? Fu(mu(e2)) : {}, hu(t8 || !e2 || !e2.__esModule ? pt2(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var yu = (e2, t8, r2) => t8.has(e2) || er("Cannot " + r2);
var tr = (e2, t8, r2) => t8.has(e2) ? er("Cannot add the same private member more than once") : t8 instanceof WeakSet ? t8.add(e2) : t8.set(e2, r2);
var fe2 = (e2, t8, r2) => (yu(e2, t8, "access private method"), r2);
var Pn2 = Cu((Mt3) => {
  "use strict";
  Object.defineProperty(Mt3, "__esModule", { value: true });
  function Co2() {
    return new Proxy({}, { get: () => (e2) => e2 });
  }
  var On3 = /\r\n|[\n\r\u2028\u2029]/;
  function ho3(e2, t8, r2) {
    let n2 = Object.assign({ column: 0, line: -1 }, e2.start), u = Object.assign({}, n2, e2.end), { linesAbove: o2 = 2, linesBelow: i = 3 } = r2 || {}, s2 = n2.line, a = n2.column, c2 = u.line, D = u.column, p = Math.max(s2 - (o2 + 1), 0), l2 = Math.min(t8.length, c2 + i);
    s2 === -1 && (p = 0), c2 === -1 && (l2 = t8.length);
    let F = c2 - s2, f = {};
    if (F) for (let d2 = 0; d2 <= F; d2++) {
      let m = d2 + s2;
      if (!a) f[m] = true;
      else if (d2 === 0) {
        let C = t8[m - 1].length;
        f[m] = [a, C - a + 1];
      } else if (d2 === F) f[m] = [0, D];
      else {
        let C = t8[m - d2].length;
        f[m] = [0, C];
      }
    }
    else a === D ? a ? f[s2] = [a, 0] : f[s2] = true : f[s2] = [a, D - a];
    return { start: p, end: l2, markerLines: f };
  }
  function go3(e2, t8, r2 = {}) {
    let u = Co2(false), o2 = e2.split(On3), { start: i, end: s2, markerLines: a } = ho3(t8, o2, r2), c2 = t8.start && typeof t8.start.column == "number", D = String(s2).length, l2 = e2.split(On3, s2).slice(i, s2).map((F, f) => {
      let d2 = i + 1 + f, C = ` ${` ${d2}`.slice(-D)} |`, E2 = a[d2], h7 = !a[d2 + 1];
      if (E2) {
        let x = "";
        if (Array.isArray(E2)) {
          let A = F.slice(0, Math.max(E2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = E2[1] || 1;
          x = [`
 `, u.gutter(C.replace(/\d/g, " ")), " ", A, u.marker("^").repeat($2)].join(""), h7 && r2.message && (x += " " + u.message(r2.message));
        }
        return [u.marker(">"), u.gutter(C), F.length > 0 ? ` ${F}` : "", x].join("");
      } else return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r2.message && !c2 && (l2 = `${" ".repeat(D + 1)}${r2.message}
${l2}`), l2;
  }
  Mt3.codeFrameColumns = go3;
});
var Zt = {};
dt(Zt, { __debug: () => ui, check: () => ri2, doc: () => qt2, format: () => fu, formatWithCursor: () => cu, getSupportInfo: () => ni2, util: () => Qt2, version: () => tu2 });
var Au = (e2, t8, r2, n2) => {
  if (!(e2 && t8 == null)) return t8.replaceAll ? t8.replaceAll(r2, n2) : r2.global ? t8.replace(r2, n2) : t8.split(r2).join(n2);
};
var te = Au;
var _e2 = class {
  diff(t8, r2, n2 = {}) {
    let u;
    typeof n2 == "function" ? (u = n2, n2 = {}) : "callback" in n2 && (u = n2.callback);
    let o2 = this.castInput(t8, n2), i = this.castInput(r2, n2), s2 = this.removeEmpty(this.tokenize(o2, n2)), a = this.removeEmpty(this.tokenize(i, n2));
    return this.diffWithOptionsObj(s2, a, n2, u);
  }
  diffWithOptionsObj(t8, r2, n2, u) {
    var o2;
    let i = (E2) => {
      if (E2 = this.postProcess(E2, n2), u) {
        setTimeout(function() {
          u(E2);
        }, 0);
        return;
      } else return E2;
    }, s2 = r2.length, a = t8.length, c2 = 1, D = s2 + a;
    n2.maxEditLength != null && (D = Math.min(D, n2.maxEditLength));
    let p = (o2 = n2.timeout) !== null && o2 !== void 0 ? o2 : 1 / 0, l2 = Date.now() + p, F = [{ oldPos: -1, lastComponent: void 0 }], f = this.extractCommon(F[0], r2, t8, 0, n2);
    if (F[0].oldPos + 1 >= a && f + 1 >= s2) return i(this.buildValues(F[0].lastComponent, r2, t8));
    let d2 = -1 / 0, m = 1 / 0, C = () => {
      for (let E2 = Math.max(d2, -c2); E2 <= Math.min(m, c2); E2 += 2) {
        let h7, x = F[E2 - 1], A = F[E2 + 1];
        x && (F[E2 - 1] = void 0);
        let $2 = false;
        if (A) {
          let Be3 = A.oldPos - E2;
          $2 = A && 0 <= Be3 && Be3 < s2;
        }
        let ue = x && x.oldPos + 1 < a;
        if (!$2 && !ue) {
          F[E2] = void 0;
          continue;
        }
        if (!ue || $2 && x.oldPos < A.oldPos ? h7 = this.addToPath(A, true, false, 0, n2) : h7 = this.addToPath(x, false, true, 1, n2), f = this.extractCommon(h7, r2, t8, E2, n2), h7.oldPos + 1 >= a && f + 1 >= s2) return i(this.buildValues(h7.lastComponent, r2, t8)) || true;
        F[E2] = h7, h7.oldPos + 1 >= a && (m = Math.min(m, E2 - 1)), f + 1 >= s2 && (d2 = Math.max(d2, E2 + 1));
      }
      c2++;
    };
    if (u) (function E2() {
      setTimeout(function() {
        if (c2 > D || Date.now() > l2) return u(void 0);
        C() || E2();
      }, 0);
    })();
    else for (; c2 <= D && Date.now() <= l2; ) {
      let E2 = C();
      if (E2) return E2;
    }
  }
  addToPath(t8, r2, n2, u, o2) {
    let i = t8.lastComponent;
    return i && !o2.oneChangePerToken && i.added === r2 && i.removed === n2 ? { oldPos: t8.oldPos + u, lastComponent: { count: i.count + 1, added: r2, removed: n2, previousComponent: i.previousComponent } } : { oldPos: t8.oldPos + u, lastComponent: { count: 1, added: r2, removed: n2, previousComponent: i } };
  }
  extractCommon(t8, r2, n2, u, o2) {
    let i = r2.length, s2 = n2.length, a = t8.oldPos, c2 = a - u, D = 0;
    for (; c2 + 1 < i && a + 1 < s2 && this.equals(n2[a + 1], r2[c2 + 1], o2); ) c2++, a++, D++, o2.oneChangePerToken && (t8.lastComponent = { count: 1, previousComponent: t8.lastComponent, added: false, removed: false });
    return D && !o2.oneChangePerToken && (t8.lastComponent = { count: D, previousComponent: t8.lastComponent, added: false, removed: false }), t8.oldPos = a, c2;
  }
  equals(t8, r2, n2) {
    return n2.comparator ? n2.comparator(t8, r2) : t8 === r2 || !!n2.ignoreCase && t8.toLowerCase() === r2.toLowerCase();
  }
  removeEmpty(t8) {
    let r2 = [];
    for (let n2 = 0; n2 < t8.length; n2++) t8[n2] && r2.push(t8[n2]);
    return r2;
  }
  castInput(t8, r2) {
    return t8;
  }
  tokenize(t8, r2) {
    return Array.from(t8);
  }
  join(t8) {
    return t8.join("");
  }
  postProcess(t8, r2) {
    return t8;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t8, r2, n2) {
    let u = [], o2;
    for (; t8; ) u.push(t8), o2 = t8.previousComponent, delete t8.previousComponent, t8 = o2;
    u.reverse();
    let i = u.length, s2 = 0, a = 0, c2 = 0;
    for (; s2 < i; s2++) {
      let D = u[s2];
      if (D.removed) D.value = this.join(n2.slice(c2, c2 + D.count)), c2 += D.count;
      else {
        if (!D.added && this.useLongestToken) {
          let p = r2.slice(a, a + D.count);
          p = p.map(function(l2, F) {
            let f = n2[c2 + F];
            return f.length > l2.length ? f : l2;
          }), D.value = this.join(p);
        } else D.value = this.join(r2.slice(a, a + D.count));
        a += D.count, D.added || (c2 += D.count);
      }
    }
    return u;
  }
};
var mt2 = class extends _e2 {
  tokenize(t8) {
    return t8.slice();
  }
  join(t8) {
    return t8;
  }
  removeEmpty(t8) {
    return t8;
  }
};
var rr2 = new mt2();
function Et2(e2, t8, r2) {
  return rr2.diff(e2, t8, r2);
}
function nr2(e2) {
  let t8 = e2.indexOf("\r");
  return t8 !== -1 ? e2.charAt(t8 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function xe2(e2) {
  switch (e2) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Ct2(e2, t8) {
  let r2;
  switch (t8) {
    case `
`:
      r2 = /\n/gu;
      break;
    case "\r":
      r2 = /\r/gu;
      break;
    case `\r
`:
      r2 = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t8)}.`);
  }
  let n2 = e2.match(r2);
  return n2 ? n2.length : 0;
}
function ur2(e2) {
  return te(false, e2, /\r\n?/gu, `
`);
}
var W2 = "string";
var Y2 = "array";
var j2 = "cursor";
var N2 = "indent";
var O2 = "align";
var P2 = "trim";
var B2 = "group";
var k2 = "fill";
var _2 = "if-break";
var v2 = "indent-if-break";
var L2 = "line-suffix";
var I2 = "line-suffix-boundary";
var g = "line";
var S2 = "label";
var w2 = "break-parent";
var Ue2 = /* @__PURE__ */ new Set([j2, N2, O2, P2, B2, k2, _2, v2, L2, I2, g, S2, w2]);
var Bu = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) return Array.isArray(t8) || typeof t8 == "string" ? t8[r2 < 0 ? t8.length + r2 : r2] : t8.at(r2);
};
var y = Bu;
function or2(e2) {
  let t8 = e2.length;
  for (; t8 > 0 && (e2[t8 - 1] === "\r" || e2[t8 - 1] === `
`); ) t8--;
  return t8 < e2.length ? e2.slice(0, t8) : e2;
}
function _u(e2) {
  if (typeof e2 == "string") return W2;
  if (Array.isArray(e2)) return Y2;
  if (!e2) return;
  let { type: t8 } = e2;
  if (Ue2.has(t8)) return t8;
}
var M = _u;
var xu = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
function wu(e2) {
  let t8 = e2 === null ? "null" : typeof e2;
  if (t8 !== "string" && t8 !== "object") return `Unexpected doc '${t8}', 
Expected it to be 'string' or 'object'.`;
  if (M(e2)) throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(e2);
  if (r2 !== "[object Object]") return `Unexpected doc '${r2}'.`;
  let n2 = xu([...Ue2].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
}
var ht2 = class extends Error {
  constructor(t8) {
    super(wu(t8));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t8;
  }
};
var q = ht2;
var ir2 = {};
function bu(e2, t8, r2, n2) {
  let u = [e2];
  for (; u.length > 0; ) {
    let o2 = u.pop();
    if (o2 === ir2) {
      r2(u.pop());
      continue;
    }
    r2 && u.push(o2, ir2);
    let i = M(o2);
    if (!i) throw new q(o2);
    if ((t8 == null ? void 0 : t8(o2)) !== false) switch (i) {
      case Y2:
      case k2: {
        let s2 = i === Y2 ? o2 : o2.parts;
        for (let a = s2.length, c2 = a - 1; c2 >= 0; --c2) u.push(s2[c2]);
        break;
      }
      case _2:
        u.push(o2.flatContents, o2.breakContents);
        break;
      case B2:
        if (n2 && o2.expandedStates) for (let s2 = o2.expandedStates.length, a = s2 - 1; a >= 0; --a) u.push(o2.expandedStates[a]);
        else u.push(o2.contents);
        break;
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        u.push(o2.contents);
        break;
      case W2:
      case j2:
      case P2:
      case I2:
      case g:
      case w2:
        break;
      default:
        throw new q(o2);
    }
  }
}
var le2 = bu;
function be2(e2, t8) {
  if (typeof e2 == "string") return t8(e2);
  let r2 = /* @__PURE__ */ new Map();
  return n2(e2);
  function n2(o2) {
    if (r2.has(o2)) return r2.get(o2);
    let i = u(o2);
    return r2.set(o2, i), i;
  }
  function u(o2) {
    switch (M(o2)) {
      case Y2:
        return t8(o2.map(n2));
      case k2:
        return t8({ ...o2, parts: o2.parts.map(n2) });
      case _2:
        return t8({ ...o2, breakContents: n2(o2.breakContents), flatContents: n2(o2.flatContents) });
      case B2: {
        let { expandedStates: i, contents: s2 } = o2;
        return i ? (i = i.map(n2), s2 = i[0]) : s2 = n2(s2), t8({ ...o2, contents: s2, expandedStates: i });
      }
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        return t8({ ...o2, contents: n2(o2.contents) });
      case W2:
      case j2:
      case P2:
      case I2:
      case g:
      case w2:
        return t8(o2);
      default:
        throw new q(o2);
    }
  }
}
function Ve2(e2, t8, r2) {
  let n2 = r2, u = false;
  function o2(i) {
    if (u) return false;
    let s2 = t8(i);
    s2 !== void 0 && (u = true, n2 = s2);
  }
  return le2(e2, o2), n2;
}
function ku(e2) {
  if (e2.type === B2 && e2.break || e2.type === g && e2.hard || e2.type === w2) return true;
}
function Dr2(e2) {
  return Ve2(e2, ku, false);
}
function sr2(e2) {
  if (e2.length > 0) {
    let t8 = y(false, e2, -1);
    !t8.expandedStates && !t8.break && (t8.break = "propagated");
  }
  return null;
}
function cr2(e2) {
  let t8 = /* @__PURE__ */ new Set(), r2 = [];
  function n2(o2) {
    if (o2.type === w2 && sr2(r2), o2.type === B2) {
      if (r2.push(o2), t8.has(o2)) return false;
      t8.add(o2);
    }
  }
  function u(o2) {
    o2.type === B2 && r2.pop().break && sr2(r2);
  }
  le2(e2, n2, u, true);
}
function Su(e2) {
  return e2.type === g && !e2.hard ? e2.soft ? "" : " " : e2.type === _2 ? e2.flatContents : e2;
}
function fr2(e2) {
  return be2(e2, Su);
}
function ar2(e2) {
  for (e2 = [...e2]; e2.length >= 2 && y(false, e2, -2).type === g && y(false, e2, -1).type === w2; ) e2.length -= 2;
  if (e2.length > 0) {
    let t8 = we2(y(false, e2, -1));
    e2[e2.length - 1] = t8;
  }
  return e2;
}
function we2(e2) {
  switch (M(e2)) {
    case N2:
    case v2:
    case B2:
    case L2:
    case S2: {
      let t8 = we2(e2.contents);
      return { ...e2, contents: t8 };
    }
    case _2:
      return { ...e2, breakContents: we2(e2.breakContents), flatContents: we2(e2.flatContents) };
    case k2:
      return { ...e2, parts: ar2(e2.parts) };
    case Y2:
      return ar2(e2);
    case W2:
      return or2(e2);
    case O2:
    case j2:
    case P2:
    case I2:
    case g:
    case w2:
      break;
    default:
      throw new q(e2);
  }
  return e2;
}
function $e(e2) {
  return we2(Nu(e2));
}
function Tu(e2) {
  switch (M(e2)) {
    case k2:
      if (e2.parts.every((t8) => t8 === "")) return "";
      break;
    case B2:
      if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates) return "";
      if (e2.contents.type === B2 && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates) return e2.contents;
      break;
    case O2:
    case N2:
    case v2:
    case L2:
      if (!e2.contents) return "";
      break;
    case _2:
      if (!e2.flatContents && !e2.breakContents) return "";
      break;
    case Y2: {
      let t8 = [];
      for (let r2 of e2) {
        if (!r2) continue;
        let [n2, ...u] = Array.isArray(r2) ? r2 : [r2];
        typeof n2 == "string" && typeof y(false, t8, -1) == "string" ? t8[t8.length - 1] += n2 : t8.push(n2), t8.push(...u);
      }
      return t8.length === 0 ? "" : t8.length === 1 ? t8[0] : t8;
    }
    case W2:
    case j2:
    case P2:
    case I2:
    case g:
    case S2:
    case w2:
      break;
    default:
      throw new q(e2);
  }
  return e2;
}
function Nu(e2) {
  return be2(e2, (t8) => Tu(t8));
}
function lr2(e2, t8 = We) {
  return be2(e2, (r2) => typeof r2 == "string" ? ke2(t8, r2.split(`
`)) : r2);
}
function Ou(e2) {
  if (e2.type === g) return true;
}
function Fr2(e2) {
  return Ve2(e2, Ou, false);
}
function Fe2(e2, t8) {
  return e2.type === S2 ? { ...e2, contents: t8(e2.contents) } : t8(e2);
}
var gt2 = () => {
};
var K2 = gt2;
var yt2 = gt2;
var pr2 = gt2;
function ie2(e2) {
  return K2(e2), { type: N2, contents: e2 };
}
function oe(e2, t8) {
  return K2(t8), { type: O2, contents: t8, n: e2 };
}
function At2(e2, t8 = {}) {
  return K2(e2), yt2(t8.expandedStates, true), { type: B2, id: t8.id, contents: e2, break: !!t8.shouldBreak, expandedStates: t8.expandedStates };
}
function dr2(e2) {
  return oe(Number.NEGATIVE_INFINITY, e2);
}
function mr2(e2) {
  return oe({ type: "root" }, e2);
}
function Er2(e2) {
  return oe(-1, e2);
}
function Cr2(e2, t8) {
  return At2(e2[0], { ...t8, expandedStates: e2 });
}
function hr2(e2) {
  return pr2(e2), { type: k2, parts: e2 };
}
function gr2(e2, t8 = "", r2 = {}) {
  return K2(e2), t8 !== "" && K2(t8), { type: _2, breakContents: e2, flatContents: t8, groupId: r2.groupId };
}
function yr2(e2, t8) {
  return K2(e2), { type: v2, contents: e2, groupId: t8.groupId, negate: t8.negate };
}
function Se2(e2) {
  return K2(e2), { type: L2, contents: e2 };
}
var Ar2 = { type: I2 };
var pe2 = { type: w2 };
var Br2 = { type: P2 };
var Te2 = { type: g, hard: true };
var Bt2 = { type: g, hard: true, literal: true };
var Me2 = { type: g };
var _r2 = { type: g, soft: true };
var z2 = [Te2, pe2];
var We = [Bt2, pe2];
var X2 = { type: j2 };
function ke2(e2, t8) {
  K2(e2), yt2(t8);
  let r2 = [];
  for (let n2 = 0; n2 < t8.length; n2++) n2 !== 0 && r2.push(e2), r2.push(t8[n2]);
  return r2;
}
function Ge3(e2, t8, r2) {
  K2(e2);
  let n2 = e2;
  if (t8 > 0) {
    for (let u = 0; u < Math.floor(t8 / r2); ++u) n2 = ie2(n2);
    n2 = oe(t8 % r2, n2), n2 = oe(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}
function xr2(e2, t8) {
  return K2(t8), e2 ? { type: S2, label: e2, contents: t8 } : t8;
}
function Q2(e2) {
  var t8;
  if (!e2) return "";
  if (Array.isArray(e2)) {
    let r2 = [];
    for (let n2 of e2) if (Array.isArray(n2)) r2.push(...Q2(n2));
    else {
      let u = Q2(n2);
      u !== "" && r2.push(u);
    }
    return r2;
  }
  return e2.type === _2 ? { ...e2, breakContents: Q2(e2.breakContents), flatContents: Q2(e2.flatContents) } : e2.type === B2 ? { ...e2, contents: Q2(e2.contents), expandedStates: (t8 = e2.expandedStates) == null ? void 0 : t8.map(Q2) } : e2.type === k2 ? { type: "fill", parts: e2.parts.map(Q2) } : e2.contents ? { ...e2, contents: Q2(e2.contents) } : e2;
}
function wr2(e2) {
  let t8 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Set();
  return n2(Q2(e2));
  function n2(o2, i, s2) {
    var a, c2;
    if (typeof o2 == "string") return JSON.stringify(o2);
    if (Array.isArray(o2)) {
      let D = o2.map(n2).filter(Boolean);
      return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
    }
    if (o2.type === g) {
      let D = ((a = s2 == null ? void 0 : s2[i + 1]) == null ? void 0 : a.type) === w2;
      return o2.literal ? D ? "literalline" : "literallineWithoutBreakParent" : o2.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : o2.soft ? "softline" : "line";
    }
    if (o2.type === w2) return ((c2 = s2 == null ? void 0 : s2[i - 1]) == null ? void 0 : c2.type) === g && s2[i - 1].hard ? void 0 : "breakParent";
    if (o2.type === P2) return "trim";
    if (o2.type === N2) return "indent(" + n2(o2.contents) + ")";
    if (o2.type === O2) return o2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n2(o2.contents) + ")" : o2.n < 0 ? "dedent(" + n2(o2.contents) + ")" : o2.n.type === "root" ? "markAsRoot(" + n2(o2.contents) + ")" : "align(" + JSON.stringify(o2.n) + ", " + n2(o2.contents) + ")";
    if (o2.type === _2) return "ifBreak(" + n2(o2.breakContents) + (o2.flatContents ? ", " + n2(o2.flatContents) : "") + (o2.groupId ? (o2.flatContents ? "" : ', ""') + `, { groupId: ${u(o2.groupId)} }` : "") + ")";
    if (o2.type === v2) {
      let D = [];
      o2.negate && D.push("negate: true"), o2.groupId && D.push(`groupId: ${u(o2.groupId)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return `indentIfBreak(${n2(o2.contents)}${p})`;
    }
    if (o2.type === B2) {
      let D = [];
      o2.break && o2.break !== "propagated" && D.push("shouldBreak: true"), o2.id && D.push(`id: ${u(o2.id)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return o2.expandedStates ? `conditionalGroup([${o2.expandedStates.map((l2) => n2(l2)).join(",")}]${p})` : `group(${n2(o2.contents)}${p})`;
    }
    if (o2.type === k2) return `fill([${o2.parts.map((D) => n2(D)).join(", ")}])`;
    if (o2.type === L2) return "lineSuffix(" + n2(o2.contents) + ")";
    if (o2.type === I2) return "lineSuffixBoundary";
    if (o2.type === S2) return `label(${JSON.stringify(o2.label)}, ${n2(o2.contents)})`;
    if (o2.type === j2) return "cursor";
    throw new Error("Unknown doc type " + o2.type);
  }
  function u(o2) {
    if (typeof o2 != "symbol") return JSON.stringify(String(o2));
    if (o2 in t8) return t8[o2];
    let i = o2.description || "symbol";
    for (let s2 = 0; ; s2++) {
      let a = i + (s2 > 0 ? ` #${s2}` : "");
      if (!r2.has(a)) return r2.add(a), t8[o2] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
var br2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function kr2(e2) {
  return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
}
function Sr2(e2) {
  return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9776 && e2 <= 9783 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 >= 9866 && e2 <= 9871 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12773 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101631 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 >= 119552 && e2 <= 119638 || e2 >= 119648 && e2 <= 119670 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129673 || e2 >= 129679 && e2 <= 129734 || e2 >= 129742 && e2 <= 129756 || e2 >= 129759 && e2 <= 129769 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
}
var Tr2 = (e2) => !(kr2(e2) || Sr2(e2));
var Pu = /[^\x20-\x7F]/u;
function vu(e2) {
  if (!e2) return 0;
  if (!Pu.test(e2)) return e2.length;
  e2 = e2.replace(br2(), "  ");
  let t8 = 0;
  for (let r2 of e2) {
    let n2 = r2.codePointAt(0);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t8 += Tr2(n2) ? 1 : 2);
  }
  return t8;
}
var Ne2 = vu;
var R2 = Symbol("MODE_BREAK");
var H2 = Symbol("MODE_FLAT");
var de2 = Symbol("cursor");
var _t2 = Symbol("DOC_FILL_PRINTED_LENGTH");
function Nr2() {
  return { value: "", length: 0, queue: [] };
}
function Lu(e2, t8) {
  return xt2(e2, { type: "indent" }, t8);
}
function Iu(e2, t8, r2) {
  return t8 === Number.NEGATIVE_INFINITY ? e2.root || Nr2() : t8 < 0 ? xt2(e2, { type: "dedent" }, r2) : t8 ? t8.type === "root" ? { ...e2, root: e2 } : xt2(e2, { type: typeof t8 == "string" ? "stringAlign" : "numberAlign", n: t8 }, r2) : e2;
}
function xt2(e2, t8, r2) {
  let n2 = t8.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t8], u = "", o2 = 0, i = 0, s2 = 0;
  for (let f of n2) switch (f.type) {
    case "indent":
      D(), r2.useTabs ? a(1) : c2(r2.tabWidth);
      break;
    case "stringAlign":
      D(), u += f.n, o2 += f.n.length;
      break;
    case "numberAlign":
      i += 1, s2 += f.n;
      break;
    default:
      throw new Error(`Unexpected type '${f.type}'`);
  }
  return l2(), { ...e2, value: u, length: o2, queue: n2 };
  function a(f) {
    u += "	".repeat(f), o2 += r2.tabWidth * f;
  }
  function c2(f) {
    u += " ".repeat(f), o2 += f;
  }
  function D() {
    r2.useTabs ? p() : l2();
  }
  function p() {
    i > 0 && a(i), F();
  }
  function l2() {
    s2 > 0 && c2(s2), F();
  }
  function F() {
    i = 0, s2 = 0;
  }
}
function wt2(e2) {
  let t8 = 0, r2 = 0, n2 = e2.length;
  e: for (; n2--; ) {
    let u = e2[n2];
    if (u === de2) {
      r2++;
      continue;
    }
    for (let o2 = u.length - 1; o2 >= 0; o2--) {
      let i = u[o2];
      if (i === " " || i === "	") t8++;
      else {
        e2[n2] = u.slice(0, o2 + 1);
        break e;
      }
    }
  }
  if (t8 > 0 || r2 > 0) for (e2.length = n2 + 1; r2-- > 0; ) e2.push(de2);
  return t8;
}
function Ke2(e2, t8, r2, n2, u, o2) {
  if (r2 === Number.POSITIVE_INFINITY) return true;
  let i = t8.length, s2 = [e2], a = [];
  for (; r2 >= 0; ) {
    if (s2.length === 0) {
      if (i === 0) return true;
      s2.push(t8[--i]);
      continue;
    }
    let { mode: c2, doc: D } = s2.pop(), p = M(D);
    switch (p) {
      case W2:
        a.push(D), r2 -= Ne2(D);
        break;
      case Y2:
      case k2: {
        let l2 = p === Y2 ? D : D.parts, F = D[_t2] ?? 0;
        for (let f = l2.length - 1; f >= F; f--) s2.push({ mode: c2, doc: l2[f] });
        break;
      }
      case N2:
      case O2:
      case v2:
      case S2:
        s2.push({ mode: c2, doc: D.contents });
        break;
      case P2:
        r2 += wt2(a);
        break;
      case B2: {
        if (o2 && D.break) return false;
        let l2 = D.break ? R2 : c2, F = D.expandedStates && l2 === R2 ? y(false, D.expandedStates, -1) : D.contents;
        s2.push({ mode: l2, doc: F });
        break;
      }
      case _2: {
        let F = (D.groupId ? u[D.groupId] || H2 : c2) === R2 ? D.breakContents : D.flatContents;
        F && s2.push({ mode: c2, doc: F });
        break;
      }
      case g:
        if (c2 === R2 || D.hard) return true;
        D.soft || (a.push(" "), r2--);
        break;
      case L2:
        n2 = true;
        break;
      case I2:
        if (n2) return false;
        break;
    }
  }
  return false;
}
function me2(e2, t8) {
  let r2 = {}, n2 = t8.printWidth, u = xe2(t8.endOfLine), o2 = 0, i = [{ ind: Nr2(), mode: R2, doc: e2 }], s2 = [], a = false, c2 = [], D = 0;
  for (cr2(e2); i.length > 0; ) {
    let { ind: l2, mode: F, doc: f } = i.pop();
    switch (M(f)) {
      case W2: {
        let d2 = u !== `
` ? te(false, f, `
`, u) : f;
        s2.push(d2), i.length > 0 && (o2 += Ne2(d2));
        break;
      }
      case Y2:
        for (let d2 = f.length - 1; d2 >= 0; d2--) i.push({ ind: l2, mode: F, doc: f[d2] });
        break;
      case j2:
        if (D >= 2) throw new Error("There are too many 'cursor' in doc.");
        s2.push(de2), D++;
        break;
      case N2:
        i.push({ ind: Lu(l2, t8), mode: F, doc: f.contents });
        break;
      case O2:
        i.push({ ind: Iu(l2, f.n, t8), mode: F, doc: f.contents });
        break;
      case P2:
        o2 -= wt2(s2);
        break;
      case B2:
        switch (F) {
          case H2:
            if (!a) {
              i.push({ ind: l2, mode: f.break ? R2 : H2, doc: f.contents });
              break;
            }
          case R2: {
            a = false;
            let d2 = { ind: l2, mode: H2, doc: f.contents }, m = n2 - o2, C = c2.length > 0;
            if (!f.break && Ke2(d2, i, m, C, r2)) i.push(d2);
            else if (f.expandedStates) {
              let E2 = y(false, f.expandedStates, -1);
              if (f.break) {
                i.push({ ind: l2, mode: R2, doc: E2 });
                break;
              } else for (let h7 = 1; h7 < f.expandedStates.length + 1; h7++) if (h7 >= f.expandedStates.length) {
                i.push({ ind: l2, mode: R2, doc: E2 });
                break;
              } else {
                let x = f.expandedStates[h7], A = { ind: l2, mode: H2, doc: x };
                if (Ke2(A, i, m, C, r2)) {
                  i.push(A);
                  break;
                }
              }
            } else i.push({ ind: l2, mode: R2, doc: f.contents });
            break;
          }
        }
        f.id && (r2[f.id] = y(false, i, -1).mode);
        break;
      case k2: {
        let d2 = n2 - o2, m = f[_t2] ?? 0, { parts: C } = f, E2 = C.length - m;
        if (E2 === 0) break;
        let h7 = C[m + 0], x = C[m + 1], A = { ind: l2, mode: H2, doc: h7 }, $2 = { ind: l2, mode: R2, doc: h7 }, ue = Ke2(A, [], d2, c2.length > 0, r2, true);
        if (E2 === 1) {
          ue ? i.push(A) : i.push($2);
          break;
        }
        let Be3 = { ind: l2, mode: H2, doc: x }, lt3 = { ind: l2, mode: R2, doc: x };
        if (E2 === 2) {
          ue ? i.push(Be3, A) : i.push(lt3, $2);
          break;
        }
        let lu = C[m + 2], Ft3 = { ind: l2, mode: F, doc: { ...f, [_t2]: m + 2 } };
        Ke2({ ind: l2, mode: H2, doc: [h7, x, lu] }, [], d2, c2.length > 0, r2, true) ? i.push(Ft3, Be3, A) : ue ? i.push(Ft3, lt3, A) : i.push(Ft3, lt3, $2);
        break;
      }
      case _2:
      case v2: {
        let d2 = f.groupId ? r2[f.groupId] : F;
        if (d2 === R2) {
          let m = f.type === _2 ? f.breakContents : f.negate ? f.contents : ie2(f.contents);
          m && i.push({ ind: l2, mode: F, doc: m });
        }
        if (d2 === H2) {
          let m = f.type === _2 ? f.flatContents : f.negate ? ie2(f.contents) : f.contents;
          m && i.push({ ind: l2, mode: F, doc: m });
        }
        break;
      }
      case L2:
        c2.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case I2:
        c2.length > 0 && i.push({ ind: l2, mode: F, doc: Te2 });
        break;
      case g:
        switch (F) {
          case H2:
            if (f.hard) a = true;
            else {
              f.soft || (s2.push(" "), o2 += 1);
              break;
            }
          case R2:
            if (c2.length > 0) {
              i.push({ ind: l2, mode: F, doc: f }, ...c2.reverse()), c2.length = 0;
              break;
            }
            f.literal ? l2.root ? (s2.push(u, l2.root.value), o2 = l2.root.length) : (s2.push(u), o2 = 0) : (o2 -= wt2(s2), s2.push(u + l2.value), o2 = l2.length);
            break;
        }
        break;
      case S2:
        i.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case w2:
        break;
      default:
        throw new q(f);
    }
    i.length === 0 && c2.length > 0 && (i.push(...c2.reverse()), c2.length = 0);
  }
  let p = s2.indexOf(de2);
  if (p !== -1) {
    let l2 = s2.indexOf(de2, p + 1);
    if (l2 === -1) return { formatted: s2.filter((m) => m !== de2).join("") };
    let F = s2.slice(0, p).join(""), f = s2.slice(p + 1, l2).join(""), d2 = s2.slice(l2 + 1).join("");
    return { formatted: F + f + d2, cursorNodeStart: F.length, cursorNodeText: f };
  }
  return { formatted: s2.join("") };
}
function Ru(e2, t8, r2 = 0) {
  let n2 = 0;
  for (let u = r2; u < e2.length; ++u) e2[u] === "	" ? n2 = n2 + t8 - n2 % t8 : n2++;
  return n2;
}
var Ee2 = Ru;
var Z2;
var kt2;
var ze2;
var bt2 = class {
  constructor(t8) {
    tr(this, Z2);
    this.stack = [t8];
  }
  get key() {
    let { stack: t8, siblings: r2 } = this;
    return y(false, t8, r2 === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t8 } = this, r2 = y(false, t8, -3);
    return Array.isArray(r2) ? r2 : null;
  }
  get next() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index + 1];
  }
  get previous() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t8, index: r2 } = this;
    return t8 !== null && r2 === t8.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...fe2(this, Z2, ze2).call(this)];
  }
  getName() {
    let { stack: t8 } = this, { length: r2 } = t8;
    return r2 > 1 ? y(false, t8, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t8 = 0) {
    let r2 = fe2(this, Z2, kt2).call(this, t8);
    return r2 === -1 ? null : this.stack[r2];
  }
  getParentNode(t8 = 0) {
    return this.getNode(t8 + 1);
  }
  call(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, o2 = y(false, n2, -1);
    for (let i of r2) o2 = o2[i], n2.push(i, o2);
    try {
      return t8(this);
    } finally {
      n2.length = u;
    }
  }
  callParent(t8, r2 = 0) {
    let n2 = fe2(this, Z2, kt2).call(this, r2 + 1), u = this.stack.splice(n2 + 1);
    try {
      return t8(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, o2 = y(false, n2, -1);
    for (let i of r2) o2 = o2[i], n2.push(i, o2);
    try {
      for (let i = 0; i < o2.length; ++i) n2.push(i, o2[i]), t8(this, i, o2), n2.length -= 2;
    } finally {
      n2.length = u;
    }
  }
  map(t8, ...r2) {
    let n2 = [];
    return this.each((u, o2, i) => {
      n2[o2] = t8(u, o2, i);
    }, ...r2), n2;
  }
  match(...t8) {
    let r2 = this.stack.length - 1, n2 = null, u = this.stack[r2--];
    for (let o2 of t8) {
      if (u === void 0) return false;
      let i = null;
      if (typeof n2 == "number" && (i = n2, n2 = this.stack[r2--], u = this.stack[r2--]), o2 && !o2(u, n2, i)) return false;
      n2 = this.stack[r2--], u = this.stack[r2--];
    }
    return true;
  }
  findAncestor(t8) {
    for (let r2 of fe2(this, Z2, ze2).call(this)) if (t8(r2)) return r2;
  }
  hasAncestor(t8) {
    for (let r2 of fe2(this, Z2, ze2).call(this)) if (t8(r2)) return true;
    return false;
  }
};
Z2 = /* @__PURE__ */ new WeakSet(), kt2 = function(t8) {
  let { stack: r2 } = this;
  for (let n2 = r2.length - 1; n2 >= 0; n2 -= 2) if (!Array.isArray(r2[n2]) && --t8 < 0) return n2;
  return -1;
}, ze2 = function* () {
  let { stack: t8 } = this;
  for (let r2 = t8.length - 3; r2 >= 0; r2 -= 2) {
    let n2 = t8[r2];
    Array.isArray(n2) || (yield n2);
  }
};
var Or2 = bt2;
var Pr2 = new Proxy(() => {
}, { get: () => Pr2 });
var Oe2 = Pr2;
function Yu(e2) {
  return e2 !== null && typeof e2 == "object";
}
var vr2 = Yu;
function* Ce2(e2, t8) {
  let { getVisitorKeys: r2, filter: n2 = () => true } = t8, u = (o2) => vr2(o2) && n2(o2);
  for (let o2 of r2(e2)) {
    let i = e2[o2];
    if (Array.isArray(i)) for (let s2 of i) u(s2) && (yield s2);
    else u(i) && (yield i);
  }
}
function* Lr2(e2, t8) {
  let r2 = [e2];
  for (let n2 = 0; n2 < r2.length; n2++) {
    let u = r2[n2];
    for (let o2 of Ce2(u, t8)) yield o2, r2.push(o2);
  }
}
function Ir2(e2, t8) {
  return Ce2(e2, t8).next().done;
}
function he2(e2) {
  return (t8, r2, n2) => {
    let u = !!(n2 != null && n2.backwards);
    if (r2 === false) return false;
    let { length: o2 } = t8, i = r2;
    for (; i >= 0 && i < o2; ) {
      let s2 = t8.charAt(i);
      if (e2 instanceof RegExp) {
        if (!e2.test(s2)) return i;
      } else if (!e2.includes(s2)) return i;
      u ? i-- : i++;
    }
    return i === -1 || i === o2 ? i : false;
  };
}
var Rr2 = he2(/\s/u);
var T2 = he2(" 	");
var He2 = he2(",; 	");
var Je2 = he2(/[^\n\r]/u);
function ju(e2, t8, r2) {
  let n2 = !!(r2 != null && r2.backwards);
  if (t8 === false) return false;
  let u = e2.charAt(t8);
  if (n2) {
    if (e2.charAt(t8 - 1) === "\r" && u === `
`) return t8 - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t8 - 1;
  } else {
    if (u === "\r" && e2.charAt(t8 + 1) === `
`) return t8 + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t8 + 1;
  }
  return t8;
}
var U = ju;
function Uu(e2, t8, r2 = {}) {
  let n2 = T2(e2, r2.backwards ? t8 - 1 : t8, r2), u = U(e2, n2, r2);
  return n2 !== u;
}
var G2 = Uu;
function Vu(e2) {
  return Array.isArray(e2) && e2.length > 0;
}
var qe2 = Vu;
var Yr = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var $u = (e2) => Object.keys(e2).filter((t8) => !Yr.has(t8));
function Wu(e2) {
  return e2 ? (t8) => e2(t8, Yr) : $u;
}
var J2 = Wu;
function Mu(e2) {
  let t8 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
  return r2.length > 20 && (r2 = r2.slice(0, 19) + "…"), t8 + (r2 ? " " + r2 : "");
}
function St2(e2, t8) {
  (e2.comments ?? (e2.comments = [])).push(t8), t8.printed = false, t8.nodeDescription = Mu(e2);
}
function se2(e2, t8) {
  t8.leading = true, t8.trailing = false, St2(e2, t8);
}
function ee2(e2, t8, r2) {
  t8.leading = false, t8.trailing = false, r2 && (t8.marker = r2), St2(e2, t8);
}
function ae2(e2, t8) {
  t8.leading = false, t8.trailing = true, St2(e2, t8);
}
var Tt2 = /* @__PURE__ */ new WeakMap();
function Xe2(e2, t8) {
  if (Tt2.has(e2)) return Tt2.get(e2);
  let { printer: { getCommentChildNodes: r2, canAttachComment: n2, getVisitorKeys: u }, locStart: o2, locEnd: i } = t8;
  if (!n2) return [];
  let s2 = ((r2 == null ? void 0 : r2(e2, t8)) ?? [...Ce2(e2, { getVisitorKeys: J2(u) })]).flatMap((a) => n2(a) ? [a] : Xe2(a, t8));
  return s2.sort((a, c2) => o2(a) - o2(c2) || i(a) - i(c2)), Tt2.set(e2, s2), s2;
}
function Ur2(e2, t8, r2, n2) {
  let { locStart: u, locEnd: o2 } = r2, i = u(t8), s2 = o2(t8), a = Xe2(e2, r2), c2, D, p = 0, l2 = a.length;
  for (; p < l2; ) {
    let F = p + l2 >> 1, f = a[F], d2 = u(f), m = o2(f);
    if (d2 <= i && s2 <= m) return Ur2(f, t8, r2, f);
    if (m <= i) {
      c2 = f, p = F + 1;
      continue;
    }
    if (s2 <= d2) {
      D = f, l2 = F;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n2 == null ? void 0 : n2.type) === "TemplateLiteral") {
    let { quasis: F } = n2, f = Ot2(F, t8, r2);
    c2 && Ot2(F, c2, r2) !== f && (c2 = null), D && Ot2(F, D, r2) !== f && (D = null);
  }
  return { enclosingNode: n2, precedingNode: c2, followingNode: D };
}
var Nt2 = () => false;
function Vr(e2, t8) {
  let { comments: r2 } = e2;
  if (delete e2.comments, !qe2(r2) || !t8.printer.canAttachComment) return;
  let n2 = [], { printer: { experimentalFeatures: { avoidAstMutation: u = false } = {}, handleComments: o2 = {} }, originalText: i } = t8, { ownLine: s2 = Nt2, endOfLine: a = Nt2, remaining: c2 = Nt2 } = o2, D = r2.map((p, l2) => ({ ...Ur2(e2, p, t8), comment: p, text: i, options: t8, ast: e2, isLastComment: r2.length - 1 === l2 }));
  for (let [p, l2] of D.entries()) {
    let { comment: F, precedingNode: f, enclosingNode: d2, followingNode: m, text: C, options: E2, ast: h7, isLastComment: x } = l2, A;
    if (u ? A = [l2] : (F.enclosingNode = d2, F.precedingNode = f, F.followingNode = m, A = [F, C, E2, h7, x]), Gu(C, E2, D, p)) F.placement = "ownLine", s2(...A) || (m ? se2(m, F) : f ? ae2(f, F) : d2 ? ee2(d2, F) : ee2(h7, F));
    else if (Ku(C, E2, D, p)) F.placement = "endOfLine", a(...A) || (f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h7, F));
    else if (F.placement = "remaining", !c2(...A)) if (f && m) {
      let $2 = n2.length;
      $2 > 0 && n2[$2 - 1].followingNode !== m && jr2(n2, E2), n2.push(l2);
    } else f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h7, F);
  }
  if (jr2(n2, t8), !u) for (let p of r2) delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
var $r2 = (e2) => !/[\S\n\u2028\u2029]/u.test(e2);
function Gu(e2, t8, r2, n2) {
  let { comment: u, precedingNode: o2 } = r2[n2], { locStart: i, locEnd: s2 } = t8, a = i(u);
  if (o2) for (let c2 = n2 - 1; c2 >= 0; c2--) {
    let { comment: D, precedingNode: p } = r2[c2];
    if (p !== o2 || !$r2(e2.slice(s2(D), a))) break;
    a = i(D);
  }
  return G2(e2, a, { backwards: true });
}
function Ku(e2, t8, r2, n2) {
  let { comment: u, followingNode: o2 } = r2[n2], { locStart: i, locEnd: s2 } = t8, a = s2(u);
  if (o2) for (let c2 = n2 + 1; c2 < r2.length; c2++) {
    let { comment: D, followingNode: p } = r2[c2];
    if (p !== o2 || !$r2(e2.slice(a, i(D)))) break;
    a = s2(D);
  }
  return G2(e2, a);
}
function jr2(e2, t8) {
  var s2, a;
  let r2 = e2.length;
  if (r2 === 0) return;
  let { precedingNode: n2, followingNode: u } = e2[0], o2 = t8.locStart(u), i;
  for (i = r2; i > 0; --i) {
    let { comment: c2, precedingNode: D, followingNode: p } = e2[i - 1];
    Oe2.strictEqual(D, n2), Oe2.strictEqual(p, u);
    let l2 = t8.originalText.slice(t8.locEnd(c2), o2);
    if (((a = (s2 = t8.printer).isGap) == null ? void 0 : a.call(s2, l2, t8)) ?? /^[\s(]*$/u.test(l2)) o2 = t8.locStart(c2);
    else break;
  }
  for (let [c2, { comment: D }] of e2.entries()) c2 < i ? ae2(n2, D) : se2(u, D);
  for (let c2 of [n2, u]) c2.comments && c2.comments.length > 1 && c2.comments.sort((D, p) => t8.locStart(D) - t8.locStart(p));
  e2.length = 0;
}
function Ot2(e2, t8, r2) {
  let n2 = r2.locStart(t8) - 1;
  for (let u = 1; u < e2.length; ++u) if (n2 < r2.locStart(e2[u])) return u - 1;
  return 0;
}
function zu(e2, t8) {
  let r2 = t8 - 1;
  r2 = T2(e2, r2, { backwards: true }), r2 = U(e2, r2, { backwards: true }), r2 = T2(e2, r2, { backwards: true });
  let n2 = U(e2, r2, { backwards: true });
  return r2 !== n2;
}
var Pe2 = zu;
function Wr2(e2, t8) {
  let r2 = e2.node;
  return r2.printed = true, t8.printer.printComment(e2, t8);
}
function Hu(e2, t8) {
  var D;
  let r2 = e2.node, n2 = [Wr2(e2, t8)], { printer: u, originalText: o2, locStart: i, locEnd: s2 } = t8;
  if ((D = u.isBlockComment) == null ? void 0 : D.call(u, r2)) {
    let p = G2(o2, s2(r2)) ? G2(o2, i(r2), { backwards: true }) ? z2 : Me2 : " ";
    n2.push(p);
  } else n2.push(z2);
  let c2 = U(o2, T2(o2, s2(r2)));
  return c2 !== false && G2(o2, c2) && n2.push(z2), n2;
}
function Ju(e2, t8, r2) {
  var c2;
  let n2 = e2.node, u = Wr2(e2, t8), { printer: o2, originalText: i, locStart: s2 } = t8, a = (c2 = o2.isBlockComment) == null ? void 0 : c2.call(o2, n2);
  if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || G2(i, s2(n2), { backwards: true })) {
    let D = Pe2(i, s2(n2));
    return { doc: Se2([z2, D ? z2 : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r2 != null && r2.hasLineSuffix ? { doc: [Se2([" ", u]), pe2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function qu(e2, t8) {
  let r2 = e2.node;
  if (!r2) return {};
  let n2 = t8[Symbol.for("printedComments")];
  if ((r2.comments || []).filter((a) => !n2.has(a)).length === 0) return { leading: "", trailing: "" };
  let o2 = [], i = [], s2;
  return e2.each(() => {
    let a = e2.node;
    if (n2 != null && n2.has(a)) return;
    let { leading: c2, trailing: D } = a;
    c2 ? o2.push(Hu(e2, t8)) : D && (s2 = Ju(e2, t8, s2), i.push(s2.doc));
  }, "comments"), { leading: o2, trailing: i };
}
function Mr(e2, t8, r2) {
  let { leading: n2, trailing: u } = qu(e2, r2);
  return !n2 && !u ? t8 : Fe2(t8, (o2) => [n2, o2, u]);
}
function Gr2(e2) {
  let { [Symbol.for("comments")]: t8, [Symbol.for("printedComments")]: r2 } = e2;
  for (let n2 of t8) {
    if (!n2.printed && !r2.has(n2)) throw new Error('Comment "' + n2.value.trim() + '" was not printed. Please report this error!');
    delete n2.printed;
  }
}
function Xu(e2) {
  return () => {
  };
}
var Kr2 = Xu;
var ve2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Le2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var zr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function Qe2({ plugins: e2 = [], showDeprecated: t8 = false } = {}) {
  let r2 = e2.flatMap((u) => u.languages ?? []), n2 = [];
  for (let u of Zu(Object.assign({}, ...e2.map(({ options: o2 }) => o2), zr))) !t8 && u.deprecated || (Array.isArray(u.choices) && (t8 || (u.choices = u.choices.filter((o2) => !o2.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...Qu(u.choices, r2, e2)])), u.pluginDefaults = Object.fromEntries(e2.filter((o2) => {
    var i;
    return ((i = o2.defaultOptions) == null ? void 0 : i[u.name]) !== void 0;
  }).map((o2) => [o2.name, o2.defaultOptions[u.name]])), n2.push(u));
  return { languages: r2, options: n2 };
}
function* Qu(e2, t8, r2) {
  let n2 = new Set(e2.map((u) => u.value));
  for (let u of t8) if (u.parsers) {
    for (let o2 of u.parsers) if (!n2.has(o2)) {
      n2.add(o2);
      let i = r2.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o2)), s2 = u.name;
      i != null && i.name && (s2 += ` (plugin: ${i.name})`), yield { value: o2, description: s2 };
    }
  }
}
function Zu(e2) {
  let t8 = [];
  for (let [r2, n2] of Object.entries(e2)) {
    let u = { name: r2, ...n2 };
    Array.isArray(u.default) && (u.default = y(false, u.default, -1).value), t8.push(u);
  }
  return t8;
}
var eo2 = (e2, t8) => {
  if (!(e2 && t8 == null)) return t8.toReversed || !Array.isArray(t8) ? t8.toReversed() : [...t8].reverse();
};
var Hr2 = eo2;
var Jr2;
var qr;
var Xr2;
var Qr2;
var Zr2;
var to2 = ((Jr2 = globalThis.Deno) == null ? void 0 : Jr2.build.os) === "windows" || ((Xr2 = (qr = globalThis.navigator) == null ? void 0 : qr.platform) == null ? void 0 : Xr2.startsWith("Win")) || ((Zr2 = (Qr2 = globalThis.process) == null ? void 0 : Qr2.platform) == null ? void 0 : Zr2.startsWith("win")) || false;
function en2(e2) {
  if (e2 = e2 instanceof URL ? e2 : new URL(e2), e2.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e2.protocol}"`);
  return e2;
}
function ro2(e2) {
  return e2 = en2(e2), decodeURIComponent(e2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function no2(e2) {
  e2 = en2(e2);
  let t8 = decodeURIComponent(e2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e2.hostname !== "" && (t8 = `\\\\${e2.hostname}${t8}`), t8;
}
function tn2(e2) {
  return to2 ? no2(e2) : ro2(e2);
}
var rn2 = tn2;
var uo2 = (e2) => String(e2).split(/[/\\]/u).pop();
function nn(e2, t8) {
  if (!t8) return;
  let r2 = uo2(t8).toLowerCase();
  return e2.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((u) => u.toLowerCase() === r2)) ?? e2.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((u) => r2.endsWith(u)));
}
function oo2(e2, t8) {
  if (t8) return e2.find(({ name: r2 }) => r2.toLowerCase() === t8) ?? e2.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(t8)) ?? e2.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${t8}`));
}
function un2(e2, t8) {
  if (t8) {
    if (String(t8).startsWith("file:")) try {
      t8 = rn2(t8);
    } catch {
      return;
    }
    if (typeof t8 == "string") return e2.find(({ isSupported: r2 }) => r2 == null ? void 0 : r2({ filepath: t8 }));
  }
}
function io2(e2, t8) {
  let r2 = Hr2(false, e2.plugins).flatMap((u) => u.languages ?? []), n2 = oo2(r2, t8.language) ?? nn(r2, t8.physicalFile) ?? nn(r2, t8.file) ?? un2(r2, t8.physicalFile) ?? un2(r2, t8.file) ?? (t8.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var on2 = io2;
var re2 = { key: (e2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2), value(e2) {
  if (e2 === null || typeof e2 != "object") return JSON.stringify(e2);
  if (Array.isArray(e2)) return `[${e2.map((r2) => re2.value(r2)).join(", ")}]`;
  let t8 = Object.keys(e2);
  return t8.length === 0 ? "{}" : `{ ${t8.map((r2) => `${re2.key(r2)}: ${re2.value(e2[r2])}`).join(", ")} }`;
}, pair: ({ key: e2, value: t8 }) => re2.value({ [e2]: t8 }) };
var sn = new Proxy(String, { get: () => sn });
var V3 = sn;
var an = (e2, t8, { descriptor: r2 }) => {
  let n2 = [`${V3.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2))} is deprecated`];
  return t8 && n2.push(`we now treat it as ${V3.blue(typeof t8 == "string" ? r2.key(t8) : r2.pair(t8))}`), n2.join("; ") + ".";
};
var Ze2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
var ge2 = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn2 = " ".repeat(2);
var fn2 = (e2, t8, r2) => {
  let { text: n2, list: u } = r2.normalizeExpectedResult(r2.schemas[e2].expected(r2)), o2 = [];
  return n2 && o2.push(cn2(e2, t8, n2, r2.descriptor)), u && o2.push([cn2(e2, t8, u.title, r2.descriptor)].concat(u.values.map((i) => ln2(i, r2.loggerPrintWidth))).join(`
`)), Fn2(o2, r2.loggerPrintWidth);
};
function cn2(e2, t8, r2, n2) {
  return [`Invalid ${V3.red(n2.key(e2))} value.`, `Expected ${V3.blue(r2)},`, `but received ${t8 === Ze2 ? V3.gray("nothing") : V3.red(n2.value(t8))}.`].join(" ");
}
function ln2({ text: e2, list: t8 }, r2) {
  let n2 = [];
  return e2 && n2.push(`- ${V3.blue(e2)}`), t8 && n2.push([`- ${V3.blue(t8.title)}:`].concat(t8.values.map((u) => ln2(u, r2 - Dn2.length).replace(/^|\n/g, `$&${Dn2}`))).join(`
`)), Fn2(n2, r2);
}
function Fn2(e2, t8) {
  if (e2.length === 1) return e2[0];
  let [r2, n2] = e2, [u, o2] = e2.map((i) => i.split(`
`, 1)[0].length);
  return u > t8 && u > o2 ? n2 : r2;
}
var Pt2 = [];
var pn2 = [];
function vt2(e2, t8) {
  if (e2 === t8) return 0;
  let r2 = e2;
  e2.length > t8.length && (e2 = t8, t8 = r2);
  let n2 = e2.length, u = t8.length;
  for (; n2 > 0 && e2.charCodeAt(~-n2) === t8.charCodeAt(~-u); ) n2--, u--;
  let o2 = 0;
  for (; o2 < n2 && e2.charCodeAt(o2) === t8.charCodeAt(o2); ) o2++;
  if (n2 -= o2, u -= o2, n2 === 0) return u;
  let i, s2, a, c2, D = 0, p = 0;
  for (; D < n2; ) pn2[D] = e2.charCodeAt(o2 + D), Pt2[D] = ++D;
  for (; p < u; ) for (i = t8.charCodeAt(o2 + p), a = p++, s2 = p, D = 0; D < n2; D++) c2 = i === pn2[D] ? a : a + 1, a = Pt2[D], s2 = Pt2[D] = a > s2 ? c2 > s2 ? s2 + 1 : c2 : c2 > a ? a + 1 : c2;
  return s2;
}
var et2 = (e2, t8, { descriptor: r2, logger: n2, schemas: u }) => {
  let o2 = [`Ignored unknown option ${V3.yellow(r2.pair({ key: e2, value: t8 }))}.`], i = Object.keys(u).sort().find((s2) => vt2(e2, s2) < 3);
  i && o2.push(`Did you mean ${V3.blue(r2.key(i))}?`), n2.warn(o2.join(" "));
};
var so2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function ao2(e2, t8) {
  let r2 = new e2(t8), n2 = Object.create(r2);
  for (let u of so2) u in t8 && (n2[u] = Do(t8[u], r2, b2.prototype[u].length));
  return n2;
}
var b2 = class {
  static create(t8) {
    return ao2(this, t8);
  }
  constructor(t8) {
    this.name = t8.name;
  }
  default(t8) {
  }
  expected(t8) {
    return "nothing";
  }
  validate(t8, r2) {
    return false;
  }
  deprecated(t8, r2) {
    return false;
  }
  forward(t8, r2) {
  }
  redirect(t8, r2) {
  }
  overlap(t8, r2, n2) {
    return t8;
  }
  preprocess(t8, r2) {
    return t8;
  }
  postprocess(t8, r2) {
    return ge2;
  }
};
function Do(e2, t8, r2) {
  return typeof e2 == "function" ? (...n2) => e2(...n2.slice(0, r2 - 1), t8, ...n2.slice(r2 - 1)) : () => e2;
}
var tt2 = class extends b2 {
  constructor(t8) {
    super(t8), this._sourceName = t8.sourceName;
  }
  expected(t8) {
    return t8.schemas[this._sourceName].expected(t8);
  }
  validate(t8, r2) {
    return r2.schemas[this._sourceName].validate(t8, r2);
  }
  redirect(t8, r2) {
    return this._sourceName;
  }
};
var rt2 = class extends b2 {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var nt2 = class extends b2 {
  constructor({ valueSchema: t8, name: r2 = t8.name, ...n2 }) {
    super({ ...n2, name: r2 }), this._valueSchema = t8;
  }
  expected(t8) {
    let { text: r2, list: n2 } = t8.normalizeExpectedResult(this._valueSchema.expected(t8));
    return { text: r2 && `an array of ${r2}`, list: n2 && { title: "an array of the following values", values: [{ list: n2 }] } };
  }
  validate(t8, r2) {
    if (!Array.isArray(t8)) return false;
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeValidateResult(this._valueSchema.validate(u, r2), u);
      o2 !== true && n2.push(o2.value);
    }
    return n2.length === 0 ? true : { value: n2 };
  }
  deprecated(t8, r2) {
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r2), u);
      o2 !== false && n2.push(...o2.map(({ value: i }) => ({ value: [i] })));
    }
    return n2;
  }
  forward(t8, r2) {
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeForwardResult(this._valueSchema.forward(u, r2), u);
      n2.push(...o2.map(dn2));
    }
    return n2;
  }
  redirect(t8, r2) {
    let n2 = [], u = [];
    for (let o2 of t8) {
      let i = r2.normalizeRedirectResult(this._valueSchema.redirect(o2, r2), o2);
      "remain" in i && n2.push(i.remain), u.push(...i.redirect.map(dn2));
    }
    return n2.length === 0 ? { redirect: u } : { redirect: u, remain: n2 };
  }
  overlap(t8, r2) {
    return t8.concat(r2);
  }
};
function dn2({ from: e2, to: t8 }) {
  return { from: [e2], to: t8 };
}
var ut2 = class extends b2 {
  expected() {
    return "true or false";
  }
  validate(t8) {
    return typeof t8 == "boolean";
  }
};
function En2(e2, t8) {
  let r2 = /* @__PURE__ */ Object.create(null);
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2[u]) throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2[u] = n2;
  }
  return r2;
}
function Cn2(e2, t8) {
  let r2 = /* @__PURE__ */ new Map();
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2.has(u)) throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2.set(u, n2);
  }
  return r2;
}
function hn2() {
  let e2 = /* @__PURE__ */ Object.create(null);
  return (t8) => {
    let r2 = JSON.stringify(t8);
    return e2[r2] ? true : (e2[r2] = true, false);
  };
}
function gn2(e2, t8) {
  let r2 = [], n2 = [];
  for (let u of e2) t8(u) ? r2.push(u) : n2.push(u);
  return [r2, n2];
}
function yn2(e2) {
  return e2 === Math.floor(e2);
}
function An2(e2, t8) {
  if (e2 === t8) return 0;
  let r2 = typeof e2, n2 = typeof t8, u = ["undefined", "object", "boolean", "number", "string"];
  return r2 !== n2 ? u.indexOf(r2) - u.indexOf(n2) : r2 !== "string" ? Number(e2) - Number(t8) : e2.localeCompare(t8);
}
function Bn2(e2) {
  return (...t8) => {
    let r2 = e2(...t8);
    return typeof r2 == "string" ? new Error(r2) : r2;
  };
}
function Lt2(e2) {
  return e2 === void 0 ? {} : e2;
}
function It2(e2) {
  if (typeof e2 == "string") return { text: e2 };
  let { text: t8, list: r2 } = e2;
  return co2((t8 || r2) !== void 0, "Unexpected `expected` result, there should be at least one field."), r2 ? { text: t8, list: { title: r2.title, values: r2.values.map(It2) } } : { text: t8 };
}
function Rt2(e2, t8) {
  return e2 === true ? true : e2 === false ? { value: t8 } : e2;
}
function Yt2(e2, t8, r2 = false) {
  return e2 === false ? false : e2 === true ? r2 ? true : [{ value: t8 }] : "value" in e2 ? [e2] : e2.length === 0 ? false : e2;
}
function mn2(e2, t8) {
  return typeof e2 == "string" || "key" in e2 ? { from: t8, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t8, to: e2.to };
}
function ot2(e2, t8) {
  return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((r2) => mn2(r2, t8)) : [mn2(e2, t8)];
}
function jt2(e2, t8) {
  let r2 = ot2(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t8);
  return r2.length === 0 ? { remain: t8, redirect: r2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: r2 } : { redirect: r2 };
}
function co2(e2, t8) {
  if (!e2) throw new Error(t8);
}
var it2 = class extends b2 {
  constructor(t8) {
    super(t8), this._choices = Cn2(t8.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
  }
  expected({ descriptor: t8 }) {
    let r2 = Array.from(this._choices.keys()).map((i) => this._choices.get(i)).filter(({ hidden: i }) => !i).map((i) => i.value).sort(An2).map(t8.value), n2 = r2.slice(0, -2), u = r2.slice(-2);
    return { text: n2.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r2 } };
  }
  validate(t8) {
    return this._choices.has(t8);
  }
  deprecated(t8) {
    let r2 = this._choices.get(t8);
    return r2 && r2.deprecated ? { value: t8 } : false;
  }
  forward(t8) {
    let r2 = this._choices.get(t8);
    return r2 ? r2.forward : void 0;
  }
  redirect(t8) {
    let r2 = this._choices.get(t8);
    return r2 ? r2.redirect : void 0;
  }
};
var st2 = class extends b2 {
  expected() {
    return "a number";
  }
  validate(t8, r2) {
    return typeof t8 == "number";
  }
};
var at2 = class extends st2 {
  expected() {
    return "an integer";
  }
  validate(t8, r2) {
    return r2.normalizeValidateResult(super.validate(t8, r2), t8) === true && yn2(t8);
  }
};
var Ie2 = class extends b2 {
  expected() {
    return "a string";
  }
  validate(t8) {
    return typeof t8 == "string";
  }
};
var _n2 = re2;
var xn2 = et2;
var wn2 = fn2;
var bn2 = an;
var Dt2 = class {
  constructor(t8, r2) {
    let { logger: n2 = console, loggerPrintWidth: u = 80, descriptor: o2 = _n2, unknown: i = xn2, invalid: s2 = wn2, deprecated: a = bn2, missing: c2 = () => false, required: D = () => false, preprocess: p = (F) => F, postprocess: l2 = () => ge2 } = r2 || {};
    this._utils = { descriptor: o2, logger: n2 || { warn: () => {
    } }, loggerPrintWidth: u, schemas: En2(t8, "name"), normalizeDefaultResult: Lt2, normalizeExpectedResult: It2, normalizeDeprecatedResult: Yt2, normalizeForwardResult: ot2, normalizeRedirectResult: jt2, normalizeValidateResult: Rt2 }, this._unknownHandler = i, this._invalidHandler = Bn2(s2), this._deprecatedHandler = a, this._identifyMissing = (F, f) => !(F in f) || c2(F, f), this._identifyRequired = D, this._preprocess = p, this._postprocess = l2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hn2();
  }
  normalize(t8) {
    let r2 = {}, u = [this._preprocess(t8, this._utils)], o2 = () => {
      for (; u.length !== 0; ) {
        let i = u.shift(), s2 = this._applyNormalization(i, r2);
        u.push(...s2);
      }
    };
    o2();
    for (let i of Object.keys(this._utils.schemas)) {
      let s2 = this._utils.schemas[i];
      if (!(i in r2)) {
        let a = Lt2(s2.default(this._utils));
        "value" in a && u.push({ [i]: a.value });
      }
    }
    o2();
    for (let i of Object.keys(this._utils.schemas)) {
      if (!(i in r2)) continue;
      let s2 = this._utils.schemas[i], a = r2[i], c2 = s2.postprocess(a, this._utils);
      c2 !== ge2 && (this._applyValidation(c2, i, s2), r2[i] = c2);
    }
    return this._applyPostprocess(r2), this._applyRequiredCheck(r2), r2;
  }
  _applyNormalization(t8, r2) {
    let n2 = [], { knownKeys: u, unknownKeys: o2 } = this._partitionOptionKeys(t8);
    for (let i of u) {
      let s2 = this._utils.schemas[i], a = s2.preprocess(t8[i], this._utils);
      this._applyValidation(a, i, s2);
      let c2 = ({ from: F, to: f }) => {
        n2.push(typeof f == "string" ? { [f]: F } : { [f.key]: f.value });
      }, D = ({ value: F, redirectTo: f }) => {
        let d2 = Yt2(s2.deprecated(F, this._utils), a, true);
        if (d2 !== false) if (d2 === true) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, f, this._utils));
        else for (let { value: m } of d2) {
          let C = { key: i, value: m };
          if (!this._hasDeprecationWarned(C)) {
            let E2 = typeof f == "string" ? { key: f, value: m } : f;
            this._utils.logger.warn(this._deprecatedHandler(C, E2, this._utils));
          }
        }
      };
      ot2(s2.forward(a, this._utils), a).forEach(c2);
      let l2 = jt2(s2.redirect(a, this._utils), a);
      if (l2.redirect.forEach(c2), "remain" in l2) {
        let F = l2.remain;
        r2[i] = i in r2 ? s2.overlap(r2[i], F, this._utils) : F, D({ value: F });
      }
      for (let { from: F, to: f } of l2.redirect) D({ value: F, redirectTo: f });
    }
    for (let i of o2) {
      let s2 = t8[i];
      this._applyUnknownHandler(i, s2, r2, (a, c2) => {
        n2.push({ [a]: c2 });
      });
    }
    return n2;
  }
  _applyRequiredCheck(t8) {
    for (let r2 of Object.keys(this._utils.schemas)) if (this._identifyMissing(r2, t8) && this._identifyRequired(r2)) throw this._invalidHandler(r2, Ze2, this._utils);
  }
  _partitionOptionKeys(t8) {
    let [r2, n2] = gn2(Object.keys(t8).filter((u) => !this._identifyMissing(u, t8)), (u) => u in this._utils.schemas);
    return { knownKeys: r2, unknownKeys: n2 };
  }
  _applyValidation(t8, r2, n2) {
    let u = Rt2(n2.validate(t8, this._utils), t8);
    if (u !== true) throw this._invalidHandler(r2, u.value, this._utils);
  }
  _applyUnknownHandler(t8, r2, n2, u) {
    let o2 = this._unknownHandler(t8, r2, this._utils);
    if (o2) for (let i of Object.keys(o2)) {
      if (this._identifyMissing(i, o2)) continue;
      let s2 = o2[i];
      i in this._utils.schemas ? u(i, s2) : n2[i] = s2;
    }
  }
  _applyPostprocess(t8) {
    let r2 = this._postprocess(t8, this._utils);
    if (r2 !== ge2) {
      if (r2.delete) for (let n2 of r2.delete) delete t8[n2];
      if (r2.override) {
        let { knownKeys: n2, unknownKeys: u } = this._partitionOptionKeys(r2.override);
        for (let o2 of n2) {
          let i = r2.override[o2];
          this._applyValidation(i, o2, this._utils.schemas[o2]), t8[o2] = i;
        }
        for (let o2 of u) {
          let i = r2.override[o2];
          this._applyUnknownHandler(o2, i, t8, (s2, a) => {
            let c2 = this._utils.schemas[s2];
            this._applyValidation(a, s2, c2), t8[s2] = a;
          });
        }
      }
    }
  }
};
var Ut2;
function lo2(e2, t8, { logger: r2 = false, isCLI: n2 = false, passThrough: u = false, FlagSchema: o2, descriptor: i } = {}) {
  if (n2) {
    if (!o2) throw new Error("'FlagSchema' option is required.");
    if (!i) throw new Error("'descriptor' option is required.");
  } else i = re2;
  let s2 = u ? Array.isArray(u) ? (l2, F) => u.includes(l2) ? { [l2]: F } : void 0 : (l2, F) => ({ [l2]: F }) : (l2, F, f) => {
    let { _: d2, ...m } = f.schemas;
    return et2(l2, F, { ...f, schemas: m });
  }, a = Fo(t8, { isCLI: n2, FlagSchema: o2 }), c2 = new Dt2(a, { logger: r2, unknown: s2, descriptor: i }), D = r2 !== false;
  D && Ut2 && (c2._hasDeprecationWarned = Ut2);
  let p = c2.normalize(e2);
  return D && (Ut2 = c2._hasDeprecationWarned), p;
}
function Fo(e2, { isCLI: t8, FlagSchema: r2 }) {
  let n2 = [];
  t8 && n2.push(rt2.create({ name: "_" }));
  for (let u of e2) n2.push(po2(u, { isCLI: t8, optionInfos: e2, FlagSchema: r2 })), u.alias && t8 && n2.push(tt2.create({ name: u.alias, sourceName: u.name }));
  return n2;
}
function po2(e2, { isCLI: t8, optionInfos: r2, FlagSchema: n2 }) {
  let { name: u } = e2, o2 = { name: u }, i, s2 = {};
  switch (e2.type) {
    case "int":
      i = at2, t8 && (o2.preprocess = Number);
      break;
    case "string":
      i = Ie2;
      break;
    case "choice":
      i = it2, o2.choices = e2.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e2.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i = ut2;
      break;
    case "flag":
      i = n2, o2.flags = r2.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i = Ie2;
      break;
    default:
      throw new Error(`Unexpected type ${e2.type}`);
  }
  if (e2.exception ? o2.validate = (a, c2, D) => e2.exception(a) || c2.validate(a, D) : o2.validate = (a, c2, D) => a === void 0 || c2.validate(a, D), e2.redirect && (s2.redirect = (a) => a ? { to: typeof e2.redirect == "string" ? e2.redirect : { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (s2.deprecated = true), t8 && !e2.array) {
    let a = o2.preprocess || ((c2) => c2);
    o2.preprocess = (c2, D, p) => D.preprocess(a(Array.isArray(c2) ? y(false, c2, -1) : c2), p);
  }
  return e2.array ? nt2.create({ ...t8 ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s2, valueSchema: i.create(o2) }) : i.create({ ...o2, ...s2 });
}
var kn2 = lo2;
var mo = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLast) return t8.findLast(r2);
    for (let n2 = t8.length - 1; n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8)) return u;
    }
  }
};
var Vt2 = mo;
function $t2(e2, t8) {
  if (!t8) throw new Error("parserName is required.");
  let r2 = Vt2(false, e2, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t8));
  if (r2) return r2;
  let n2 = `Couldn't resolve parser "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new ve2(n2);
}
function Sn2(e2, t8) {
  if (!t8) throw new Error("astFormat is required.");
  let r2 = Vt2(false, e2, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t8));
  if (r2) return r2;
  let n2 = `Couldn't find plugin for AST format "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new ve2(n2);
}
function Re2({ plugins: e2, parser: t8 }) {
  let r2 = $t2(e2, t8);
  return Wt2(r2, t8);
}
function Wt2(e2, t8) {
  let r2 = e2.parsers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
function Tn2(e2, t8) {
  let r2 = e2.printers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
var Nn2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function Eo(e2, t8 = {}) {
  var p;
  let r2 = { ...e2 };
  if (!r2.parser) if (r2.filepath) {
    if (r2.parser = on2(r2, { physicalFile: r2.filepath }), !r2.parser) throw new Le2(`No parser could be inferred for file "${r2.filepath}".`);
  } else throw new Le2("No parser and no file path given, couldn't infer a parser.");
  let n2 = Qe2({ plugins: e2.plugins, showDeprecated: true }).options, u = { ...Nn2, ...Object.fromEntries(n2.filter((l2) => l2.default !== void 0).map((l2) => [l2.name, l2.default])) }, o2 = $t2(r2.plugins, r2.parser), i = await Wt2(o2, r2.parser);
  r2.astFormat = i.astFormat, r2.locEnd = i.locEnd, r2.locStart = i.locStart;
  let s2 = (p = o2.printers) != null && p[i.astFormat] ? o2 : Sn2(r2.plugins, i.astFormat), a = await Tn2(s2, i.astFormat);
  r2.printer = a;
  let c2 = s2.defaultOptions ? Object.fromEntries(Object.entries(s2.defaultOptions).filter(([, l2]) => l2 !== void 0)) : {}, D = { ...u, ...c2 };
  for (let [l2, F] of Object.entries(D)) (r2[l2] === null || r2[l2] === void 0) && (r2[l2] = F);
  return r2.parser === "json" && (r2.trailingComma = "none"), kn2(r2, n2, { passThrough: Object.keys(Nn2), ...t8 });
}
var ne2 = Eo;
var vn2 = gu(Pn2(), 1);
async function yo(e2, t8) {
  let r2 = await Re2(t8), n2 = r2.preprocess ? r2.preprocess(e2, t8) : e2;
  t8.originalText = n2;
  let u;
  try {
    u = await r2.parse(n2, t8, t8);
  } catch (o2) {
    Ao(o2, e2);
  }
  return { text: n2, ast: u };
}
function Ao(e2, t8) {
  let { loc: r2 } = e2;
  if (r2) {
    let n2 = (0, vn2.codeFrameColumns)(t8, r2, { highlightCode: true });
    throw e2.message += `
` + n2, e2.codeFrame = n2, e2;
  }
  throw e2;
}
var De2 = yo;
async function Ln2(e2, t8, r2, n2, u) {
  let { embeddedLanguageFormatting: o2, printer: { embed: i, hasPrettierIgnore: s2 = () => false, getVisitorKeys: a } } = r2;
  if (!i || o2 !== "auto") return;
  if (i.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let c2 = J2(i.getVisitorKeys ?? a), D = [];
  F();
  let p = e2.stack;
  for (let { print: f, node: d2, pathStack: m } of D) try {
    e2.stack = m;
    let C = await f(l2, t8, e2, r2);
    C && u.set(d2, C);
  } catch (C) {
    if (globalThis.PRETTIER_DEBUG) throw C;
  }
  e2.stack = p;
  function l2(f, d2) {
    return Bo(f, d2, r2, n2);
  }
  function F() {
    let { node: f } = e2;
    if (f === null || typeof f != "object" || s2(e2)) return;
    for (let m of c2(f)) Array.isArray(f[m]) ? e2.each(F, m) : e2.call(F, m);
    let d2 = i(e2, r2);
    if (d2) {
      if (typeof d2 == "function") {
        D.push({ print: d2, node: f, pathStack: [...e2.stack] });
        return;
      }
      u.set(f, d2);
    }
  }
}
async function Bo(e2, t8, r2, n2) {
  let u = await ne2({ ...r2, ...t8, parentParser: r2.parser, originalText: e2, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: o2 } = await De2(e2, u), i = await n2(o2, u);
  return $e(i);
}
function _o(e2, t8) {
  let { originalText: r2, [Symbol.for("comments")]: n2, locStart: u, locEnd: o2, [Symbol.for("printedComments")]: i } = t8, { node: s2 } = e2, a = u(s2), c2 = o2(s2);
  for (let D of n2) u(D) >= a && o2(D) <= c2 && i.add(D);
  return r2.slice(a, c2);
}
var In2 = _o;
async function Ye2(e2, t8) {
  ({ ast: e2 } = await Gt2(e2, t8));
  let r2 = /* @__PURE__ */ new Map(), n2 = new Or2(e2), u = Kr2(t8), o2 = /* @__PURE__ */ new Map();
  await Ln2(n2, s2, t8, Ye2, o2);
  let i = await Rn2(n2, t8, s2, void 0, o2);
  if (Gr2(t8), t8.cursorOffset >= 0) {
    if (t8.nodeAfterCursor && !t8.nodeBeforeCursor) return [X2, i];
    if (t8.nodeBeforeCursor && !t8.nodeAfterCursor) return [i, X2];
  }
  return i;
  function s2(c2, D) {
    return c2 === void 0 || c2 === n2 ? a(D) : Array.isArray(c2) ? n2.call(() => a(D), ...c2) : n2.call(() => a(D), c2);
  }
  function a(c2) {
    u(n2);
    let D = n2.node;
    if (D == null) return "";
    let p = D && typeof D == "object" && c2 === void 0;
    if (p && r2.has(D)) return r2.get(D);
    let l2 = Rn2(n2, t8, s2, c2, o2);
    return p && r2.set(D, l2), l2;
  }
}
function Rn2(e2, t8, r2, n2, u) {
  var a;
  let { node: o2 } = e2, { printer: i } = t8, s2;
  switch ((a = i.hasPrettierIgnore) != null && a.call(i, e2) ? s2 = In2(e2, t8) : u.has(o2) ? s2 = u.get(o2) : s2 = i.print(e2, t8, r2, n2), o2) {
    case t8.cursorNode:
      s2 = Fe2(s2, (c2) => [X2, c2, X2]);
      break;
    case t8.nodeBeforeCursor:
      s2 = Fe2(s2, (c2) => [c2, X2]);
      break;
    case t8.nodeAfterCursor:
      s2 = Fe2(s2, (c2) => [X2, c2]);
      break;
  }
  return i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e2, t8)) && (s2 = Mr(e2, s2, t8)), s2;
}
async function Gt2(e2, t8) {
  let r2 = e2.comments ?? [];
  t8[Symbol.for("comments")] = r2, t8[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Vr(e2, t8);
  let { printer: { preprocess: n2 } } = t8;
  return e2 = n2 ? await n2(e2, t8) : e2, { ast: e2, comments: r2 };
}
function xo(e2, t8) {
  let { cursorOffset: r2, locStart: n2, locEnd: u } = t8, o2 = J2(t8.printer.getVisitorKeys), i = (F) => n2(F) <= r2 && u(F) >= r2, s2 = e2, a = [e2];
  for (let F of Lr2(e2, { getVisitorKeys: o2, filter: i })) a.push(F), s2 = F;
  if (Ir2(s2, { getVisitorKeys: o2 })) return { cursorNode: s2 };
  let c2, D, p = -1, l2 = Number.POSITIVE_INFINITY;
  for (; a.length > 0 && (c2 === void 0 || D === void 0); ) {
    s2 = a.pop();
    let F = c2 !== void 0, f = D !== void 0;
    for (let d2 of Ce2(s2, { getVisitorKeys: o2 })) {
      if (!F) {
        let m = u(d2);
        m <= r2 && m > p && (c2 = d2, p = m);
      }
      if (!f) {
        let m = n2(d2);
        m >= r2 && m < l2 && (D = d2, l2 = m);
      }
    }
  }
  return { nodeBeforeCursor: c2, nodeAfterCursor: D };
}
var Kt2 = xo;
function wo(e2, t8) {
  let { printer: { massageAstNode: r2, getVisitorKeys: n2 } } = t8;
  if (!r2) return e2;
  let u = J2(n2), o2 = r2.ignoredProperties ?? /* @__PURE__ */ new Set();
  return i(e2);
  function i(s2, a) {
    if (!(s2 !== null && typeof s2 == "object")) return s2;
    if (Array.isArray(s2)) return s2.map((l2) => i(l2, a)).filter(Boolean);
    let c2 = {}, D = new Set(u(s2));
    for (let l2 in s2) !Object.prototype.hasOwnProperty.call(s2, l2) || o2.has(l2) || (D.has(l2) ? c2[l2] = i(s2[l2], s2) : c2[l2] = s2[l2]);
    let p = r2(s2, c2, a);
    if (p !== null) return p ?? c2;
  }
}
var Yn2 = wo;
var bo = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLastIndex) return t8.findLastIndex(r2);
    for (let n2 = t8.length - 1; n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8)) return n2;
    }
    return -1;
  }
};
var jn2 = bo;
var ko = ({ parser: e2 }) => e2 === "json" || e2 === "json5" || e2 === "jsonc" || e2 === "json-stringify";
function So(e2, t8) {
  let r2 = [e2.node, ...e2.parentNodes], n2 = /* @__PURE__ */ new Set([t8.node, ...t8.parentNodes]);
  return r2.find((u) => $n2.has(u.type) && n2.has(u));
}
function Un2(e2) {
  let t8 = jn2(false, e2, (r2) => r2.type !== "Program" && r2.type !== "File");
  return t8 === -1 ? e2 : e2.slice(0, t8 + 1);
}
function To(e2, t8, { locStart: r2, locEnd: n2 }) {
  let u = e2.node, o2 = t8.node;
  if (u === o2) return { startNode: u, endNode: o2 };
  let i = r2(e2.node);
  for (let a of Un2(t8.parentNodes)) if (r2(a) >= i) o2 = a;
  else break;
  let s2 = n2(t8.node);
  for (let a of Un2(e2.parentNodes)) {
    if (n2(a) <= s2) u = a;
    else break;
    if (u === o2) break;
  }
  return { startNode: u, endNode: o2 };
}
function zt2(e2, t8, r2, n2, u = [], o2) {
  let { locStart: i, locEnd: s2 } = r2, a = i(e2), c2 = s2(e2);
  if (!(t8 > c2 || t8 < a || o2 === "rangeEnd" && t8 === a || o2 === "rangeStart" && t8 === c2)) {
    for (let D of Xe2(e2, r2)) {
      let p = zt2(D, t8, r2, n2, [e2, ...u], o2);
      if (p) return p;
    }
    if (!n2 || n2(e2, u[0])) return { node: e2, parentNodes: u };
  }
}
function No(e2, t8) {
  return t8 !== "DeclareExportDeclaration" && e2 !== "TypeParameterDeclaration" && (e2 === "Directive" || e2 === "TypeAlias" || e2 === "TSExportAssignment" || e2.startsWith("Declare") || e2.startsWith("TSDeclare") || e2.endsWith("Statement") || e2.endsWith("Declaration"));
}
var $n2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Oo2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Vn2(e2, t8, r2) {
  if (!t8) return false;
  switch (e2.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return No(t8.type, r2 == null ? void 0 : r2.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return $n2.has(t8.type);
    case "graphql":
      return Oo2.has(t8.kind);
    case "vue":
      return t8.tag !== "root";
  }
  return false;
}
function Wn2(e2, t8, r2) {
  let { rangeStart: n2, rangeEnd: u, locStart: o2, locEnd: i } = t8;
  Oe2.ok(u > n2);
  let s2 = e2.slice(n2, u).search(/\S/u), a = s2 === -1;
  if (!a) for (n2 += s2; u > n2 && !/\S/u.test(e2[u - 1]); --u) ;
  let c2 = zt2(r2, n2, t8, (F, f) => Vn2(t8, F, f), [], "rangeStart"), D = a ? c2 : zt2(r2, u, t8, (F) => Vn2(t8, F), [], "rangeEnd");
  if (!c2 || !D) return { rangeStart: 0, rangeEnd: 0 };
  let p, l2;
  if (ko(t8)) {
    let F = So(c2, D);
    p = F, l2 = F;
  } else ({ startNode: p, endNode: l2 } = To(c2, D, t8));
  return { rangeStart: Math.min(o2(p), o2(l2)), rangeEnd: Math.max(i(p), i(l2)) };
}
var zn2 = "\uFEFF";
var Mn2 = Symbol("cursor");
async function Hn2(e2, t8, r2 = 0) {
  if (!e2 || e2.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n2, text: u } = await De2(e2, t8);
  t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(n2, t8) });
  let o2 = await Ye2(n2, t8, r2);
  r2 > 0 && (o2 = Ge3([z2, o2], r2, t8.tabWidth));
  let i = me2(o2, t8);
  if (r2 > 0) {
    let a = i.formatted.trim();
    i.cursorNodeStart !== void 0 && (i.cursorNodeStart -= i.formatted.indexOf(a), i.cursorNodeStart < 0 && (i.cursorNodeStart = 0, i.cursorNodeText = i.cursorNodeText.trimStart()), i.cursorNodeStart + i.cursorNodeText.length > a.length && (i.cursorNodeText = i.cursorNodeText.trimEnd())), i.formatted = a + xe2(t8.endOfLine);
  }
  let s2 = t8[Symbol.for("comments")];
  if (t8.cursorOffset >= 0) {
    let a, c2, D, p;
    if ((t8.cursorNode || t8.nodeBeforeCursor || t8.nodeAfterCursor) && i.cursorNodeText) if (D = i.cursorNodeStart, p = i.cursorNodeText, t8.cursorNode) a = t8.locStart(t8.cursorNode), c2 = u.slice(a, t8.locEnd(t8.cursorNode));
    else {
      if (!t8.nodeBeforeCursor && !t8.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      a = t8.nodeBeforeCursor ? t8.locEnd(t8.nodeBeforeCursor) : 0;
      let C = t8.nodeAfterCursor ? t8.locStart(t8.nodeAfterCursor) : u.length;
      c2 = u.slice(a, C);
    }
    else a = 0, c2 = u, D = 0, p = i.formatted;
    let l2 = t8.cursorOffset - a;
    if (c2 === p) return { formatted: i.formatted, cursorOffset: D + l2, comments: s2 };
    let F = c2.split("");
    F.splice(l2, 0, Mn2);
    let f = p.split(""), d2 = Et2(F, f), m = D;
    for (let C of d2) if (C.removed) {
      if (C.value.includes(Mn2)) break;
    } else m += C.count;
    return { formatted: i.formatted, cursorOffset: m, comments: s2 };
  }
  return { formatted: i.formatted, cursorOffset: -1, comments: s2 };
}
async function Po(e2, t8) {
  let { ast: r2, text: n2 } = await De2(e2, t8), { rangeStart: u, rangeEnd: o2 } = Wn2(n2, t8, r2), i = n2.slice(u, o2), s2 = Math.min(u, n2.lastIndexOf(`
`, u) + 1), a = n2.slice(s2, u).match(/^\s*/u)[0], c2 = Ee2(a, t8.tabWidth), D = await Hn2(i, { ...t8, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t8.cursorOffset > u && t8.cursorOffset <= o2 ? t8.cursorOffset - u : -1, endOfLine: "lf" }, c2), p = D.formatted.trimEnd(), { cursorOffset: l2 } = t8;
  l2 > o2 ? l2 += p.length - i.length : D.cursorOffset >= 0 && (l2 = D.cursorOffset + u);
  let F = n2.slice(0, u) + p + n2.slice(o2);
  if (t8.endOfLine !== "lf") {
    let f = xe2(t8.endOfLine);
    l2 >= 0 && f === `\r
` && (l2 += Ct2(F.slice(0, l2), `
`)), F = te(false, F, `
`, f);
  }
  return { formatted: F, cursorOffset: l2, comments: D.comments };
}
function Ht2(e2, t8, r2) {
  return typeof t8 != "number" || Number.isNaN(t8) || t8 < 0 || t8 > e2.length ? r2 : t8;
}
function Gn2(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u } = t8;
  return r2 = Ht2(e2, r2, -1), n2 = Ht2(e2, n2, 0), u = Ht2(e2, u, e2.length), { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u };
}
function Jn2(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: o2 } = Gn2(e2, t8), i = e2.charAt(0) === zn2;
  if (i && (e2 = e2.slice(1), r2--, n2--, u--), o2 === "auto" && (o2 = nr2(e2)), e2.includes("\r")) {
    let s2 = (a) => Ct2(e2.slice(0, Math.max(a, 0)), `\r
`);
    r2 -= s2(r2), n2 -= s2(n2), u -= s2(u), e2 = ur2(e2);
  }
  return { hasBOM: i, text: e2, options: Gn2(e2, { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: o2 }) };
}
async function Kn2(e2, t8) {
  let r2 = await Re2(t8);
  return !r2.hasPragma || r2.hasPragma(e2);
}
async function vo(e2, t8) {
  var n2;
  let r2 = await Re2(t8);
  return (n2 = r2.hasIgnorePragma) == null ? void 0 : n2.call(r2, e2);
}
async function Jt(e2, t8) {
  let { hasBOM: r2, text: n2, options: u } = Jn2(e2, await ne2(t8));
  if (u.rangeStart >= u.rangeEnd && n2 !== "" || u.requirePragma && !await Kn2(n2, u) || u.checkIgnorePragma && await vo(n2, u)) return { formatted: e2, cursorOffset: t8.cursorOffset, comments: [] };
  let o2;
  return u.rangeStart > 0 || u.rangeEnd < n2.length ? o2 = await Po(n2, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn2(n2, u) && (n2 = u.printer.insertPragma(n2)), o2 = await Hn2(n2, u)), r2 && (o2.formatted = zn2 + o2.formatted, o2.cursorOffset >= 0 && o2.cursorOffset++), o2;
}
async function qn2(e2, t8, r2) {
  let { text: n2, options: u } = Jn2(e2, await ne2(t8)), o2 = await De2(n2, u);
  return r2 && (r2.preprocessForPrint && (o2.ast = await Gt2(o2.ast, u)), r2.massage && (o2.ast = Yn2(o2.ast, u))), o2;
}
async function Xn2(e2, t8) {
  t8 = await ne2(t8);
  let r2 = await Ye2(e2, t8);
  return me2(r2, t8);
}
async function Qn2(e2, t8) {
  let r2 = wr2(e2), { formatted: n2 } = await Jt(r2, { ...t8, parser: "__js_expression" });
  return n2;
}
async function Zn2(e2, t8) {
  t8 = await ne2(t8);
  let { ast: r2 } = await De2(e2, t8);
  return t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(r2, t8) }), Ye2(r2, t8);
}
async function eu2(e2, t8) {
  return me2(e2, await ne2(t8));
}
var qt2 = {};
dt(qt2, { builders: () => Io2, printer: () => Ro2, utils: () => Yo2 });
var Io2 = { join: ke2, line: Me2, softline: _r2, hardline: z2, literalline: We, group: At2, conditionalGroup: Cr2, fill: hr2, lineSuffix: Se2, lineSuffixBoundary: Ar2, cursor: X2, breakParent: pe2, ifBreak: gr2, trim: Br2, indent: ie2, indentIfBreak: yr2, align: oe, addAlignmentToDoc: Ge3, markAsRoot: mr2, dedentToRoot: dr2, dedent: Er2, hardlineWithoutBreakParent: Te2, literallineWithoutBreakParent: Bt2, label: xr2, concat: (e2) => e2 };
var Ro2 = { printDocToString: me2 };
var Yo2 = { willBreak: Dr2, traverseDoc: le2, findInDoc: Ve2, mapDoc: be2, removeLines: fr2, stripTrailingHardline: $e, replaceEndOfLine: lr2, canBreak: Fr2 };
var tu2 = "3.6.2";
var Qt2 = {};
dt(Qt2, { addDanglingComment: () => ee2, addLeadingComment: () => se2, addTrailingComment: () => ae2, getAlignmentSize: () => Ee2, getIndentSize: () => ru2, getMaxContinuousCount: () => nu2, getNextNonSpaceNonCommentCharacter: () => uu2, getNextNonSpaceNonCommentCharacterIndex: () => Xo2, getPreferredQuote: () => iu2, getStringWidth: () => Ne2, hasNewline: () => G2, hasNewlineInRange: () => su2, hasSpaces: () => au2, isNextLineEmpty: () => ti2, isNextLineEmptyAfterIndex: () => ct2, isPreviousLineEmpty: () => Zo2, makeString: () => Du, skip: () => he2, skipEverythingButNewLine: () => Je2, skipInlineComment: () => ye, skipNewline: () => U, skipSpaces: () => T2, skipToLineEnd: () => He2, skipTrailingComment: () => Ae2, skipWhitespace: () => Rr2 });
function jo2(e2, t8) {
  if (t8 === false) return false;
  if (e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "*") {
    for (let r2 = t8 + 2; r2 < e2.length; ++r2) if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/") return r2 + 2;
  }
  return t8;
}
var ye = jo2;
function Uo2(e2, t8) {
  return t8 === false ? false : e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "/" ? Je2(e2, t8) : t8;
}
var Ae2 = Uo2;
function Vo2(e2, t8) {
  let r2 = null, n2 = t8;
  for (; n2 !== r2; ) r2 = n2, n2 = T2(e2, n2), n2 = ye(e2, n2), n2 = Ae2(e2, n2), n2 = U(e2, n2);
  return n2;
}
var je2 = Vo2;
function $o2(e2, t8) {
  let r2 = null, n2 = t8;
  for (; n2 !== r2; ) r2 = n2, n2 = He2(e2, n2), n2 = ye(e2, n2), n2 = T2(e2, n2);
  return n2 = Ae2(e2, n2), n2 = U(e2, n2), n2 !== false && G2(e2, n2);
}
var ct2 = $o2;
function Wo2(e2, t8) {
  let r2 = e2.lastIndexOf(`
`);
  return r2 === -1 ? 0 : Ee2(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t8);
}
var ru2 = Wo2;
function Xt2(e2) {
  if (typeof e2 != "string") throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Mo2(e2, t8) {
  let r2 = e2.match(new RegExp(`(${Xt2(t8)})+`, "gu"));
  return r2 === null ? 0 : r2.reduce((n2, u) => Math.max(n2, u.length / t8.length), 0);
}
var nu2 = Mo2;
function Go2(e2, t8) {
  let r2 = je2(e2, t8);
  return r2 === false ? "" : e2.charAt(r2);
}
var uu2 = Go2;
var ft2 = "'";
var ou2 = '"';
function Ko2(e2, t8) {
  let r2 = t8 === true || t8 === ft2 ? ft2 : ou2, n2 = r2 === ft2 ? ou2 : ft2, u = 0, o2 = 0;
  for (let i of e2) i === r2 ? u++ : i === n2 && o2++;
  return u > o2 ? n2 : r2;
}
var iu2 = Ko2;
function zo2(e2, t8, r2) {
  for (let n2 = t8; n2 < r2; ++n2) if (e2.charAt(n2) === `
`) return true;
  return false;
}
var su2 = zo2;
function Ho2(e2, t8, r2 = {}) {
  return T2(e2, r2.backwards ? t8 - 1 : t8, r2) !== t8;
}
var au2 = Ho2;
function Jo2(e2, t8, r2) {
  let n2 = t8 === '"' ? "'" : '"', o2 = te(false, e2, /\\(.)|(["'])/gsu, (i, s2, a) => s2 === n2 ? s2 : a === t8 ? "\\" + a : a || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s2) ? s2 : "\\" + s2));
  return t8 + o2 + t8;
}
var Du = Jo2;
function qo2(e2, t8, r2) {
  return je2(e2, r2(t8));
}
function Xo2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? je2(e2, t8) : qo2(...arguments);
}
function Qo2(e2, t8, r2) {
  return Pe2(e2, r2(t8));
}
function Zo2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? Pe2(e2, t8) : Qo2(...arguments);
}
function ei(e2, t8, r2) {
  return ct2(e2, r2(t8));
}
function ti2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? ct2(e2, t8) : ei(...arguments);
}
function ce2(e2, t8 = 1) {
  return async (...r2) => {
    let n2 = r2[t8] ?? {}, u = n2.plugins ?? [];
    return r2[t8] = { ...n2, plugins: Array.isArray(u) ? u : Object.values(u) }, e2(...r2);
  };
}
var cu = ce2(Jt);
async function fu(e2, t8) {
  let { formatted: r2 } = await cu(e2, { ...t8, cursorOffset: -1 });
  return r2;
}
async function ri2(e2, t8) {
  return await fu(e2, t8) === e2;
}
var ni2 = ce2(Qe2, 0);
var ui = { parse: ce2(qn2), formatAST: ce2(Xn2), formatDoc: ce2(Qn2), printToDoc: ce2(Zn2), printDocToString: ce2(eu2) };

// node_modules/@react-email/components/node_modules/@react-email/render/dist/browser/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var __defProp15 = Object.defineProperty;
var __defProps15 = Object.defineProperties;
var __getOwnPropDescs15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols15 = Object.getOwnPropertySymbols;
var __hasOwnProp15 = Object.prototype.hasOwnProperty;
var __propIsEnum15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues15 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp15.call(b3, prop))
      __defNormalProp15(a, prop, b3[prop]);
  if (__getOwnPropSymbols15)
    for (var prop of __getOwnPropSymbols15(b3)) {
      if (__propIsEnum15.call(b3, prop))
        __defNormalProp15(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps15 = (a, b3) => __defProps15(a, __getOwnPropDescs15(b3));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "[data-skip-in-text=true]", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) {
    return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  }
  if (typeof doc === "object") {
    if (doc.type === "group") {
      return __spreadProps15(__spreadValues15({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback),
        expandedStates: recursivelyMapDoc(
          doc.expandedStates,
          callback
        )
      });
    }
    if ("contents" in doc) {
      return __spreadProps15(__spreadValues15({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback)
      });
    }
    if ("parts" in doc) {
      return __spreadProps15(__spreadValues15({}, doc), {
        parts: recursivelyMapDoc(doc.parts, callback)
      });
    }
    if (doc.type === "if-break") {
      return __spreadProps15(__spreadValues15({}, doc), {
        breakContents: recursivelyMapDoc(doc.breakContents, callback),
        flatContents: recursivelyMapDoc(doc.flatContents, callback)
      });
    }
  }
  return callback(doc);
}
var modifiedHtml = __spreadValues15({}, html_exports);
if (modifiedHtml.printers) {
  const previousPrint = modifiedHtml.printers.html.print;
  modifiedHtml.printers.html.print = (path, options2, print, args) => {
    const node = path.getNode();
    const rawPrintingResult = previousPrint(path, options2, print, args);
    if (node.type === "ieConditionalComment") {
      const printingResult = recursivelyMapDoc(rawPrintingResult, (doc) => {
        if (typeof doc === "object" && doc.type === "line") {
          return doc.soft ? "" : " ";
        }
        return doc;
      });
      return printingResult;
    }
    return rawPrintingResult;
  };
}
var defaults = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [modifiedHtml],
  bracketSameLine: true,
  parser: "html"
};
var pretty = (str, options2 = {}) => {
  return fu(str.replaceAll("\0", ""), __spreadValues15(__spreadValues15({}, defaults), options2));
};
var decoder = new TextDecoder("utf-8");
var readStream = (stream) => __async(void 0, null, function* () {
  const chunks = [];
  const writableStream = new WritableStream({
    write(chunk) {
      chunks.push(chunk);
    },
    abort(reason) {
      throw new Error("Stream aborted", {
        cause: {
          reason
        }
      });
    }
  });
  yield stream.pipeTo(writableStream);
  let length = 0;
  chunks.forEach((item) => {
    length += item.length;
  });
  const mergedChunks = new Uint8Array(length);
  let offset = 0;
  chunks.forEach((item) => {
    mergedChunks.set(item, offset);
    offset += item.length;
  });
  return decoder.decode(mergedChunks);
});
var render2 = (node, options2) => __async(void 0, null, function* () {
  const suspendedElement = (0, import_jsx_runtime16.jsx)(import_react.Suspense, { children: node });
  const reactDOMServer = yield import("./server.browser-U6VRMUGP.js").then(
    // This is beacuse react-dom/server is CJS
    (m) => m.default
  );
  const html2 = yield new Promise((resolve, reject) => {
    reactDOMServer.renderToReadableStream(suspendedElement, {
      onError(error) {
        reject(error);
      },
      progressiveChunkSize: Number.POSITIVE_INFINITY
    }).then(readStream).then(resolve).catch(reject);
  });
  if (options2 == null ? void 0 : options2.plainText) {
    return convert(html2, __spreadValues15({
      selectors: plainTextSelectors
    }, options2.htmlToTextOptions));
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document2 = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options2 == null ? void 0 : options2.pretty) {
    return pretty(document2);
  }
  return document2;
});
var renderAsync = (element, options2) => {
  return render2(element, options2);
};

// node_modules/@react-email/row/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var __defProp16 = Object.defineProperty;
var __defProps16 = Object.defineProperties;
var __getOwnPropDescs16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols16 = Object.getOwnPropertySymbols;
var __hasOwnProp16 = Object.prototype.hasOwnProperty;
var __propIsEnum16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues16 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp16.call(b3, prop))
      __defNormalProp16(a, prop, b3[prop]);
  if (__getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(b3)) {
      if (__propIsEnum16.call(b3, prop))
        __defNormalProp16(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps16 = (a, b3) => __defProps16(a, __getOwnPropDescs16(b3));
var __objRest15 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp16.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum16.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Row = React16.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style } = _b, props = __objRest15(_b, ["children", "style"]);
    return (0, import_jsx_runtime17.jsx)(
      "table",
      __spreadProps16(__spreadValues16({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: (0, import_jsx_runtime17.jsx)("tbody", { style: { width: "100%" }, children: (0, import_jsx_runtime17.jsx)("tr", { style: { width: "100%" }, children }) })
      })
    );
  }
);
Row.displayName = "Row";

// node_modules/@react-email/section/dist/index.mjs
var React17 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var __defProp17 = Object.defineProperty;
var __defProps17 = Object.defineProperties;
var __getOwnPropDescs17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols17 = Object.getOwnPropertySymbols;
var __hasOwnProp17 = Object.prototype.hasOwnProperty;
var __propIsEnum17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues17 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp17.call(b3, prop))
      __defNormalProp17(a, prop, b3[prop]);
  if (__getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(b3)) {
      if (__propIsEnum17.call(b3, prop))
        __defNormalProp17(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps17 = (a, b3) => __defProps17(a, __getOwnPropDescs17(b3));
var __objRest16 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp17.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum17.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Section = React17.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { children, style } = _b, props = __objRest16(_b, ["children", "style"]);
    return (0, import_jsx_runtime18.jsx)(
      "table",
      __spreadProps17(__spreadValues17({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: (0, import_jsx_runtime18.jsx)("tbody", { children: (0, import_jsx_runtime18.jsx)("tr", { children: (0, import_jsx_runtime18.jsx)("td", { children }) }) })
      })
    );
  }
);
Section.displayName = "Section";

// node_modules/@react-email/tailwind/dist/index.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var Or3 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var ta2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function He3(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function cu2(u) {
  if (Object.prototype.hasOwnProperty.call(u, "__esModule")) return u;
  var a = u.default;
  if (typeof a == "function") {
    var h7 = function p() {
      return this instanceof p ? Reflect.construct(a, arguments, this.constructor) : a.apply(this, arguments);
    };
    h7.prototype = a.prototype;
  } else h7 = {};
  return Object.defineProperty(h7, "__esModule", { value: true }), Object.keys(u).forEach(function(p) {
    var l2 = Object.getOwnPropertyDescriptor(u, p);
    Object.defineProperty(h7, p, l2.get ? l2 : {
      enumerable: true,
      get: function() {
        return u[p];
      }
    });
  }), h7;
}
var pt3 = { exports: {} };
var ra2;
function Ti() {
  if (ra2) return pt3.exports;
  ra2 = 1;
  var u = String, a = function() {
    return { isColorSupported: false, reset: u, bold: u, dim: u, italic: u, underline: u, inverse: u, hidden: u, strikethrough: u, black: u, red: u, green: u, yellow: u, blue: u, magenta: u, cyan: u, white: u, gray: u, bgBlack: u, bgRed: u, bgGreen: u, bgYellow: u, bgBlue: u, bgMagenta: u, bgCyan: u, bgWhite: u, blackBright: u, redBright: u, greenBright: u, yellowBright: u, blueBright: u, magentaBright: u, cyanBright: u, whiteBright: u, bgBlackBright: u, bgRedBright: u, bgGreenBright: u, bgYellowBright: u, bgBlueBright: u, bgMagentaBright: u, bgCyanBright: u, bgWhiteBright: u };
  };
  return pt3.exports = a(), pt3.exports.createColors = a, pt3.exports;
}
var du2 = {};
var pu2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: du2
}, Symbol.toStringTag, { value: "Module" }));
var Ne3 = cu2(pu2);
var kr3;
var na2;
function Ai2() {
  if (na2) return kr3;
  na2 = 1;
  let u = Ti(), a = Ne3;
  class h7 extends Error {
    constructor(l2, f, s2, c2, t8, e2) {
      super(l2), this.name = "CssSyntaxError", this.reason = l2, t8 && (this.file = t8), c2 && (this.source = c2), e2 && (this.plugin = e2), typeof f < "u" && typeof s2 < "u" && (typeof f == "number" ? (this.line = f, this.column = s2) : (this.line = f.line, this.column = f.column, this.endLine = s2.line, this.endColumn = s2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, h7);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(l2) {
      if (!this.source) return "";
      let f = this.source;
      l2 == null && (l2 = u.isColorSupported);
      let s2 = (v3) => v3, c2 = (v3) => v3, t8 = (v3) => v3;
      if (l2) {
        let { bold: v3, gray: m, red: n2 } = u.createColors(true);
        c2 = (d2) => v3(n2(d2)), s2 = (d2) => m(d2), a && (t8 = (d2) => a(d2));
      }
      let e2 = f.split(/\r?\n/), r2 = Math.max(this.line - 3, 0), i = Math.min(this.line + 2, e2.length), o2 = String(i).length;
      return e2.slice(r2, i).map((v3, m) => {
        let n2 = r2 + 1 + m, d2 = " " + (" " + n2).slice(-o2) + " | ";
        if (n2 === this.line) {
          if (v3.length > 160) {
            let w3 = 20, y2 = Math.max(0, this.column - w3), x = Math.max(
              this.column + w3,
              this.endColumn + w3
            ), g2 = v3.slice(y2, x), O3 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, Math.min(this.column - 1, w3 - 1)).replace(/[^\t]/g, " ");
            return c2(">") + s2(d2) + t8(g2) + `
 ` + O3 + c2("^");
          }
          let _3 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return c2(">") + s2(d2) + t8(v3) + `
 ` + _3 + c2("^");
        }
        return " " + s2(d2) + t8(v3);
      }).join(`
`);
    }
    toString() {
      let l2 = this.showSourceCode();
      return l2 && (l2 = `

` + l2 + `
`), this.name + ": " + this.message + l2;
    }
  }
  return kr3 = h7, h7.default = h7, kr3;
}
var Pr3;
var ia2;
function dl() {
  if (ia2) return Pr3;
  ia2 = 1;
  const u = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: false
  };
  function a(p) {
    return p[0].toUpperCase() + p.slice(1);
  }
  class h7 {
    constructor(l2) {
      this.builder = l2;
    }
    atrule(l2, f) {
      let s2 = "@" + l2.name, c2 = l2.params ? this.rawValue(l2, "params") : "";
      if (typeof l2.raws.afterName < "u" ? s2 += l2.raws.afterName : c2 && (s2 += " "), l2.nodes)
        this.block(l2, s2 + c2);
      else {
        let t8 = (l2.raws.between || "") + (f ? ";" : "");
        this.builder(s2 + c2 + t8, l2);
      }
    }
    beforeAfter(l2, f) {
      let s2;
      l2.type === "decl" ? s2 = this.raw(l2, null, "beforeDecl") : l2.type === "comment" ? s2 = this.raw(l2, null, "beforeComment") : f === "before" ? s2 = this.raw(l2, null, "beforeRule") : s2 = this.raw(l2, null, "beforeClose");
      let c2 = l2.parent, t8 = 0;
      for (; c2 && c2.type !== "root"; )
        t8 += 1, c2 = c2.parent;
      if (s2.includes(`
`)) {
        let e2 = this.raw(l2, null, "indent");
        if (e2.length)
          for (let r2 = 0; r2 < t8; r2++) s2 += e2;
      }
      return s2;
    }
    block(l2, f) {
      let s2 = this.raw(l2, "between", "beforeOpen");
      this.builder(f + s2 + "{", l2, "start");
      let c2;
      l2.nodes && l2.nodes.length ? (this.body(l2), c2 = this.raw(l2, "after")) : c2 = this.raw(l2, "after", "emptyBody"), c2 && this.builder(c2), this.builder("}", l2, "end");
    }
    body(l2) {
      let f = l2.nodes.length - 1;
      for (; f > 0 && l2.nodes[f].type === "comment"; )
        f -= 1;
      let s2 = this.raw(l2, "semicolon");
      for (let c2 = 0; c2 < l2.nodes.length; c2++) {
        let t8 = l2.nodes[c2], e2 = this.raw(t8, "before");
        e2 && this.builder(e2), this.stringify(t8, f !== c2 || s2);
      }
    }
    comment(l2) {
      let f = this.raw(l2, "left", "commentLeft"), s2 = this.raw(l2, "right", "commentRight");
      this.builder("/*" + f + l2.text + s2 + "*/", l2);
    }
    decl(l2, f) {
      let s2 = this.raw(l2, "between", "colon"), c2 = l2.prop + s2 + this.rawValue(l2, "value");
      l2.important && (c2 += l2.raws.important || " !important"), f && (c2 += ";"), this.builder(c2, l2);
    }
    document(l2) {
      this.body(l2);
    }
    raw(l2, f, s2) {
      let c2;
      if (s2 || (s2 = f), f && (c2 = l2.raws[f], typeof c2 < "u"))
        return c2;
      let t8 = l2.parent;
      if (s2 === "before" && (!t8 || t8.type === "root" && t8.first === l2 || t8 && t8.type === "document"))
        return "";
      if (!t8) return u[s2];
      let e2 = l2.root();
      if (e2.rawCache || (e2.rawCache = {}), typeof e2.rawCache[s2] < "u")
        return e2.rawCache[s2];
      if (s2 === "before" || s2 === "after")
        return this.beforeAfter(l2, s2);
      {
        let r2 = "raw" + a(s2);
        this[r2] ? c2 = this[r2](e2, l2) : e2.walk((i) => {
          if (c2 = i.raws[f], typeof c2 < "u") return false;
        });
      }
      return typeof c2 > "u" && (c2 = u[s2]), e2.rawCache[s2] = c2, c2;
    }
    rawBeforeClose(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length > 0 && typeof s2.raws.after < "u")
          return f = s2.raws.after, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawBeforeComment(l2, f) {
      let s2;
      return l2.walkComments((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeDecl") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeDecl(l2, f) {
      let s2;
      return l2.walkDecls((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeRule") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeOpen(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.type !== "decl" && (f = s2.raws.between, typeof f < "u"))
          return false;
      }), f;
    }
    rawBeforeRule(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && (s2.parent !== l2 || l2.first !== s2) && typeof s2.raws.before < "u")
          return f = s2.raws.before, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawColon(l2) {
      let f;
      return l2.walkDecls((s2) => {
        if (typeof s2.raws.between < "u")
          return f = s2.raws.between.replace(/[^\s:]/g, ""), false;
      }), f;
    }
    rawEmptyBody(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length === 0 && (f = s2.raws.after, typeof f < "u"))
          return false;
      }), f;
    }
    rawIndent(l2) {
      if (l2.raws.indent) return l2.raws.indent;
      let f;
      return l2.walk((s2) => {
        let c2 = s2.parent;
        if (c2 && c2 !== l2 && c2.parent && c2.parent === l2 && typeof s2.raws.before < "u") {
          let t8 = s2.raws.before.split(`
`);
          return f = t8[t8.length - 1], f = f.replace(/\S/g, ""), false;
        }
      }), f;
    }
    rawSemicolon(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length && s2.last.type === "decl" && (f = s2.raws.semicolon, typeof f < "u"))
          return false;
      }), f;
    }
    rawValue(l2, f) {
      let s2 = l2[f], c2 = l2.raws[f];
      return c2 && c2.value === s2 ? c2.raw : s2;
    }
    root(l2) {
      this.body(l2), l2.raws.after && this.builder(l2.raws.after);
    }
    rule(l2) {
      this.block(l2, this.rawValue(l2, "selector")), l2.raws.ownSemicolon && this.builder(l2.raws.ownSemicolon, l2, "end");
    }
    stringify(l2, f) {
      if (!this[l2.type])
        throw new Error(
          "Unknown AST node type " + l2.type + ". Maybe you need to change PostCSS stringifier."
        );
      this[l2.type](l2, f);
    }
  }
  return Pr3 = h7, h7.default = h7, Pr3;
}
var Er3;
var aa2;
function or3() {
  if (aa2) return Er3;
  aa2 = 1;
  let u = dl();
  function a(h7, p) {
    new u(p).stringify(h7);
  }
  return Er3 = a, a.default = a, Er3;
}
var ht3 = {};
var sa2;
function Ci2() {
  return sa2 || (sa2 = 1, ht3.isClean = Symbol("isClean"), ht3.my = Symbol("my")), ht3;
}
var Tr3;
var oa2;
function lr3() {
  if (oa2) return Tr3;
  oa2 = 1;
  let u = Ai2(), a = dl(), h7 = or3(), { isClean: p, my: l2 } = Ci2();
  function f(t8, e2) {
    let r2 = new t8.constructor();
    for (let i in t8) {
      if (!Object.prototype.hasOwnProperty.call(t8, i) || i === "proxyCache") continue;
      let o2 = t8[i], v3 = typeof o2;
      i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : i === "source" ? r2[i] = o2 : Array.isArray(o2) ? r2[i] = o2.map((m) => f(m, r2)) : (v3 === "object" && o2 !== null && (o2 = f(o2)), r2[i] = o2);
    }
    return r2;
  }
  function s2(t8, e2) {
    if (e2 && typeof e2.offset < "u")
      return e2.offset;
    let r2 = 1, i = 1, o2 = 0;
    for (let v3 = 0; v3 < t8.length; v3++) {
      if (i === e2.line && r2 === e2.column) {
        o2 = v3;
        break;
      }
      t8[v3] === `
` ? (r2 = 1, i += 1) : r2 += 1;
    }
    return o2;
  }
  class c2 {
    get proxyOf() {
      return this;
    }
    constructor(e2 = {}) {
      this.raws = {}, this[p] = false, this[l2] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let i of e2[r2])
            typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(
          /\n\s{4}at /,
          `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`
        );
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = f(this);
      for (let i in e2)
        r2[i] = e2[i];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: i, start: o2 } = this.rangeBy(r2);
        return this.source.input.error(
          e2,
          { column: o2.column, line: o2.line },
          { column: i.column, line: i.line },
          r2
        );
      }
      return new u(e2);
    }
    getProxyProcessor() {
      return {
        get(e2, r2) {
          return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
        },
        set(e2, r2, i) {
          return e2[r2] === i || (e2[r2] = i, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || /* c8 ignore next */
          r2 === "text") && e2.markDirty()), true;
        }
      };
    }
    /* c8 ignore next 3 */
    markClean() {
      this[p] = true;
    }
    markDirty() {
      if (this[p]) {
        this[p] = false;
        let e2 = this;
        for (; e2 = e2.parent; )
          e2[p] = false;
      }
    }
    next() {
      if (!this.parent) return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2) {
      let r2 = this.source.start;
      if (e2.index)
        r2 = this.positionInside(e2.index);
      else if (e2.word) {
        let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = i.slice(
          s2(i, this.source.start),
          s2(i, this.source.end)
        ).indexOf(e2.word);
        v3 !== -1 && (r2 = this.positionInside(v3));
      }
      return r2;
    }
    positionInside(e2) {
      let r2 = this.source.start.column, i = this.source.start.line, o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = s2(o2, this.source.start), m = v3 + e2;
      for (let n2 = v3; n2 < m; n2++)
        o2[n2] === `
` ? (r2 = 1, i += 1) : r2 += 1;
      return { column: r2, line: i };
    }
    prev() {
      if (!this.parent) return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = {
        column: this.source.start.column,
        line: this.source.start.line
      }, i = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: r2.column + 1,
        line: r2.line
      };
      if (e2.word) {
        let o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, m = o2.slice(
          s2(o2, this.source.start),
          s2(o2, this.source.end)
        ).indexOf(e2.word);
        m !== -1 && (r2 = this.positionInside(m), i = this.positionInside(
          m + e2.word.length
        ));
      } else
        e2.start ? r2 = {
          column: e2.start.column,
          line: e2.start.line
        } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? i = {
          column: e2.end.column,
          line: e2.end.line
        } : typeof e2.endIndex == "number" ? i = this.positionInside(e2.endIndex) : e2.index && (i = this.positionInside(e2.index + 1));
      return (i.line < r2.line || i.line === r2.line && i.column <= r2.column) && (i = { column: r2.column + 1, line: r2.line }), { end: i, start: r2 };
    }
    raw(e2, r2) {
      return new a().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, i = false;
        for (let o2 of e2)
          o2 === this ? i = true : i ? (this.parent.insertAfter(r2, o2), r2 = o2) : this.parent.insertBefore(r2, o2);
        i || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (; e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let i = {}, o2 = r2 == null;
      r2 = r2 || /* @__PURE__ */ new Map();
      let v3 = 0;
      for (let m in this) {
        if (!Object.prototype.hasOwnProperty.call(this, m) || m === "parent" || m === "proxyCache") continue;
        let n2 = this[m];
        if (Array.isArray(n2))
          i[m] = n2.map((d2) => typeof d2 == "object" && d2.toJSON ? d2.toJSON(null, r2) : d2);
        else if (typeof n2 == "object" && n2.toJSON)
          i[m] = n2.toJSON(null, r2);
        else if (m === "source") {
          let d2 = r2.get(n2.input);
          d2 == null && (d2 = v3, r2.set(n2.input, v3), v3++), i[m] = {
            end: n2.end,
            inputId: d2,
            start: n2.start
          };
        } else
          i[m] = n2;
      }
      return o2 && (i.inputs = [...r2.keys()].map((m) => m.toJSON())), i;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = h7) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (i) => {
        r2 += i;
      }), r2;
    }
    warn(e2, r2, i) {
      let o2 = { node: this };
      for (let v3 in i) o2[v3] = i[v3];
      return e2.warn(r2, o2);
    }
  }
  return Tr3 = c2, c2.default = c2, Tr3;
}
var Ar3;
var la2;
function ur3() {
  if (la2) return Ar3;
  la2 = 1;
  let u = lr3();
  class a extends u {
    constructor(p) {
      super(p), this.type = "comment";
    }
  }
  return Ar3 = a, a.default = a, Ar3;
}
var Cr3;
var ua2;
function fr3() {
  if (ua2) return Cr3;
  ua2 = 1;
  let u = lr3();
  class a extends u {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(p) {
      p && typeof p.value < "u" && typeof p.value != "string" && (p = { ...p, value: String(p.value) }), super(p), this.type = "decl";
    }
  }
  return Cr3 = a, a.default = a, Cr3;
}
var Rr3;
var fa2;
function nt3() {
  if (fa2) return Rr3;
  fa2 = 1;
  let u = ur3(), a = fr3(), h7 = lr3(), { isClean: p, my: l2 } = Ci2(), f, s2, c2, t8;
  function e2(o2) {
    return o2.map((v3) => (v3.nodes && (v3.nodes = e2(v3.nodes)), delete v3.source, v3));
  }
  function r2(o2) {
    if (o2[p] = false, o2.proxyOf.nodes)
      for (let v3 of o2.proxyOf.nodes)
        r2(v3);
  }
  class i extends h7 {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...v3) {
      for (let m of v3) {
        let n2 = this.normalize(m, this.last);
        for (let d2 of n2) this.proxyOf.nodes.push(d2);
      }
      return this.markDirty(), this;
    }
    cleanRaws(v3) {
      if (super.cleanRaws(v3), this.nodes)
        for (let m of this.nodes) m.cleanRaws(v3);
    }
    each(v3) {
      if (!this.proxyOf.nodes) return;
      let m = this.getIterator(), n2, d2;
      for (; this.indexes[m] < this.proxyOf.nodes.length && (n2 = this.indexes[m], d2 = v3(this.proxyOf.nodes[n2], n2), d2 !== false); )
        this.indexes[m] += 1;
      return delete this.indexes[m], d2;
    }
    every(v3) {
      return this.nodes.every(v3);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let v3 = this.lastEach;
      return this.indexes[v3] = 0, v3;
    }
    getProxyProcessor() {
      return {
        get(v3, m) {
          return m === "proxyOf" ? v3 : v3[m] ? m === "each" || typeof m == "string" && m.startsWith("walk") ? (...n2) => v3[m](
            ...n2.map((d2) => typeof d2 == "function" ? (_3, w3) => d2(_3.toProxy(), w3) : d2)
          ) : m === "every" || m === "some" ? (n2) => v3[m](
            (d2, ..._3) => n2(d2.toProxy(), ..._3)
          ) : m === "root" ? () => v3.root().toProxy() : m === "nodes" ? v3.nodes.map((n2) => n2.toProxy()) : m === "first" || m === "last" ? v3[m].toProxy() : v3[m] : v3[m];
        },
        set(v3, m, n2) {
          return v3[m] === n2 || (v3[m] = n2, (m === "name" || m === "params" || m === "selector") && v3.markDirty()), true;
        }
      };
    }
    index(v3) {
      return typeof v3 == "number" ? v3 : (v3.proxyOf && (v3 = v3.proxyOf), this.proxyOf.nodes.indexOf(v3));
    }
    insertAfter(v3, m) {
      let n2 = this.index(v3), d2 = this.normalize(m, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(v3);
      for (let w3 of d2) this.proxyOf.nodes.splice(n2 + 1, 0, w3);
      let _3;
      for (let w3 in this.indexes)
        _3 = this.indexes[w3], n2 < _3 && (this.indexes[w3] = _3 + d2.length);
      return this.markDirty(), this;
    }
    insertBefore(v3, m) {
      let n2 = this.index(v3), d2 = n2 === 0 ? "prepend" : false, _3 = this.normalize(
        m,
        this.proxyOf.nodes[n2],
        d2
      ).reverse();
      n2 = this.index(v3);
      for (let y2 of _3) this.proxyOf.nodes.splice(n2, 0, y2);
      let w3;
      for (let y2 in this.indexes)
        w3 = this.indexes[y2], n2 <= w3 && (this.indexes[y2] = w3 + _3.length);
      return this.markDirty(), this;
    }
    normalize(v3, m) {
      if (typeof v3 == "string")
        v3 = e2(s2(v3).nodes);
      else if (typeof v3 > "u")
        v3 = [];
      else if (Array.isArray(v3)) {
        v3 = v3.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type === "root" && this.type !== "document") {
        v3 = v3.nodes.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type)
        v3 = [v3];
      else if (v3.prop) {
        if (typeof v3.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof v3.value != "string" && (v3.value = String(v3.value)), v3 = [new a(v3)];
      } else if (v3.selector || v3.selectors)
        v3 = [new t8(v3)];
      else if (v3.name)
        v3 = [new f(v3)];
      else if (v3.text)
        v3 = [new u(v3)];
      else
        throw new Error("Unknown node type in node creation");
      return v3.map((d2) => (d2[l2] || i.rebuild(d2), d2 = d2.proxyOf, d2.parent && d2.parent.removeChild(d2), d2[p] && r2(d2), d2.raws || (d2.raws = {}), typeof d2.raws.before > "u" && m && typeof m.raws.before < "u" && (d2.raws.before = m.raws.before.replace(/\S/g, "")), d2.parent = this.proxyOf, d2));
    }
    prepend(...v3) {
      v3 = v3.reverse();
      for (let m of v3) {
        let n2 = this.normalize(m, this.first, "prepend").reverse();
        for (let d2 of n2) this.proxyOf.nodes.unshift(d2);
        for (let d2 in this.indexes)
          this.indexes[d2] = this.indexes[d2] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(v3) {
      return v3.parent = this, this.proxyOf.nodes.push(v3), this;
    }
    removeAll() {
      for (let v3 of this.proxyOf.nodes) v3.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(v3) {
      v3 = this.index(v3), this.proxyOf.nodes[v3].parent = void 0, this.proxyOf.nodes.splice(v3, 1);
      let m;
      for (let n2 in this.indexes)
        m = this.indexes[n2], m >= v3 && (this.indexes[n2] = m - 1);
      return this.markDirty(), this;
    }
    replaceValues(v3, m, n2) {
      return n2 || (n2 = m, m = {}), this.walkDecls((d2) => {
        m.props && !m.props.includes(d2.prop) || m.fast && !d2.value.includes(m.fast) || (d2.value = d2.value.replace(v3, n2));
      }), this.markDirty(), this;
    }
    some(v3) {
      return this.nodes.some(v3);
    }
    walk(v3) {
      return this.each((m, n2) => {
        let d2;
        try {
          d2 = v3(m, n2);
        } catch (_3) {
          throw m.addToError(_3);
        }
        return d2 !== false && m.walk && (d2 = m.walk(v3)), d2;
      });
    }
    walkAtRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "atrule" && v3.test(n2.name))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "atrule" && n2.name === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "atrule")
          return m(n2, d2);
      }));
    }
    walkComments(v3) {
      return this.walk((m, n2) => {
        if (m.type === "comment")
          return v3(m, n2);
      });
    }
    walkDecls(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "decl" && v3.test(n2.prop))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "decl" && n2.prop === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "decl")
          return m(n2, d2);
      }));
    }
    walkRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "rule" && v3.test(n2.selector))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "rule" && n2.selector === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "rule")
          return m(n2, d2);
      }));
    }
  }
  return i.registerParse = (o2) => {
    s2 = o2;
  }, i.registerRule = (o2) => {
    t8 = o2;
  }, i.registerAtRule = (o2) => {
    f = o2;
  }, i.registerRoot = (o2) => {
    c2 = o2;
  }, Rr3 = i, i.default = i, i.rebuild = (o2) => {
    o2.type === "atrule" ? Object.setPrototypeOf(o2, f.prototype) : o2.type === "rule" ? Object.setPrototypeOf(o2, t8.prototype) : o2.type === "decl" ? Object.setPrototypeOf(o2, a.prototype) : o2.type === "comment" ? Object.setPrototypeOf(o2, u.prototype) : o2.type === "root" && Object.setPrototypeOf(o2, c2.prototype), o2[l2] = true, o2.nodes && o2.nodes.forEach((v3) => {
      i.rebuild(v3);
    });
  }, Rr3;
}
var Ir3;
var ca2;
function Ri2() {
  if (ca2) return Ir3;
  ca2 = 1;
  let u = nt3();
  class a extends u {
    constructor(p) {
      super(p), this.type = "atrule";
    }
    append(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...p);
    }
    prepend(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...p);
    }
  }
  return Ir3 = a, a.default = a, u.registerAtRule(a), Ir3;
}
var Mr2;
var da2;
function Ii2() {
  if (da2) return Mr2;
  da2 = 1;
  let u = nt3(), a, h7;
  class p extends u {
    constructor(f) {
      super({ type: "document", ...f }), this.nodes || (this.nodes = []);
    }
    toResult(f = {}) {
      return new a(new h7(), this, f).stringify();
    }
  }
  return p.registerLazyResult = (l2) => {
    a = l2;
  }, p.registerProcessor = (l2) => {
    h7 = l2;
  }, Mr2 = p, p.default = p, Mr2;
}
var Dr3;
var pa2;
function hu2() {
  if (pa2) return Dr3;
  pa2 = 1;
  let u = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return Dr3 = { nanoid: (p = 21) => {
    let l2 = "", f = p | 0;
    for (; f--; )
      l2 += u[Math.random() * 64 | 0];
    return l2;
  }, customAlphabet: (p, l2 = 21) => (f = l2) => {
    let s2 = "", c2 = f | 0;
    for (; c2--; )
      s2 += p[Math.random() * p.length | 0];
    return s2;
  } }, Dr3;
}
var qr2;
var ha2;
function pl() {
  if (ha2) return qr2;
  ha2 = 1;
  let { existsSync: u, readFileSync: a } = Ne3, { dirname: h7, join: p } = Ne3, { SourceMapConsumer: l2, SourceMapGenerator: f } = Ne3;
  function s2(t8) {
    return Buffer ? Buffer.from(t8, "base64").toString() : window.atob(t8);
  }
  class c2 {
    constructor(e2, r2) {
      if (r2.map === false) return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let i = r2.map ? r2.map.prev : void 0, o2 = this.loadMap(r2.from, i);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = h7(this.mapFile)), o2 && (this.text = o2);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new l2(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, o2 = /^data:application\/json;charset=utf-?8,/, v3 = /^data:application\/json,/, m = e2.match(o2) || e2.match(v3);
      if (m)
        return decodeURIComponent(e2.substr(m[0].length));
      let n2 = e2.match(r2) || e2.match(i);
      if (n2)
        return s2(e2.substr(n2[0].length));
      let d2 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + d2);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/g);
      if (!r2) return;
      let i = e2.lastIndexOf(r2.pop()), o2 = e2.indexOf("*/", i);
      i > -1 && o2 > -1 && (this.annotation = this.getAnnotationURL(e2.substring(i, o2)));
    }
    loadFile(e2) {
      if (this.root = h7(e2), u(e2))
        return this.mapFile = e2, a(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false) return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let i = r2(e2);
          if (i) {
            let o2 = this.loadFile(i);
            if (!o2)
              throw new Error(
                "Unable to load previous source map: " + i.toString()
              );
            return o2;
          }
        } else {
          if (r2 instanceof l2)
            return f.fromSourceMap(r2).toString();
          if (r2 instanceof f)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error(
            "Unsupported previous source map format: " + r2.toString()
          );
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let i = this.annotation;
          return e2 && (i = p(h7(e2), i)), this.loadFile(i);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return qr2 = c2, c2.default = c2, qr2;
}
var Lr3;
var va2;
function cr3() {
  if (va2) return Lr3;
  va2 = 1;
  let { nanoid: u } = hu2(), { isAbsolute: a, resolve: h7 } = Ne3, { SourceMapConsumer: p, SourceMapGenerator: l2 } = Ne3, { fileURLToPath: f, pathToFileURL: s2 } = Ne3, c2 = Ai2(), t8 = pl(), e2 = Ne3, r2 = Symbol("fromOffsetCache"), i = !!(p && l2), o2 = !!(h7 && a);
  class v3 {
    get from() {
      return this.file || this.id;
    }
    constructor(n2, d2 = {}) {
      if (n2 === null || typeof n2 > "u" || typeof n2 == "object" && !n2.toString)
        throw new Error(`PostCSS received ${n2} instead of CSS string`);
      if (this.css = n2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, d2.document && (this.document = d2.document.toString()), d2.from && (!o2 || /^\w+:\/\//.test(d2.from) || a(d2.from) ? this.file = d2.from : this.file = h7(d2.from)), o2 && i) {
        let _3 = new t8(this.css, d2);
        if (_3.text) {
          this.map = _3;
          let w3 = _3.consumer().file;
          !this.file && w3 && (this.file = this.mapResolve(w3));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(n2, d2, _3, w3 = {}) {
      let y2, x, g2;
      if (d2 && typeof d2 == "object") {
        let A = d2, E2 = _3;
        if (typeof A.offset == "number") {
          let b3 = this.fromOffset(A.offset);
          d2 = b3.line, _3 = b3.col;
        } else
          d2 = A.line, _3 = A.column;
        if (typeof E2.offset == "number") {
          let b3 = this.fromOffset(E2.offset);
          x = b3.line, y2 = b3.col;
        } else
          x = E2.line, y2 = E2.column;
      } else if (!_3) {
        let A = this.fromOffset(d2);
        d2 = A.line, _3 = A.col;
      }
      let O3 = this.origin(d2, _3, x, y2);
      return O3 ? g2 = new c2(
        n2,
        O3.endLine === void 0 ? O3.line : { column: O3.column, line: O3.line },
        O3.endLine === void 0 ? O3.column : { column: O3.endColumn, line: O3.endLine },
        O3.source,
        O3.file,
        w3.plugin
      ) : g2 = new c2(
        n2,
        x === void 0 ? d2 : { column: _3, line: d2 },
        x === void 0 ? _3 : { column: y2, line: x },
        this.css,
        this.file,
        w3.plugin
      ), g2.input = { column: _3, endColumn: y2, endLine: x, line: d2, source: this.css }, this.file && (s2 && (g2.input.url = s2(this.file).toString()), g2.input.file = this.file), g2;
    }
    fromOffset(n2) {
      let d2, _3;
      if (this[r2])
        _3 = this[r2];
      else {
        let y2 = this.css.split(`
`);
        _3 = new Array(y2.length);
        let x = 0;
        for (let g2 = 0, O3 = y2.length; g2 < O3; g2++)
          _3[g2] = x, x += y2[g2].length + 1;
        this[r2] = _3;
      }
      d2 = _3[_3.length - 1];
      let w3 = 0;
      if (n2 >= d2)
        w3 = _3.length - 1;
      else {
        let y2 = _3.length - 2, x;
        for (; w3 < y2; )
          if (x = w3 + (y2 - w3 >> 1), n2 < _3[x])
            y2 = x - 1;
          else if (n2 >= _3[x + 1])
            w3 = x + 1;
          else {
            w3 = x;
            break;
          }
      }
      return {
        col: n2 - _3[w3] + 1,
        line: w3 + 1
      };
    }
    mapResolve(n2) {
      return /^\w+:\/\//.test(n2) ? n2 : h7(this.map.consumer().sourceRoot || this.map.root || ".", n2);
    }
    origin(n2, d2, _3, w3) {
      if (!this.map) return false;
      let y2 = this.map.consumer(), x = y2.originalPositionFor({ column: d2, line: n2 });
      if (!x.source) return false;
      let g2;
      typeof _3 == "number" && (g2 = y2.originalPositionFor({ column: w3, line: _3 }));
      let O3;
      a(x.source) ? O3 = s2(x.source) : O3 = new URL(
        x.source,
        this.map.consumer().sourceRoot || s2(this.map.mapFile)
      );
      let A = {
        column: x.column,
        endColumn: g2 && g2.column,
        endLine: g2 && g2.line,
        line: x.line,
        url: O3.toString()
      };
      if (O3.protocol === "file:")
        if (f)
          A.file = f(O3);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let E2 = y2.sourceContentFor(x.source);
      return E2 && (A.source = E2), A;
    }
    toJSON() {
      let n2 = {};
      for (let d2 of ["hasBOM", "css", "file", "id"])
        this[d2] != null && (n2[d2] = this[d2]);
      return this.map && (n2.map = { ...this.map }, n2.map.consumerCache && (n2.map.consumerCache = void 0)), n2;
    }
  }
  return Lr3 = v3, v3.default = v3, e2 && e2.registerInput && e2.registerInput(v3), Lr3;
}
var Nr3;
var ga2;
function lt2() {
  if (ga2) return Nr3;
  ga2 = 1;
  let u = nt3(), a, h7;
  class p extends u {
    constructor(f) {
      super(f), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(f, s2, c2) {
      let t8 = super.normalize(f);
      if (s2) {
        if (c2 === "prepend")
          this.nodes.length > 1 ? s2.raws.before = this.nodes[1].raws.before : delete s2.raws.before;
        else if (this.first !== s2)
          for (let e2 of t8)
            e2.raws.before = s2.raws.before;
      }
      return t8;
    }
    removeChild(f, s2) {
      let c2 = this.index(f);
      return !s2 && c2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[c2].raws.before), super.removeChild(f);
    }
    toResult(f = {}) {
      return new a(new h7(), this, f).stringify();
    }
  }
  return p.registerLazyResult = (l2) => {
    a = l2;
  }, p.registerProcessor = (l2) => {
    h7 = l2;
  }, Nr3 = p, p.default = p, u.registerRoot(p), Nr3;
}
var Fr3;
var ma2;
function hl() {
  if (ma2) return Fr3;
  ma2 = 1;
  let u = {
    comma(a) {
      return u.split(a, [","], true);
    },
    space(a) {
      let h7 = [" ", `
`, "	"];
      return u.split(a, h7);
    },
    split(a, h7, p) {
      let l2 = [], f = "", s2 = false, c2 = 0, t8 = false, e2 = "", r2 = false;
      for (let i of a)
        r2 ? r2 = false : i === "\\" ? r2 = true : t8 ? i === e2 && (t8 = false) : i === '"' || i === "'" ? (t8 = true, e2 = i) : i === "(" ? c2 += 1 : i === ")" ? c2 > 0 && (c2 -= 1) : c2 === 0 && h7.includes(i) && (s2 = true), s2 ? (f !== "" && l2.push(f.trim()), f = "", s2 = false) : f += i;
      return (p || f !== "") && l2.push(f.trim()), l2;
    }
  };
  return Fr3 = u, u.default = u, Fr3;
}
var $r3;
var ya2;
function Mi2() {
  if (ya2) return $r3;
  ya2 = 1;
  let u = nt3(), a = hl();
  class h7 extends u {
    get selectors() {
      return a.comma(this.selector);
    }
    set selectors(l2) {
      let f = this.selector ? this.selector.match(/,\s*/) : null, s2 = f ? f[0] : "," + this.raw("between", "beforeOpen");
      this.selector = l2.join(s2);
    }
    constructor(l2) {
      super(l2), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return $r3 = h7, h7.default = h7, u.registerRule(h7), $r3;
}
var Ur3;
var wa2;
function vu2() {
  if (wa2) return Ur3;
  wa2 = 1;
  let u = Ri2(), a = ur3(), h7 = fr3(), p = cr3(), l2 = pl(), f = lt2(), s2 = Mi2();
  function c2(t8, e2) {
    if (Array.isArray(t8)) return t8.map((o2) => c2(o2));
    let { inputs: r2, ...i } = t8;
    if (r2) {
      e2 = [];
      for (let o2 of r2) {
        let v3 = { ...o2, __proto__: p.prototype };
        v3.map && (v3.map = {
          ...v3.map,
          __proto__: l2.prototype
        }), e2.push(v3);
      }
    }
    if (i.nodes && (i.nodes = t8.nodes.map((o2) => c2(o2, e2))), i.source) {
      let { inputId: o2, ...v3 } = i.source;
      i.source = v3, o2 != null && (i.source.input = e2[o2]);
    }
    if (i.type === "root")
      return new f(i);
    if (i.type === "decl")
      return new h7(i);
    if (i.type === "rule")
      return new s2(i);
    if (i.type === "comment")
      return new a(i);
    if (i.type === "atrule")
      return new u(i);
    throw new Error("Unknown node type: " + t8.type);
  }
  return Ur3 = c2, c2.default = c2, Ur3;
}
var zr2;
var ba2;
function vl() {
  if (ba2) return zr2;
  ba2 = 1;
  let { dirname: u, relative: a, resolve: h7, sep: p } = Ne3, { SourceMapConsumer: l2, SourceMapGenerator: f } = Ne3, { pathToFileURL: s2 } = Ne3, c2 = cr3(), t8 = !!(l2 && f), e2 = !!(u && h7 && a && p);
  class r2 {
    constructor(o2, v3, m, n2) {
      this.stringify = o2, this.mapOpts = m.map || {}, this.root = v3, this.opts = m, this.css = n2, this.originalCSS = n2, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let o2;
      this.isInline() ? o2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? o2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? o2 = this.mapOpts.annotation(this.opts.to, this.root) : o2 = this.outputFile() + ".map";
      let v3 = `
`;
      this.css.includes(`\r
`) && (v3 = `\r
`), this.css += v3 + "/*# sourceMappingURL=" + o2 + " */";
    }
    applyPrevMaps() {
      for (let o2 of this.previous()) {
        let v3 = this.toUrl(this.path(o2.file)), m = o2.root || u(o2.file), n2;
        this.mapOpts.sourcesContent === false ? (n2 = new l2(o2.text), n2.sourcesContent && (n2.sourcesContent = null)) : n2 = o2.consumer(), this.map.applySourceMap(n2, v3, this.toUrl(this.path(m)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let o2;
          for (let v3 = this.root.nodes.length - 1; v3 >= 0; v3--)
            o2 = this.root.nodes[v3], o2.type === "comment" && o2.text.startsWith("# sourceMappingURL=") && this.root.removeChild(v3);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), e2 && t8 && this.isMap())
        return this.generateMap();
      {
        let o2 = "";
        return this.stringify(this.root, (v3) => {
          o2 += v3;
        }), [o2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let o2 = this.previous()[0].consumer();
        o2.file = this.outputFile(), this.map = f.fromSourceMap(o2, {
          ignoreInvalidMapping: true
        });
      } else
        this.map = new f({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new f({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      let o2 = 1, v3 = 1, m = "<no source>", n2 = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, d2, _3;
      this.stringify(this.root, (w3, y2, x) => {
        if (this.css += w3, y2 && x !== "end" && (n2.generated.line = o2, n2.generated.column = v3 - 1, y2.source && y2.source.start ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.start.line, n2.original.column = y2.source.start.column - 1, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, this.map.addMapping(n2))), _3 = w3.match(/\n/g), _3 ? (o2 += _3.length, d2 = w3.lastIndexOf(`
`), v3 = w3.length - d2) : v3 += w3.length, y2 && x !== "start") {
          let g2 = y2.parent || { raws: {} };
          (!(y2.type === "decl" || y2.type === "atrule" && !y2.nodes) || y2 !== g2.last || g2.raws.semicolon) && (y2.source && y2.source.end ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.end.line, n2.original.column = y2.source.end.column - 1, n2.generated.line = o2, n2.generated.column = v3 - 2, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, n2.generated.line = o2, n2.generated.column = v3 - 1, this.map.addMapping(n2)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((o2) => o2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let o2 = this.mapOpts.annotation;
      return typeof o2 < "u" && o2 !== true ? false : this.previous().length ? this.previous().some((v3) => v3.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((o2) => o2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(o2) {
      if (this.mapOpts.absolute || o2.charCodeAt(0) === 60 || /^\w+:\/\//.test(o2)) return o2;
      let v3 = this.memoizedPaths.get(o2);
      if (v3) return v3;
      let m = this.opts.to ? u(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (m = u(h7(m, this.mapOpts.annotation)));
      let n2 = a(m, o2);
      return this.memoizedPaths.set(o2, n2), n2;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((o2) => {
            if (o2.source && o2.source.input.map) {
              let v3 = o2.source.input.map;
              this.previousMaps.includes(v3) || this.previousMaps.push(v3);
            }
          });
        else {
          let o2 = new c2(this.originalCSS, this.opts);
          o2.map && this.previousMaps.push(o2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let o2 = {};
      if (this.root)
        this.root.walk((v3) => {
          if (v3.source) {
            let m = v3.source.input.from;
            if (m && !o2[m]) {
              o2[m] = true;
              let n2 = this.usesFileUrls ? this.toFileUrl(m) : this.toUrl(this.path(m));
              this.map.setSourceContent(n2, v3.source.input.css);
            }
          }
        });
      else if (this.css) {
        let v3 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(v3, this.css);
      }
    }
    sourcePath(o2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(o2.source.input.from) : this.toUrl(this.path(o2.source.input.from));
    }
    toBase64(o2) {
      return Buffer ? Buffer.from(o2).toString("base64") : window.btoa(unescape(encodeURIComponent(o2)));
    }
    toFileUrl(o2) {
      let v3 = this.memoizedFileURLs.get(o2);
      if (v3) return v3;
      if (s2) {
        let m = s2(o2).toString();
        return this.memoizedFileURLs.set(o2, m), m;
      } else
        throw new Error(
          "`map.absolute` option is not available in this PostCSS build"
        );
    }
    toUrl(o2) {
      let v3 = this.memoizedURLs.get(o2);
      if (v3) return v3;
      p === "\\" && (o2 = o2.replace(/\\/g, "/"));
      let m = encodeURI(o2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(o2, m), m;
    }
  }
  return zr2 = r2, zr2;
}
var Wr3;
var _a4;
function gu2() {
  if (_a4) return Wr3;
  _a4 = 1;
  const u = 39, a = 34, h7 = 92, p = 47, l2 = 10, f = 32, s2 = 12, c2 = 9, t8 = 13, e2 = 91, r2 = 93, i = 40, o2 = 41, v3 = 123, m = 125, n2 = 59, d2 = 42, _3 = 58, w3 = 64, y2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, x = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, g2 = /.[\r\n"'(/\\]/, O3 = /[\da-f]/i;
  return Wr3 = function(E2, b3 = {}) {
    let k3 = E2.css.valueOf(), q2 = b3.ignoreErrors, M2, W3, S3, P3, C, R3, $2, B3, z3, L3, F = k3.length, D = 0, I3 = [], N3 = [];
    function J3() {
      return D;
    }
    function T3(V4) {
      throw E2.error("Unclosed " + V4, D);
    }
    function U2() {
      return N3.length === 0 && D >= F;
    }
    function j3(V4) {
      if (N3.length) return N3.pop();
      if (D >= F) return;
      let K3 = V4 ? V4.ignoreUnclosed : false;
      switch (M2 = k3.charCodeAt(D), M2) {
        case l2:
        case f:
        case c2:
        case t8:
        case s2: {
          P3 = D;
          do
            P3 += 1, M2 = k3.charCodeAt(P3);
          while (M2 === f || M2 === l2 || M2 === c2 || M2 === t8 || M2 === s2);
          R3 = ["space", k3.slice(D, P3)], D = P3 - 1;
          break;
        }
        case e2:
        case r2:
        case v3:
        case m:
        case _3:
        case n2:
        case o2: {
          let X3 = String.fromCharCode(M2);
          R3 = [X3, X3, D];
          break;
        }
        case i: {
          if (L3 = I3.length ? I3.pop()[1] : "", z3 = k3.charCodeAt(D + 1), L3 === "url" && z3 !== u && z3 !== a && z3 !== f && z3 !== l2 && z3 !== c2 && z3 !== s2 && z3 !== t8) {
            P3 = D;
            do {
              if ($2 = false, P3 = k3.indexOf(")", P3 + 1), P3 === -1)
                if (q2 || K3) {
                  P3 = D;
                  break;
                } else
                  T3("bracket");
              for (B3 = P3; k3.charCodeAt(B3 - 1) === h7; )
                B3 -= 1, $2 = !$2;
            } while ($2);
            R3 = ["brackets", k3.slice(D, P3 + 1), D, P3], D = P3;
          } else
            P3 = k3.indexOf(")", D + 1), W3 = k3.slice(D, P3 + 1), P3 === -1 || g2.test(W3) ? R3 = ["(", "(", D] : (R3 = ["brackets", W3, D, P3], D = P3);
          break;
        }
        case u:
        case a: {
          C = M2 === u ? "'" : '"', P3 = D;
          do {
            if ($2 = false, P3 = k3.indexOf(C, P3 + 1), P3 === -1)
              if (q2 || K3) {
                P3 = D + 1;
                break;
              } else
                T3("string");
            for (B3 = P3; k3.charCodeAt(B3 - 1) === h7; )
              B3 -= 1, $2 = !$2;
          } while ($2);
          R3 = ["string", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case w3: {
          y2.lastIndex = D + 1, y2.test(k3), y2.lastIndex === 0 ? P3 = k3.length - 1 : P3 = y2.lastIndex - 2, R3 = ["at-word", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case h7: {
          for (P3 = D, S3 = true; k3.charCodeAt(P3 + 1) === h7; )
            P3 += 1, S3 = !S3;
          if (M2 = k3.charCodeAt(P3 + 1), S3 && M2 !== p && M2 !== f && M2 !== l2 && M2 !== c2 && M2 !== t8 && M2 !== s2 && (P3 += 1, O3.test(k3.charAt(P3)))) {
            for (; O3.test(k3.charAt(P3 + 1)); )
              P3 += 1;
            k3.charCodeAt(P3 + 1) === f && (P3 += 1);
          }
          R3 = ["word", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        default: {
          M2 === p && k3.charCodeAt(D + 1) === d2 ? (P3 = k3.indexOf("*/", D + 2) + 1, P3 === 0 && (q2 || K3 ? P3 = k3.length : T3("comment")), R3 = ["comment", k3.slice(D, P3 + 1), D, P3], D = P3) : (x.lastIndex = D + 1, x.test(k3), x.lastIndex === 0 ? P3 = k3.length - 1 : P3 = x.lastIndex - 2, R3 = ["word", k3.slice(D, P3 + 1), D, P3], I3.push(R3), D = P3);
          break;
        }
      }
      return D++, R3;
    }
    function H3(V4) {
      N3.push(V4);
    }
    return {
      back: H3,
      endOfFile: U2,
      nextToken: j3,
      position: J3
    };
  }, Wr3;
}
var Vr2;
var Sa2;
function mu2() {
  if (Sa2) return Vr2;
  Sa2 = 1;
  let u = Ri2(), a = ur3(), h7 = fr3(), p = lt2(), l2 = Mi2(), f = gu2();
  const s2 = {
    empty: true,
    space: true
  };
  function c2(e2) {
    for (let r2 = e2.length - 1; r2 >= 0; r2--) {
      let i = e2[r2], o2 = i[3] || i[2];
      if (o2) return o2;
    }
  }
  class t8 {
    constructor(r2) {
      this.input = r2, this.root = new p(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: r2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(r2) {
      let i = new u();
      i.name = r2[1].slice(1), i.name === "" && this.unnamedAtrule(i, r2), this.init(i, r2[2]);
      let o2, v3, m, n2 = false, d2 = false, _3 = [], w3 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (r2 = this.tokenizer.nextToken(), o2 = r2[0], o2 === "(" || o2 === "[" ? w3.push(o2 === "(" ? ")" : "]") : o2 === "{" && w3.length > 0 ? w3.push("}") : o2 === w3[w3.length - 1] && w3.pop(), w3.length === 0)
          if (o2 === ";") {
            i.source.end = this.getPosition(r2[2]), i.source.end.offset++, this.semicolon = true;
            break;
          } else if (o2 === "{") {
            d2 = true;
            break;
          } else if (o2 === "}") {
            if (_3.length > 0) {
              for (m = _3.length - 1, v3 = _3[m]; v3 && v3[0] === "space"; )
                v3 = _3[--m];
              v3 && (i.source.end = this.getPosition(v3[3] || v3[2]), i.source.end.offset++);
            }
            this.end(r2);
            break;
          } else
            _3.push(r2);
        else
          _3.push(r2);
        if (this.tokenizer.endOfFile()) {
          n2 = true;
          break;
        }
      }
      i.raws.between = this.spacesAndCommentsFromEnd(_3), _3.length ? (i.raws.afterName = this.spacesAndCommentsFromStart(_3), this.raw(i, "params", _3), n2 && (r2 = _3[_3.length - 1], i.source.end = this.getPosition(r2[3] || r2[2]), i.source.end.offset++, this.spaces = i.raws.between, i.raws.between = "")) : (i.raws.afterName = "", i.params = ""), d2 && (i.nodes = [], this.current = i);
    }
    checkMissedSemicolon(r2) {
      let i = this.colon(r2);
      if (i === false) return;
      let o2 = 0, v3;
      for (let m = i - 1; m >= 0 && (v3 = r2[m], !(v3[0] !== "space" && (o2 += 1, o2 === 2))); m--)
        ;
      throw this.input.error(
        "Missed semicolon",
        v3[0] === "word" ? v3[3] + 1 : v3[2]
      );
    }
    colon(r2) {
      let i = 0, o2, v3, m;
      for (let [n2, d2] of r2.entries()) {
        if (v3 = d2, m = v3[0], m === "(" && (i += 1), m === ")" && (i -= 1), i === 0 && m === ":")
          if (!o2)
            this.doubleColon(v3);
          else {
            if (o2[0] === "word" && o2[1] === "progid")
              continue;
            return n2;
          }
        o2 = v3;
      }
      return false;
    }
    comment(r2) {
      let i = new a();
      this.init(i, r2[2]), i.source.end = this.getPosition(r2[3] || r2[2]), i.source.end.offset++;
      let o2 = r2[1].slice(2, -2);
      if (/^\s*$/.test(o2))
        i.text = "", i.raws.left = o2, i.raws.right = "";
      else {
        let v3 = o2.match(/^(\s*)([^]*\S)(\s*)$/);
        i.text = v3[2], i.raws.left = v3[1], i.raws.right = v3[3];
      }
    }
    createTokenizer() {
      this.tokenizer = f(this.input);
    }
    decl(r2, i) {
      let o2 = new h7();
      this.init(o2, r2[0][2]);
      let v3 = r2[r2.length - 1];
      for (v3[0] === ";" && (this.semicolon = true, r2.pop()), o2.source.end = this.getPosition(
        v3[3] || v3[2] || c2(r2)
      ), o2.source.end.offset++; r2[0][0] !== "word"; )
        r2.length === 1 && this.unknownWord(r2), o2.raws.before += r2.shift()[1];
      for (o2.source.start = this.getPosition(r2[0][2]), o2.prop = ""; r2.length; ) {
        let w3 = r2[0][0];
        if (w3 === ":" || w3 === "space" || w3 === "comment")
          break;
        o2.prop += r2.shift()[1];
      }
      o2.raws.between = "";
      let m;
      for (; r2.length; )
        if (m = r2.shift(), m[0] === ":") {
          o2.raws.between += m[1];
          break;
        } else
          m[0] === "word" && /\w/.test(m[1]) && this.unknownWord([m]), o2.raws.between += m[1];
      (o2.prop[0] === "_" || o2.prop[0] === "*") && (o2.raws.before += o2.prop[0], o2.prop = o2.prop.slice(1));
      let n2 = [], d2;
      for (; r2.length && (d2 = r2[0][0], !(d2 !== "space" && d2 !== "comment")); )
        n2.push(r2.shift());
      this.precheckMissedSemicolon(r2);
      for (let w3 = r2.length - 1; w3 >= 0; w3--) {
        if (m = r2[w3], m[1].toLowerCase() === "!important") {
          o2.important = true;
          let y2 = this.stringFrom(r2, w3);
          y2 = this.spacesFromEnd(r2) + y2, y2 !== " !important" && (o2.raws.important = y2);
          break;
        } else if (m[1].toLowerCase() === "important") {
          let y2 = r2.slice(0), x = "";
          for (let g2 = w3; g2 > 0; g2--) {
            let O3 = y2[g2][0];
            if (x.trim().startsWith("!") && O3 !== "space")
              break;
            x = y2.pop()[1] + x;
          }
          x.trim().startsWith("!") && (o2.important = true, o2.raws.important = x, r2 = y2);
        }
        if (m[0] !== "space" && m[0] !== "comment")
          break;
      }
      r2.some((w3) => w3[0] !== "space" && w3[0] !== "comment") && (o2.raws.between += n2.map((w3) => w3[1]).join(""), n2 = []), this.raw(o2, "value", n2.concat(r2), i), o2.value.includes(":") && !i && this.checkMissedSemicolon(r2);
    }
    doubleColon(r2) {
      throw this.input.error(
        "Double colon",
        { offset: r2[2] },
        { offset: r2[2] + r2[1].length }
      );
    }
    emptyRule(r2) {
      let i = new l2();
      this.init(i, r2[2]), i.selector = "", i.raws.between = "", this.current = i;
    }
    end(r2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(r2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(r2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(r2) {
      if (this.spaces += r2[1], this.current.nodes) {
        let i = this.current.nodes[this.current.nodes.length - 1];
        i && i.type === "rule" && !i.raws.ownSemicolon && (i.raws.ownSemicolon = this.spaces, this.spaces = "", i.source.end = this.getPosition(r2[2]), i.source.end.offset += i.raws.ownSemicolon.length);
      }
    }
    // Helpers
    getPosition(r2) {
      let i = this.input.fromOffset(r2);
      return {
        column: i.col,
        line: i.line,
        offset: r2
      };
    }
    init(r2, i) {
      this.current.push(r2), r2.source = {
        input: this.input,
        start: this.getPosition(i)
      }, r2.raws.before = this.spaces, this.spaces = "", r2.type !== "comment" && (this.semicolon = false);
    }
    other(r2) {
      let i = false, o2 = null, v3 = false, m = null, n2 = [], d2 = r2[1].startsWith("--"), _3 = [], w3 = r2;
      for (; w3; ) {
        if (o2 = w3[0], _3.push(w3), o2 === "(" || o2 === "[")
          m || (m = w3), n2.push(o2 === "(" ? ")" : "]");
        else if (d2 && v3 && o2 === "{")
          m || (m = w3), n2.push("}");
        else if (n2.length === 0)
          if (o2 === ";")
            if (v3) {
              this.decl(_3, d2);
              return;
            } else
              break;
          else if (o2 === "{") {
            this.rule(_3);
            return;
          } else if (o2 === "}") {
            this.tokenizer.back(_3.pop()), i = true;
            break;
          } else o2 === ":" && (v3 = true);
        else o2 === n2[n2.length - 1] && (n2.pop(), n2.length === 0 && (m = null));
        w3 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (i = true), n2.length > 0 && this.unclosedBracket(m), i && v3) {
        if (!d2)
          for (; _3.length && (w3 = _3[_3.length - 1][0], !(w3 !== "space" && w3 !== "comment")); )
            this.tokenizer.back(_3.pop());
        this.decl(_3, d2);
      } else
        this.unknownWord(_3);
    }
    parse() {
      let r2;
      for (; !this.tokenizer.endOfFile(); )
        switch (r2 = this.tokenizer.nextToken(), r2[0]) {
          case "space":
            this.spaces += r2[1];
            break;
          case ";":
            this.freeSemicolon(r2);
            break;
          case "}":
            this.end(r2);
            break;
          case "comment":
            this.comment(r2);
            break;
          case "at-word":
            this.atrule(r2);
            break;
          case "{":
            this.emptyRule(r2);
            break;
          default:
            this.other(r2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(r2, i, o2, v3) {
      let m, n2, d2 = o2.length, _3 = "", w3 = true, y2, x;
      for (let g2 = 0; g2 < d2; g2 += 1)
        m = o2[g2], n2 = m[0], n2 === "space" && g2 === d2 - 1 && !v3 ? w3 = false : n2 === "comment" ? (x = o2[g2 - 1] ? o2[g2 - 1][0] : "empty", y2 = o2[g2 + 1] ? o2[g2 + 1][0] : "empty", !s2[x] && !s2[y2] ? _3.slice(-1) === "," ? w3 = false : _3 += m[1] : w3 = false) : _3 += m[1];
      if (!w3) {
        let g2 = o2.reduce((O3, A) => O3 + A[1], "");
        r2.raws[i] = { raw: g2, value: _3 };
      }
      r2[i] = _3;
    }
    rule(r2) {
      r2.pop();
      let i = new l2();
      this.init(i, r2[0][2]), i.raws.between = this.spacesAndCommentsFromEnd(r2), this.raw(i, "selector", r2), this.current = i;
    }
    spacesAndCommentsFromEnd(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[r2.length - 1][0], !(i !== "space" && i !== "comment")); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    // Errors
    spacesAndCommentsFromStart(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[0][0], !(i !== "space" && i !== "comment")); )
        o2 += r2.shift()[1];
      return o2;
    }
    spacesFromEnd(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[r2.length - 1][0], i === "space"); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    stringFrom(r2, i) {
      let o2 = "";
      for (let v3 = i; v3 < r2.length; v3++)
        o2 += r2[v3][1];
      return r2.splice(i, r2.length - i), o2;
    }
    unclosedBlock() {
      let r2 = this.current.source.start;
      throw this.input.error("Unclosed block", r2.line, r2.column);
    }
    unclosedBracket(r2) {
      throw this.input.error(
        "Unclosed bracket",
        { offset: r2[2] },
        { offset: r2[2] + 1 }
      );
    }
    unexpectedClose(r2) {
      throw this.input.error(
        "Unexpected }",
        { offset: r2[2] },
        { offset: r2[2] + 1 }
      );
    }
    unknownWord(r2) {
      throw this.input.error(
        "Unknown word " + r2[0][1],
        { offset: r2[0][2] },
        { offset: r2[0][2] + r2[0][1].length }
      );
    }
    unnamedAtrule(r2, i) {
      throw this.input.error(
        "At-rule without name",
        { offset: i[2] },
        { offset: i[2] + i[1].length }
      );
    }
  }
  return Vr2 = t8, Vr2;
}
var jr3;
var xa2;
function Di2() {
  if (xa2) return jr3;
  xa2 = 1;
  let u = nt3(), a = cr3(), h7 = mu2();
  function p(l2, f) {
    let s2 = new a(l2, f), c2 = new h7(s2);
    try {
      c2.parse();
    } catch (t8) {
      throw t8.name === "CssSyntaxError" && f && f.from && (/\.scss$/i.test(f.from) ? t8.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(f.from) ? t8.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(f.from) && (t8.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), t8;
    }
    return c2.root;
  }
  return jr3 = p, p.default = p, u.registerParse(p), jr3;
}
var Br3;
var Oa2;
function gl() {
  if (Oa2) return Br3;
  Oa2 = 1;
  class u {
    constructor(h7, p = {}) {
      if (this.type = "warning", this.text = h7, p.node && p.node.source) {
        let l2 = p.node.rangeBy(p);
        this.line = l2.start.line, this.column = l2.start.column, this.endLine = l2.end.line, this.endColumn = l2.end.column;
      }
      for (let l2 in p) this[l2] = p[l2];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return Br3 = u, u.default = u, Br3;
}
var Gr3;
var ka2;
function qi2() {
  if (ka2) return Gr3;
  ka2 = 1;
  let u = gl();
  class a {
    get content() {
      return this.css;
    }
    constructor(p, l2, f) {
      this.processor = p, this.messages = [], this.root = l2, this.opts = f, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(p, l2 = {}) {
      l2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (l2.plugin = this.lastPlugin.postcssPlugin);
      let f = new u(p, l2);
      return this.messages.push(f), f;
    }
    warnings() {
      return this.messages.filter((p) => p.type === "warning");
    }
  }
  return Gr3 = a, a.default = a, Gr3;
}
var Yr2;
var Pa2;
function ml() {
  if (Pa2) return Yr2;
  Pa2 = 1;
  let u = {};
  return Yr2 = function(h7) {
    u[h7] || (u[h7] = true, typeof console < "u" && console.warn && console.warn(h7));
  }, Yr2;
}
var Qr3;
var Ea2;
function yl() {
  if (Ea2) return Qr3;
  Ea2 = 1;
  let u = nt3(), a = Ii2(), h7 = vl(), p = Di2(), l2 = qi2(), f = lt2(), s2 = or3(), { isClean: c2, my: t8 } = Ci2(), e2 = ml();
  const r2 = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, i = {
    AtRule: true,
    AtRuleExit: true,
    Comment: true,
    CommentExit: true,
    Declaration: true,
    DeclarationExit: true,
    Document: true,
    DocumentExit: true,
    Once: true,
    OnceExit: true,
    postcssPlugin: true,
    prepare: true,
    Root: true,
    RootExit: true,
    Rule: true,
    RuleExit: true
  }, o2 = {
    Once: true,
    postcssPlugin: true,
    prepare: true
  }, v3 = 0;
  function m(x) {
    return typeof x == "object" && typeof x.then == "function";
  }
  function n2(x) {
    let g2 = false, O3 = r2[x.type];
    return x.type === "decl" ? g2 = x.prop.toLowerCase() : x.type === "atrule" && (g2 = x.name.toLowerCase()), g2 && x.append ? [
      O3,
      O3 + "-" + g2,
      v3,
      O3 + "Exit",
      O3 + "Exit-" + g2
    ] : g2 ? [O3, O3 + "-" + g2, O3 + "Exit", O3 + "Exit-" + g2] : x.append ? [O3, v3, O3 + "Exit"] : [O3, O3 + "Exit"];
  }
  function d2(x) {
    let g2;
    return x.type === "document" ? g2 = ["Document", v3, "DocumentExit"] : x.type === "root" ? g2 = ["Root", v3, "RootExit"] : g2 = n2(x), {
      eventIndex: 0,
      events: g2,
      iterator: 0,
      node: x,
      visitorIndex: 0,
      visitors: []
    };
  }
  function _3(x) {
    return x[c2] = false, x.nodes && x.nodes.forEach((g2) => _3(g2)), x;
  }
  let w3 = {};
  class y2 {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(g2, O3, A) {
      this.stringified = false, this.processed = false;
      let E2;
      if (typeof O3 == "object" && O3 !== null && (O3.type === "root" || O3.type === "document"))
        E2 = _3(O3);
      else if (O3 instanceof y2 || O3 instanceof l2)
        E2 = _3(O3.root), O3.map && (typeof A.map > "u" && (A.map = {}), A.map.inline || (A.map.inline = false), A.map.prev = O3.map);
      else {
        let b3 = p;
        A.syntax && (b3 = A.syntax.parse), A.parser && (b3 = A.parser), b3.parse && (b3 = b3.parse);
        try {
          E2 = b3(O3, A);
        } catch (k3) {
          this.processed = true, this.error = k3;
        }
        E2 && !E2[t8] && u.rebuild(E2);
      }
      this.result = new l2(g2, E2, A), this.helpers = { ...w3, postcss: w3, result: this.result }, this.plugins = this.processor.plugins.map((b3) => typeof b3 == "object" && b3.prepare ? { ...b3, ...b3.prepare(this.result) } : b3);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(g2) {
      return this.async().catch(g2);
    }
    finally(g2) {
      return this.async().then(g2, g2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(g2, O3) {
      let A = this.result.lastPlugin;
      try {
        if (O3 && O3.addToError(g2), this.error = g2, g2.name === "CssSyntaxError" && !g2.plugin)
          g2.plugin = A.postcssPlugin, g2.setMessage();
        else if (A.postcssVersion && true) {
          let E2 = A.postcssPlugin, b3 = A.postcssVersion, k3 = this.result.processor.version, q2 = b3.split("."), M2 = k3.split(".");
          (q2[0] !== M2[0] || parseInt(q2[1]) > parseInt(M2[1])) && console.error(
            "Unknown error from PostCSS plugin. Your current PostCSS version is " + k3 + ", but " + E2 + " uses " + b3 + ". Perhaps this is the source of the error below."
          );
        }
      } catch (E2) {
        console && console.error && console.error(E2);
      }
      return g2;
    }
    prepareVisitors() {
      this.listeners = {};
      let g2 = (O3, A, E2) => {
        this.listeners[A] || (this.listeners[A] = []), this.listeners[A].push([O3, E2]);
      };
      for (let O3 of this.plugins)
        if (typeof O3 == "object")
          for (let A in O3) {
            if (!i[A] && /^[A-Z]/.test(A))
              throw new Error(
                `Unknown event ${A} in ${O3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
              );
            if (!o2[A])
              if (typeof O3[A] == "object")
                for (let E2 in O3[A])
                  E2 === "*" ? g2(O3, A, O3[A][E2]) : g2(
                    O3,
                    A + "-" + E2.toLowerCase(),
                    O3[A][E2]
                  );
              else typeof O3[A] == "function" && g2(O3, A, O3[A]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let g2 = 0; g2 < this.plugins.length; g2++) {
        let O3 = this.plugins[g2], A = this.runOnRoot(O3);
        if (m(A))
          try {
            await A;
          } catch (E2) {
            throw this.handleError(E2);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (; !g2[c2]; ) {
          g2[c2] = true;
          let O3 = [d2(g2)];
          for (; O3.length > 0; ) {
            let A = this.visitTick(O3);
            if (m(A))
              try {
                await A;
              } catch (E2) {
                let b3 = O3[O3.length - 1].node;
                throw this.handleError(E2, b3);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [O3, A] of this.listeners.OnceExit) {
            this.result.lastPlugin = O3;
            try {
              if (g2.type === "document") {
                let E2 = g2.nodes.map(
                  (b3) => A(b3, this.helpers)
                );
                await Promise.all(E2);
              } else
                await A(g2, this.helpers);
            } catch (E2) {
              throw this.handleError(E2);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(g2) {
      this.result.lastPlugin = g2;
      try {
        if (typeof g2 == "object" && g2.Once) {
          if (this.result.root.type === "document") {
            let O3 = this.result.root.nodes.map(
              (A) => g2.Once(A, this.helpers)
            );
            return m(O3[0]) ? Promise.all(O3) : O3;
          }
          return g2.Once(this.result.root, this.helpers);
        } else if (typeof g2 == "function")
          return g2(this.result.root, this.result);
      } catch (O3) {
        throw this.handleError(O3);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true, this.sync();
      let g2 = this.result.opts, O3 = s2;
      g2.syntax && (O3 = g2.syntax.stringify), g2.stringifier && (O3 = g2.stringifier), O3.stringify && (O3 = O3.stringify);
      let E2 = new h7(O3, this.result.root, this.result.opts).generate();
      return this.result.css = E2[0], this.result.map = E2[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let g2 of this.plugins) {
        let O3 = this.runOnRoot(g2);
        if (m(O3))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (; !g2[c2]; )
          g2[c2] = true, this.walkSync(g2);
        if (this.listeners.OnceExit)
          if (g2.type === "document")
            for (let O3 of g2.nodes)
              this.visitSync(this.listeners.OnceExit, O3);
          else
            this.visitSync(this.listeners.OnceExit, g2);
      }
      return this.result;
    }
    then(g2, O3) {
      return "from" in this.opts || e2(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      ), this.async().then(g2, O3);
    }
    toString() {
      return this.css;
    }
    visitSync(g2, O3) {
      for (let [A, E2] of g2) {
        this.result.lastPlugin = A;
        let b3;
        try {
          b3 = E2(O3, this.helpers);
        } catch (k3) {
          throw this.handleError(k3, O3.proxyOf);
        }
        if (O3.type !== "root" && O3.type !== "document" && !O3.parent)
          return true;
        if (m(b3))
          throw this.getAsyncError();
      }
    }
    visitTick(g2) {
      let O3 = g2[g2.length - 1], { node: A, visitors: E2 } = O3;
      if (A.type !== "root" && A.type !== "document" && !A.parent) {
        g2.pop();
        return;
      }
      if (E2.length > 0 && O3.visitorIndex < E2.length) {
        let [k3, q2] = E2[O3.visitorIndex];
        O3.visitorIndex += 1, O3.visitorIndex === E2.length && (O3.visitors = [], O3.visitorIndex = 0), this.result.lastPlugin = k3;
        try {
          return q2(A.toProxy(), this.helpers);
        } catch (M2) {
          throw this.handleError(M2, A);
        }
      }
      if (O3.iterator !== 0) {
        let k3 = O3.iterator, q2;
        for (; q2 = A.nodes[A.indexes[k3]]; )
          if (A.indexes[k3] += 1, !q2[c2]) {
            q2[c2] = true, g2.push(d2(q2));
            return;
          }
        O3.iterator = 0, delete A.indexes[k3];
      }
      let b3 = O3.events;
      for (; O3.eventIndex < b3.length; ) {
        let k3 = b3[O3.eventIndex];
        if (O3.eventIndex += 1, k3 === v3) {
          A.nodes && A.nodes.length && (A[c2] = true, O3.iterator = A.getIterator());
          return;
        } else if (this.listeners[k3]) {
          O3.visitors = this.listeners[k3];
          return;
        }
      }
      g2.pop();
    }
    walkSync(g2) {
      g2[c2] = true;
      let O3 = n2(g2);
      for (let A of O3)
        if (A === v3)
          g2.nodes && g2.each((E2) => {
            E2[c2] || this.walkSync(E2);
          });
        else {
          let E2 = this.listeners[A];
          if (E2 && this.visitSync(E2, g2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return y2.registerPostcss = (x) => {
    w3 = x;
  }, Qr3 = y2, y2.default = y2, f.registerLazyResult(y2), a.registerLazyResult(y2), Qr3;
}
var Hr3;
var Ta2;
function yu2() {
  if (Ta2) return Hr3;
  Ta2 = 1;
  let u = vl(), a = Di2();
  const h7 = qi2();
  let p = or3(), l2 = ml();
  class f {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let c2, t8 = a;
      try {
        c2 = t8(this._css, this._opts);
      } catch (e2) {
        this.error = e2;
      }
      if (this.error)
        throw this.error;
      return this._root = c2, c2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(c2, t8, e2) {
      t8 = t8.toString(), this.stringified = false, this._processor = c2, this._css = t8, this._opts = e2, this._map = void 0;
      let r2, i = p;
      this.result = new h7(this._processor, r2, this._opts), this.result.css = t8;
      let o2 = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return o2.root;
        }
      });
      let v3 = new u(i, r2, this._opts, t8);
      if (v3.isMap()) {
        let [m, n2] = v3.generate();
        m && (this.result.css = m), n2 && (this.result.map = n2);
      } else
        v3.clearAnnotation(), this.result.css = v3.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(c2) {
      return this.async().catch(c2);
    }
    finally(c2) {
      return this.async().then(c2, c2);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(c2, t8) {
      return "from" in this._opts || l2(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      ), this.async().then(c2, t8);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Hr3 = f, f.default = f, Hr3;
}
var Jr3;
var Aa2;
function wu2() {
  if (Aa2) return Jr3;
  Aa2 = 1;
  let u = Ii2(), a = yl(), h7 = yu2(), p = lt2();
  class l2 {
    constructor(s2 = []) {
      this.version = "8.5.3", this.plugins = this.normalize(s2);
    }
    normalize(s2) {
      let c2 = [];
      for (let t8 of s2)
        if (t8.postcss === true ? t8 = t8() : t8.postcss && (t8 = t8.postcss), typeof t8 == "object" && Array.isArray(t8.plugins))
          c2 = c2.concat(t8.plugins);
        else if (typeof t8 == "object" && t8.postcssPlugin)
          c2.push(t8);
        else if (typeof t8 == "function")
          c2.push(t8);
        else if (typeof t8 == "object" && (t8.parse || t8.stringify)) {
          if (true)
            throw new Error(
              "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
            );
        } else
          throw new Error(t8 + " is not a PostCSS plugin");
      return c2;
    }
    process(s2, c2 = {}) {
      return !this.plugins.length && !c2.parser && !c2.stringifier && !c2.syntax ? new h7(this, s2, c2) : new a(this, s2, c2);
    }
    use(s2) {
      return this.plugins = this.plugins.concat(this.normalize([s2])), this;
    }
  }
  return Jr3 = l2, l2.default = l2, p.registerProcessor(l2), u.registerProcessor(l2), Jr3;
}
var Kr3;
var Ca2;
function Be2() {
  if (Ca2) return Kr3;
  Ca2 = 1;
  let u = Ri2(), a = ur3(), h7 = nt3(), p = Ai2(), l2 = fr3(), f = Ii2(), s2 = vu2(), c2 = cr3(), t8 = yl(), e2 = hl(), r2 = lr3(), i = Di2(), o2 = wu2(), v3 = qi2(), m = lt2(), n2 = Mi2(), d2 = or3(), _3 = gl();
  function w3(...y2) {
    return y2.length === 1 && Array.isArray(y2[0]) && (y2 = y2[0]), new o2(y2);
  }
  return w3.plugin = function(x, g2) {
    let O3 = false;
    function A(...b3) {
      console && console.warn && !O3 && (O3 = true, console.warn(
        x + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
      ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
        x + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
      ));
      let k3 = g2(...b3);
      return k3.postcssPlugin = x, k3.postcssVersion = new o2().version, k3;
    }
    let E2;
    return Object.defineProperty(A, "postcss", {
      get() {
        return E2 || (E2 = A()), E2;
      }
    }), A.process = function(b3, k3, q2) {
      return w3([A(q2)]).process(b3, k3);
    }, A;
  }, w3.stringify = d2, w3.parse = i, w3.fromJSON = s2, w3.list = e2, w3.comment = (y2) => new a(y2), w3.atRule = (y2) => new u(y2), w3.decl = (y2) => new l2(y2), w3.rule = (y2) => new n2(y2), w3.root = (y2) => new m(y2), w3.document = (y2) => new f(y2), w3.CssSyntaxError = p, w3.Declaration = l2, w3.Container = h7, w3.Processor = o2, w3.Document = f, w3.Comment = a, w3.Warning = _3, w3.AtRule = u, w3.Result = v3, w3.Input = c2, w3.Rule = n2, w3.Root = m, w3.Node = r2, t8.registerPostcss(w3), Kr3 = w3, w3.default = w3, Kr3;
}
var bu2 = Be2();
var Le3 = He3(bu2);
Le3.stringify;
Le3.fromJSON;
Le3.plugin;
var _u2 = Le3.parse;
Le3.list;
Le3.document;
Le3.comment;
Le3.atRule;
var Su2 = Le3.rule;
var xu2 = Le3.decl;
Le3.root;
Le3.CssSyntaxError;
Le3.Declaration;
Le3.Container;
Le3.Processor;
Le3.Document;
Le3.Comment;
Le3.Warning;
var wl = Le3.AtRule;
Le3.Result;
Le3.Input;
var Ra2 = Le3.Rule;
var Ou2 = Le3.Root;
Le3.Node;
var ku2 = (u) => u.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}");
var Li2 = (u) => {
  if (u.first === void 0) {
    const a = u.parent;
    a && (u.remove(), Li2(a));
  }
};
var Pu2 = (u) => {
  u.walkRules((a) => {
    u.walkRules(a.selector, (h7) => {
      if (h7 === a) return;
      const p = h7.parent;
      h7.remove(), p && Li2(p);
    });
  });
};
var bl = (u) => typeof u.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
u.type.render !== void 0;
function sr3(u, a) {
  const h7 = import_react2.default.Children.map(u, (p) => {
    if (import_react2.default.isValidElement(p)) {
      const l2 = { ...p.props };
      p.props.children && !bl(p) && (l2.children = sr3(p.props.children, a));
      const f = a(
        import_react2.default.cloneElement(p, l2, l2.children)
      );
      if (import_react2.default.isValidElement(f) && (typeof f.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
      f.type.render)) {
        const c2 = (typeof f.type == "object" ? (
          // @ts-expect-error - we know this is a component with a render function
          f.type.render
        ) : f.type)(f.props);
        return sr3(c2, a);
      }
      return f;
    }
    return a(p);
  });
  return h7 && h7.length === 1 ? h7[0] : h7;
}
var Eu2 = {
  0: "zero",
  1: "one",
  2: "two",
  3: "three",
  4: "four",
  5: "five",
  6: "six",
  7: "seven",
  8: "eight",
  9: "nine"
};
var _l = (u) => u.replaceAll("+", "plus").replaceAll("[", "").replaceAll("%", "pc").replaceAll("]", "").replaceAll("(", "").replaceAll(")", "").replaceAll("!", "imprtnt").replaceAll(">", "gt").replaceAll("<", "lt").replaceAll("=", "eq").replace(/^[0-9]/, (a) => Eu2[a]).replace(/[^a-zA-Z0-9\-_]/g, "_");
var vt3 = { exports: {} };
var gt3 = { exports: {} };
var mt3 = { exports: {} };
var yt3 = { exports: {} };
var wt3 = { exports: {} };
var bt3 = { exports: {} };
var Ye3 = {};
var _t3 = { exports: {} };
var Ia2;
function Sl() {
  return Ia2 || (Ia2 = 1, function(u, a) {
    a.__esModule = true, a.default = l2;
    function h7(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t8 = false, e2 = 0; e2 < 6 && s2[e2] !== void 0; e2++) {
        var r2 = s2.charCodeAt(e2), i = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t8 = r2 === 32, !i)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["�", c2.length + (t8 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t8 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l2(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t8 = 0; t8 < f.length; t8++) {
        if (f[t8] === "\\") {
          var e2 = h7(f.slice(t8 + 1, t8 + 7));
          if (e2 !== void 0) {
            c2 += e2[0], t8 += e2[1];
            continue;
          }
          if (f[t8 + 1] === "\\") {
            c2 += "\\", t8++;
            continue;
          }
          f.length === t8 + 1 && (c2 += f[t8]);
          continue;
        }
        c2 += f[t8];
      }
      return c2;
    }
    u.exports = a.default;
  }(_t3, _t3.exports)), _t3.exports;
}
var St3 = { exports: {} };
var Ma2;
function Tu2() {
  return Ma2 || (Ma2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  }(St3, St3.exports)), St3.exports;
}
var xt3 = { exports: {} };
var Da2;
function Au2() {
  return Da2 || (Da2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  }(xt3, xt3.exports)), xt3.exports;
}
var Ot3 = { exports: {} };
var qa2;
function Cu2() {
  return qa2 || (qa2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = "", f = p.indexOf("/*"), s2 = 0; f >= 0; ) {
        l2 = l2 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l2;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l2 = l2 + p.slice(s2), l2;
    }
    u.exports = a.default;
  }(Ot3, Ot3.exports)), Ot3.exports;
}
var La2;
function dr3() {
  if (La2) return Ye3;
  La2 = 1, Ye3.__esModule = true, Ye3.unesc = Ye3.stripComments = Ye3.getProp = Ye3.ensureObject = void 0;
  var u = l2(Sl());
  Ye3.unesc = u.default;
  var a = l2(Tu2());
  Ye3.getProp = a.default;
  var h7 = l2(Au2());
  Ye3.ensureObject = h7.default;
  var p = l2(Cu2());
  Ye3.stripComments = p.default;
  function l2(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Ye3;
}
var Na2;
function et3() {
  return Na2 || (Na2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = dr3();
    function p(c2, t8) {
      for (var e2 = 0; e2 < t8.length; e2++) {
        var r2 = t8[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l2(c2, t8, e2) {
      return t8 && p(c2.prototype, t8), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c2(t8, e2) {
      if (typeof t8 != "object" || t8 === null)
        return t8;
      var r2 = new t8.constructor();
      for (var i in t8)
        if (t8.hasOwnProperty(i)) {
          var o2 = t8[i], v3 = typeof o2;
          i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : o2 instanceof Array ? r2[i] = o2.map(function(m) {
            return c2(m, r2);
          }) : r2[i] = c2(o2, r2);
        }
      return r2;
    }, s2 = function() {
      function c2(e2) {
        e2 === void 0 && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t8 = c2.prototype;
      return t8.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, t8.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t8.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t8.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t8.clone = function(r2) {
        r2 === void 0 && (r2 = {});
        var i = f(this);
        for (var o2 in r2)
          i[o2] = r2[o2];
        return i;
      }, t8.appendToPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i, m || o2 !== i ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t8.setPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {}), this[r2] = i, this.raws[r2] = o2;
      }, t8.setPropertyWithoutEscape = function(r2, i) {
        this[r2] = i, this.raws && delete this.raws[r2];
      }, t8.isAtPosition = function(r2, i) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i || this.source.end.line === r2 && this.source.end.column < i);
      }, t8.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t8.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t8.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l2(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === void 0 && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h7.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === void 0 && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h7.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    }();
    a.default = s2, u.exports = a.default;
  }(bt3, bt3.exports)), bt3.exports;
}
var Re3 = {};
var Fa2;
function Fe3() {
  if (Fa2) return Re3;
  Fa2 = 1, Re3.__esModule = true, Re3.UNIVERSAL = Re3.TAG = Re3.STRING = Re3.SELECTOR = Re3.ROOT = Re3.PSEUDO = Re3.NESTING = Re3.ID = Re3.COMMENT = Re3.COMBINATOR = Re3.CLASS = Re3.ATTRIBUTE = void 0;
  var u = "tag";
  Re3.TAG = u;
  var a = "string";
  Re3.STRING = a;
  var h7 = "selector";
  Re3.SELECTOR = h7;
  var p = "root";
  Re3.ROOT = p;
  var l2 = "pseudo";
  Re3.PSEUDO = l2;
  var f = "nesting";
  Re3.NESTING = f;
  var s2 = "id";
  Re3.ID = s2;
  var c2 = "comment";
  Re3.COMMENT = c2;
  var t8 = "combinator";
  Re3.COMBINATOR = t8;
  var e2 = "class";
  Re3.CLASS = e2;
  var r2 = "attribute";
  Re3.ATTRIBUTE = r2;
  var i = "universal";
  return Re3.UNIVERSAL = i, Re3;
}
var $a2;
function Ni2() {
  return $a2 || ($a2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(et3()), p = f(Fe3());
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _3 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_3) return (_3 = _3.call(n2)).next.bind(_3);
      if (Array.isArray(n2) || (_3 = t8(n2)) || d2) {
        _3 && (n2 = _3);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t8(n2, d2) {
      if (n2) {
        if (typeof n2 == "string") return e2(n2, d2);
        var _3 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_3 === "Object" && n2.constructor && (_3 = n2.constructor.name), _3 === "Map" || _3 === "Set") return Array.from(n2);
        if (_3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_3)) return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _3 = 0, w3 = new Array(d2); _3 < d2; _3++)
        w3[_3] = n2[_3];
      return w3;
    }
    function r2(n2, d2) {
      for (var _3 = 0; _3 < d2.length; _3++) {
        var w3 = d2[_3];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i(n2, d2, _3) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _3 = d2.prototype;
      return _3.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _3.prepend = function(y2) {
        y2.parent = this, this.nodes.unshift(y2);
        for (var x in this.indexes)
          this.indexes[x]++;
        return this;
      }, _3.at = function(y2) {
        return this.nodes[y2];
      }, _3.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _3.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = void 0, this.nodes.splice(y2, 1);
        var x;
        for (var g2 in this.indexes)
          x = this.indexes[g2], x >= y2 && (this.indexes[g2] = x - 1);
        return this;
      }, _3.removeAll = function() {
        for (var y2 = c2(this.nodes), x; !(x = y2()).done; ) {
          var g2 = x.value;
          g2.parent = void 0;
        }
        return this.nodes = [], this;
      }, _3.empty = function() {
        return this.removeAll();
      }, _3.insertAfter = function(y2, x) {
        var g2;
        x.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2; E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3 + 1, 0, x].concat(A)), x.parent = this;
        var b3;
        for (var k3 in this.indexes)
          b3 = this.indexes[k3], O3 < b3 && (this.indexes[k3] = b3 + arguments.length - 1);
        return this;
      }, _3.insertBefore = function(y2, x) {
        var g2;
        x.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2; E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3, 0, x].concat(A)), x.parent = this;
        var b3;
        for (var k3 in this.indexes)
          b3 = this.indexes[k3], b3 >= O3 && (this.indexes[k3] = b3 + arguments.length - 1);
        return this;
      }, _3._findChildAtPosition = function(y2, x) {
        var g2 = void 0;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x))
            return g2 = O3, false;
        }), g2;
      }, _3.atPosition = function(y2, x) {
        if (this.isAtPosition(y2, x))
          return this._findChildAtPosition(y2, x) || this;
      }, _3._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _3.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x = this.lastEach;
        if (this.indexes[x] = 0, !!this.length) {
          for (var g2, O3; this.indexes[x] < this.length && (g2 = this.indexes[x], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x] += 1;
          if (delete this.indexes[x], O3 === false)
            return false;
        }
      }, _3.walk = function(y2) {
        return this.each(function(x, g2) {
          var O3 = y2(x, g2);
          if (O3 !== false && x.length && (O3 = x.walk(y2)), O3 === false)
            return false;
        });
      }, _3.walkAttributes = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x, g2);
        });
      }, _3.walkClasses = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x, g2);
        });
      }, _3.walkCombinators = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x, g2);
        });
      }, _3.walkComments = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x, g2);
        });
      }, _3.walkIds = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x, g2);
        });
      }, _3.walkNesting = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x, g2);
        });
      }, _3.walkPseudos = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x, g2);
        });
      }, _3.walkTags = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x, g2);
        });
      }, _3.walkUniversals = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x, g2);
        });
      }, _3.split = function(y2) {
        var x = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b3 = y2.call(x, A);
          return g2.push(A), b3 ? (O3.push(g2), g2 = []) : E2 === x.length - 1 && O3.push(g2), O3;
        }, []);
      }, _3.map = function(y2) {
        return this.nodes.map(y2);
      }, _3.reduce = function(y2, x) {
        return this.nodes.reduce(y2, x);
      }, _3.every = function(y2) {
        return this.nodes.every(y2);
      }, _3.some = function(y2) {
        return this.nodes.some(y2);
      }, _3.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _3.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _3.toString = function() {
        return this.map(String).join("");
      }, i(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    }(h7.default);
    a.default = m, u.exports = a.default;
  }(wt3, wt3.exports)), wt3.exports;
}
var Ua2;
function xl() {
  return Ua2 || (Ua2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Ni2()), p = Fe3();
    function l2(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i) {
      for (var o2 = 0; o2 < i.length; o2++) {
        var v3 = i[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i, o2) {
      return i && f(r2.prototype, i), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i) {
      r2.prototype = Object.create(i.prototype), r2.prototype.constructor = r2, t8(r2, i);
    }
    function t8(r2, i) {
      return t8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t8(r2, i);
    }
    var e2 = function(r2) {
      c2(i, r2);
      function i(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i;
    }(h7.default);
    a.default = e2, u.exports = a.default;
  }(yt3, yt3.exports)), yt3.exports;
}
var kt3 = { exports: {} };
var za2;
function Ol() {
  return za2 || (za2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Ni2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.SELECTOR, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(kt3, kt3.exports)), kt3.exports;
}
var Pt3 = { exports: {} };
var Xr3;
var Wa2;
function at3() {
  if (Wa2) return Xr3;
  Wa2 = 1;
  var u = {}, a = u.hasOwnProperty, h7 = function(t8, e2) {
    if (!t8)
      return e2;
    var r2 = {};
    for (var i in e2)
      r2[i] = a.call(t8, i) ? t8[i] : e2[i];
    return r2;
  }, p = /[ -,\.\/:-@\[-\^`\{-~]/, l2 = /[ -,\.\/:-@\[\]\^`\{-~]/, f = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, s2 = function c2(t8, e2) {
    e2 = h7(e2, c2.options), e2.quotes != "single" && e2.quotes != "double" && (e2.quotes = "single");
    for (var r2 = e2.quotes == "double" ? '"' : "'", i = e2.isIdentifier, o2 = t8.charAt(0), v3 = "", m = 0, n2 = t8.length; m < n2; ) {
      var d2 = t8.charAt(m++), _3 = d2.charCodeAt(), w3 = void 0;
      if (_3 < 32 || _3 > 126) {
        if (_3 >= 55296 && _3 <= 56319 && m < n2) {
          var y2 = t8.charCodeAt(m++);
          (y2 & 64512) == 56320 ? _3 = ((_3 & 1023) << 10) + (y2 & 1023) + 65536 : m--;
        }
        w3 = "\\" + _3.toString(16).toUpperCase() + " ";
      } else
        e2.escapeEverything ? p.test(d2) ? w3 = "\\" + d2 : w3 = "\\" + _3.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(d2) ? w3 = "\\" + _3.toString(16).toUpperCase() + " " : d2 == "\\" || !i && (d2 == '"' && r2 == d2 || d2 == "'" && r2 == d2) || i && l2.test(d2) ? w3 = "\\" + d2 : w3 = d2;
      v3 += w3;
    }
    return i && (/^-[-\d]/.test(v3) ? v3 = "\\-" + v3.slice(1) : /\d/.test(o2) && (v3 = "\\3" + o2 + " " + v3.slice(1))), v3 = v3.replace(f, function(x, g2, O3) {
      return g2 && g2.length % 2 ? x : (g2 || "") + O3;
    }), !i && e2.wrap ? r2 + v3 + r2 : v3;
  };
  return s2.options = {
    escapeEverything: false,
    isIdentifier: false,
    quotes: "single",
    wrap: false
  }, s2.version = "3.0.0", Xr3 = s2, Xr3;
}
var Va2;
function kl() {
  return Va2 || (Va2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(at3()), p = dr3(), l2 = s2(et3()), f = Fe3();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0; m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t8(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i = function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t8(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _3 = (0, h7.default)(d2, {
              isIdentifier: true
            });
            _3 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _3) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    }(l2.default);
    a.default = i, u.exports = a.default;
  }(Pt3, Pt3.exports)), Pt3.exports;
}
var Et3 = { exports: {} };
var ja2;
function Pl() {
  return ja2 || (ja2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMMENT, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Et3, Et3.exports)), Et3.exports;
}
var Tt3 = { exports: {} };
var Ba2;
function El() {
  return Ba2 || (Ba2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t8.prototype.valueToString.call(this);
      }, e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Tt3, Tt3.exports)), Tt3.exports;
}
var At3 = { exports: {} };
var Ct3 = { exports: {} };
var Ga2;
function Fi2() {
  return Ga2 || (Ga2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = f(at3()), p = dr3(), l2 = f(et3());
    function f(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s2(i, o2) {
      for (var v3 = 0; v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i, m.key, m);
      }
    }
    function c2(i, o2, v3) {
      return o2 && s2(i.prototype, o2), Object.defineProperty(i, "prototype", { writable: false }), i;
    }
    function t8(i, o2) {
      i.prototype = Object.create(o2.prototype), i.prototype.constructor = i, e2(i, o2);
    }
    function e2(i, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i, o2);
    }
    var r2 = function(i) {
      t8(o2, i);
      function o2() {
        return i.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h7.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    }(l2.default);
    a.default = r2, u.exports = a.default;
  }(Ct3, Ct3.exports)), Ct3.exports;
}
var Ya2;
function Tl() {
  return Ya2 || (Ya2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Fi2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.TAG, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(At3, At3.exports)), At3.exports;
}
var Rt3 = { exports: {} };
var Qa2;
function Al() {
  return Qa2 || (Qa2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.STRING, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Rt3, Rt3.exports)), Rt3.exports;
}
var It3 = { exports: {} };
var Ha2;
function Cl() {
  return Ha2 || (Ha2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Ni2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(It3, It3.exports)), It3.exports;
}
var Zr3 = {};
var en3;
var Ja2;
function Rl() {
  if (Ja2) return en3;
  Ja2 = 1, en3 = u;
  function u(h7, p) {
    if (a("noDeprecation"))
      return h7;
    var l2 = false;
    function f() {
      if (!l2) {
        if (a("throwDeprecation"))
          throw new Error(p);
        a("traceDeprecation") ? console.trace(p) : console.warn(p), l2 = true;
      }
      return h7.apply(this, arguments);
    }
    return f;
  }
  function a(h7) {
    try {
      if (!ta2.localStorage) return false;
    } catch {
      return false;
    }
    var p = ta2.localStorage[h7];
    return p == null ? false : String(p).toLowerCase() === "true";
  }
  return en3;
}
var Ka2;
function Il() {
  return Ka2 || (Ka2 = 1, function(u) {
    u.__esModule = true, u.default = void 0, u.unescapeValue = d2;
    var a = s2(at3()), h7 = s2(Sl()), p = s2(Fi2()), l2 = Fe3(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0; A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t8(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b3) {
        return E2.__proto__ = b3, E2;
      }, r2(g2, O3);
    }
    var i = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b3 = E2.match(o2);
      return b3 && (A = b3[1], E2 = b3[2]), E2 = (0, h7.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _3(g2) {
      if (g2.quoteMark !== void 0 || g2.value === void 0)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === void 0 && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b3;
        return E2 === void 0 && (E2 = {}), b3 = g2.call(this, _3(E2)) || this, b3.type = l2.ATTRIBUTE, b3.raws = b3.raws || {}, Object.defineProperty(b3.raws, "unquoted", {
          get: i(function() {
            return b3.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i(function() {
            return b3.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b3._constructed = true, b3;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b3) {
        b3 === void 0 && (b3 = {});
        var k3 = this._determineQuoteMark(b3), q2 = y2[k3], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b3) {
        return b3.smart ? this.smartQuoteMark(b3) : this.preferredQuoteMark(b3);
      }, A.setValue = function(b3, k3) {
        k3 === void 0 && (k3 = {}), this._value = b3, this._quoteMark = this._determineQuoteMark(k3), this._syncRawValue();
      }, A.smartQuoteMark = function(b3) {
        var k3 = this.value, q2 = k3.replace(/[^']/g, "").length, M2 = k3.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k3, {
            isIdentifier: true
          });
          if (W3 === k3)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b3);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b3.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k3, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else return M2 === q2 ? this.preferredQuoteMark(b3) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b3) {
        var k3 = b3.preferCurrentQuoteMark ? this.quoteMark : b3.quoteMark;
        return k3 === void 0 && (k3 = b3.preferCurrentQuoteMark ? b3.quoteMark : this.quoteMark), k3 === void 0 && (k3 = O3.DOUBLE_QUOTE), k3;
      }, A._syncRawValue = function() {
        var b3 = (0, a.default)(this._value, y2[this.quoteMark]);
        b3 === this._value ? this.raws && delete this.raws.value : this.raws.value = b3;
      }, A._handleEscapes = function(b3, k3) {
        if (this._constructed) {
          var q2 = (0, a.default)(k3, {
            isIdentifier: true
          });
          q2 !== k3 ? this.raws[b3] = q2 : delete this.raws[b3];
        }
      }, A._spacesFor = function(b3) {
        var k3 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b3] || {}, M2 = this.raws.spaces && this.raws.spaces[b3] || {};
        return Object.assign(k3, q2, M2);
      }, A._stringFor = function(b3, k3, q2) {
        k3 === void 0 && (k3 = b3), q2 === void 0 && (q2 = x);
        var M2 = this._spacesFor(k3);
        return q2(this.stringifyProperty(b3), M2);
      }, A.offsetOf = function(b3) {
        var k3 = 1, q2 = this._spacesFor("attribute");
        if (k3 += q2.before.length, b3 === "namespace" || b3 === "ns")
          return this.namespace ? k3 : -1;
        if (b3 === "attributeNS" || (k3 += this.namespaceString.length, this.namespace && (k3 += 1), b3 === "attribute"))
          return k3;
        k3 += this.stringifyProperty("attribute").length, k3 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k3 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b3 === "operator")
          return W3 ? k3 : -1;
        k3 += W3.length, k3 += M2.after.length;
        var S3 = this._spacesFor("value");
        k3 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b3 === "value")
          return P3 ? k3 : -1;
        k3 += P3.length, k3 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k3 += C.before.length, b3 === "insensitive" && this.insensitive ? k3 : -1;
      }, A.toString = function() {
        var b3 = this, k3 = [this.rawSpaceBefore, "["];
        return k3.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k3.push(this._stringFor("operator")), k3.push(this._stringFor("value")), k3.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b3.quoted && M2.before.length === 0 && !(b3.spaces.value && b3.spaces.value.after) && (M2.before = " "), x(q2, M2);
        }))), k3.push("]"), k3.push(this.rawSpaceAfter), k3.join("");
      }, t8(O3, [{
        key: "quoted",
        get: function() {
          var b3 = this.quoteMark;
          return b3 === "'" || b3 === '"';
        },
        set: function(b3) {
          m();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b3) {
          if (!this._constructed) {
            this._quoteMark = b3;
            return;
          }
          this._quoteMark !== b3 && (this._quoteMark = b3, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function(b3) {
            if (this._constructed) {
              var k3 = d2(b3), q2 = k3.deprecatedUsage, M2 = k3.unescaped, W3 = k3.quoteMark;
              if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
                return;
              this._value = M2, this._quoteMark = W3, this._syncRawValue();
            } else
              this._value = b3;
          }
        )
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b3) {
          b3 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = b3;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b3) {
          this._handleEscapes("attribute", b3), this._attribute = b3;
        }
      }]), O3;
    }(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  }(Zr3)), Zr3;
}
var Mt2 = { exports: {} };
var Xa2;
function Ml() {
  return Xa2 || (Xa2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Fi2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.UNIVERSAL, i.value = "*", i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Mt2, Mt2.exports)), Mt2.exports;
}
var Dt3 = { exports: {} };
var Za2;
function Dl() {
  return Za2 || (Za2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMBINATOR, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Dt3, Dt3.exports)), Dt3.exports;
}
var qt3 = { exports: {} };
var es2;
function ql() {
  return es2 || (es2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.NESTING, i.value = "&", i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(qt3, qt3.exports)), qt3.exports;
}
var Lt3 = { exports: {} };
var ts2;
function Ru2() {
  return ts2 || (ts2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      return p.sort(function(l2, f) {
        return l2 - f;
      });
    }
    u.exports = a.default;
  }(Lt3, Lt3.exports)), Lt3.exports;
}
var tn3 = {};
var oe2 = {};
var rs2;
function Ll() {
  if (rs2) return oe2;
  rs2 = 1, oe2.__esModule = true, oe2.word = oe2.tilde = oe2.tab = oe2.str = oe2.space = oe2.slash = oe2.singleQuote = oe2.semicolon = oe2.plus = oe2.pipe = oe2.openSquare = oe2.openParenthesis = oe2.newline = oe2.greaterThan = oe2.feed = oe2.equals = oe2.doubleQuote = oe2.dollar = oe2.cr = oe2.comment = oe2.comma = oe2.combinator = oe2.colon = oe2.closeSquare = oe2.closeParenthesis = oe2.caret = oe2.bang = oe2.backslash = oe2.at = oe2.asterisk = oe2.ampersand = void 0;
  var u = 38;
  oe2.ampersand = u;
  var a = 42;
  oe2.asterisk = a;
  var h7 = 64;
  oe2.at = h7;
  var p = 44;
  oe2.comma = p;
  var l2 = 58;
  oe2.colon = l2;
  var f = 59;
  oe2.semicolon = f;
  var s2 = 40;
  oe2.openParenthesis = s2;
  var c2 = 41;
  oe2.closeParenthesis = c2;
  var t8 = 91;
  oe2.openSquare = t8;
  var e2 = 93;
  oe2.closeSquare = e2;
  var r2 = 36;
  oe2.dollar = r2;
  var i = 126;
  oe2.tilde = i;
  var o2 = 94;
  oe2.caret = o2;
  var v3 = 43;
  oe2.plus = v3;
  var m = 61;
  oe2.equals = m;
  var n2 = 124;
  oe2.pipe = n2;
  var d2 = 62;
  oe2.greaterThan = d2;
  var _3 = 32;
  oe2.space = _3;
  var w3 = 39;
  oe2.singleQuote = w3;
  var y2 = 34;
  oe2.doubleQuote = y2;
  var x = 47;
  oe2.slash = x;
  var g2 = 33;
  oe2.bang = g2;
  var O3 = 92;
  oe2.backslash = O3;
  var A = 13;
  oe2.cr = A;
  var E2 = 12;
  oe2.feed = E2;
  var b3 = 10;
  oe2.newline = b3;
  var k3 = 9;
  oe2.tab = k3;
  var q2 = w3;
  oe2.str = q2;
  var M2 = -1;
  oe2.comment = M2;
  var W3 = -2;
  oe2.word = W3;
  var S3 = -3;
  return oe2.combinator = S3, oe2;
}
var ns2;
function Iu2() {
  return ns2 || (ns2 = 1, function(u) {
    u.__esModule = true, u.FIELDS = void 0, u.default = m;
    var a = f(Ll()), h7, p;
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    for (var s2 = (h7 = {}, h7[a.tab] = true, h7[a.newline] = true, h7[a.cr] = true, h7[a.feed] = true, h7), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t8 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0; r2 < e2.length; r2++)
      t8[e2.charCodeAt(r2)] = true;
    function i(n2, d2) {
      var _3 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_3), c2[w3])
          return _3 - 1;
        w3 === a.backslash ? _3 = o2(n2, _3) + 1 : _3++;
      } while (_3 < n2.length);
      return _3 - 1;
    }
    function o2(n2, d2) {
      var _3 = d2, w3 = n2.charCodeAt(_3 + 1);
      if (!s2[w3]) if (t8[w3]) {
        var y2 = 0;
        do
          _3++, y2++, w3 = n2.charCodeAt(_3 + 1);
        while (t8[w3] && y2 < 6);
        y2 < 6 && w3 === a.space && _3++;
      } else
        _3++;
      return _3;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _3 = n2.css.valueOf(), w3 = _3, y2 = w3.length, x = -1, g2 = 1, O3 = 0, A = 0, E2, b3, k3, q2, M2, W3, S3, P3, C, R3, $2, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _3 += D, C = _3.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x, O3);
      }
      for (; O3 < y2; ) {
        switch (E2 = _3.charCodeAt(O3), E2 === a.newline && (x = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C), E2 === a.newline && (x = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k3 = C - x - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k3 = O3 - x, A = C;
            break;
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _3.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C; _3.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          default:
            E2 === a.slash && _3.charCodeAt(O3 + 1) === a.asterisk ? (C = _3.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b3 = _3.slice(O3, C + 1), P3 = b3.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $2 = C - P3[S3].length) : (R3 = g2, $2 = x), z3 = a.comment, g2 = R3, q2 = R3, k3 = C - $2) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1) : (C = i(_3, O3), z3 = a.word, q2 = g2, k3 = C - x), A = C + 1;
            break;
        }
        d2.push([
          z3,
          // [0] Token type
          g2,
          // [1] Starting line
          O3 - x,
          // [2] Starting column
          q2,
          // [3] Ending line
          k3,
          // [4] Ending column
          O3,
          // [5] Start position / Source index
          A
          // [6] End position
        ]), $2 && (x = $2, $2 = null), O3 = A;
      }
      return d2;
    }
  }(tn3)), tn3;
}
var is2;
function Mu2() {
  return is2 || (is2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = A(xl()), p = A(Ol()), l2 = A(kl()), f = A(Pl()), s2 = A(El()), c2 = A(Tl()), t8 = A(Al()), e2 = A(Cl()), r2 = O3(Il()), i = A(Ml()), o2 = A(Dl()), v3 = A(ql()), m = A(Ru2()), n2 = O3(Iu2()), d2 = O3(Ll()), _3 = O3(Fe3()), w3 = dr3(), y2, x;
    function g2(L3) {
      if (typeof WeakMap != "function") return null;
      var F = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T3 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T3 && (T3.get || T3.set) ? Object.defineProperty(I3, J3, T3) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0; D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b3(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k3 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k3, (x = {}, x[d2.comment] = true, x));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === void 0 && (L3.raws[F] = D)), L3;
    }
    function $2(L3, F) {
      for (var D = -1, I3 = []; (D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = function() {
      function L3(D, I3) {
        I3 === void 0 && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h7.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T3 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false; U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne3 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T3, "spaces", V4);
                var de3 = T3.spaces[V4].after || "";
                T3.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || null;
                _e3 && (T3.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne3[n2.FIELDS.TYPE] === d2.equals)
                T3.operator = Q3, V4 = "operator";
              else if ((!T3.namespace || V4 === "namespace" && !K3) && ne3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = j3, H3 = ""), T3.namespace = (T3.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T3, "raws", "namespace") || null;
                be3 && (T3.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T3, "raws", "value");
                T3.value += "$", ie3 && (T3.raws.value = ie3 + "$");
                break;
              }
            case d2.caret:
              ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne3[n2.FIELDS.TYPE] === d2.equals ? (T3.operator = Q3, V4 = "operator") : !T3.namespace && !T3.attribute && (T3.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne3 && this.content(ne3) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && // this look-ahead probably fails with comment nodes involved.
              !T3.operator && !T3.namespace)
                T3.namespace = Q3, V4 = "namespace";
              else if (!T3.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = H3, H3 = ""), T3.attribute = (T3.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T3, "raws", "attribute") || null;
                ke3 && (T3.raws.attribute += Q3), V4 = "attribute";
              } else if (!T3.value && T3.value !== "" || V4 === "value" && !(K3 || T3.quoteMark)) {
                var Y3 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T3, "raws", "value") || "", te2 = T3.value || "";
                T3.value = te2 + Y3, T3.quoteMark = null, (Y3 !== Q3 || G3) && ((0, w3.ensureObject)(T3, "raws"), T3.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T3.value || T3.value === "") && (T3.quoteMark || K3) ? (T3.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T3, "raws"), T3.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T3, "spaces", "insensitive"), T3.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "insensitive"), T3.raws.spaces.insensitive.before = H3, H3 = "")) : (T3.value || T3.value === "") && (V4 = "value", T3.value += Q3, T3.raws.value && (T3.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T3.attribute || !T3.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T3.value = se3, T3.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T3, "raws"), T3.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T3.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T3.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T3.operator = T3.operator ? T3.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne3 && ne3[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T3, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T3, "raws", "spaces", V4), T3.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T3[V4] || "", ve3 = (0, w3.getProp)(T3, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T3, "raws"), T3.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T3, "attribute"), R3(T3, "namespace"), this.newNode(new r2.default(T3)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T3 = "", U2 = void 0;
        do
          if (k3[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T3 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T3 && (j3.before = T3, T3 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T3) {
          if (U2)
            U2.spaces.after = T3;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t8.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T3,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === void 0 && (N3 = false);
        var T3 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T3 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T3 && (U2 = void 0);
        var j3 = {
          space: T3,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === void 0 && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T3 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T3;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T3 = this.current.last;
            if (T3) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== void 0 && (T3.rawSpaceAfter += H3), T3.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = void 0;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k3[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne3 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne3, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y3 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y3.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y3.spaces.after = ie3.slice(1)) : Y3.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y3
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _3.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T3 = this.current;
          for (I3.append(J3), this.current = J3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T3;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t8.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken; this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T3, U2) {
            N3 += T3, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t8.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T3 = this.nextToken, U2 = this.content(); T3 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T3[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T3 = this.nextToken;
        }
        var V4 = $2(U2, ".").filter(function(ne3) {
          var de3 = U2[ne3 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $2(U2, "#").filter(function(ne3) {
          return U2[ne3 - 1] !== "\\";
        }), X3 = $2(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne3) {
          return !~X3.indexOf(ne3);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne3, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne3, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y3 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne3, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne3)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new l2.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne3)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y3
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (; this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T3 = I3.pop();
          I3 = I3.join(", ") + " or " + T3;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === void 0 && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === void 0 && (I3 = this.position + 1);
        for (var N3 = I3; N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b3(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    }();
    a.default = z3, u.exports = a.default;
  }(mt3, mt3.exports)), mt3.exports;
}
var as2;
function Du2() {
  return as2 || (as2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = p(Mu2());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l2 = function() {
      function f(c2, t8) {
        this.func = c2 || function() {
        }, this.funcRes = null, this.options = t8;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t8 != "string";
      }, s2._isLossy = function(t8) {
        t8 === void 0 && (t8 = {});
        var e2 = Object.assign({}, this.options, t8);
        return e2.lossless === false;
      }, s2._root = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = new h7.default(t8, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t8) {
        return {
          lossy: this._isLossy(t8)
        };
      }, s2._run = function(t8, e2) {
        var r2 = this;
        return e2 === void 0 && (e2 = {}), new Promise(function(i, o2) {
          try {
            var v3 = r2._root(t8, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = void 0;
              return r2._shouldUpdateSelector(t8, e2) && (n2 = v3.toString(), t8.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = this._root(t8, e2), i = this.func(r2);
        if (i && typeof i.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = void 0;
        return e2.updateSelector && typeof t8 != "string" && (o2 = r2.toString(), t8.selector = o2), {
          transform: i,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t8, e2) {
        return this._runSync(t8, e2).root;
      }, s2.transform = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t8, e2) {
        return this._runSync(t8, e2).transform;
      }, s2.process = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t8, e2) {
        var r2 = this._runSync(t8, e2);
        return r2.string || r2.root.toString();
      }, f;
    }();
    a.default = l2, u.exports = a.default;
  }(gt3, gt3.exports)), gt3.exports;
}
var rn3 = {};
var Ie3 = {};
var ss2;
function qu2() {
  if (ss2) return Ie3;
  ss2 = 1, Ie3.__esModule = true, Ie3.universal = Ie3.tag = Ie3.string = Ie3.selector = Ie3.root = Ie3.pseudo = Ie3.nesting = Ie3.id = Ie3.comment = Ie3.combinator = Ie3.className = Ie3.attribute = void 0;
  var u = o2(Il()), a = o2(kl()), h7 = o2(Dl()), p = o2(Pl()), l2 = o2(El()), f = o2(ql()), s2 = o2(Cl()), c2 = o2(xl()), t8 = o2(Ol()), e2 = o2(Al()), r2 = o2(Tl()), i = o2(Ml());
  function o2(b3) {
    return b3 && b3.__esModule ? b3 : { default: b3 };
  }
  var v3 = function(k3) {
    return new u.default(k3);
  };
  Ie3.attribute = v3;
  var m = function(k3) {
    return new a.default(k3);
  };
  Ie3.className = m;
  var n2 = function(k3) {
    return new h7.default(k3);
  };
  Ie3.combinator = n2;
  var d2 = function(k3) {
    return new p.default(k3);
  };
  Ie3.comment = d2;
  var _3 = function(k3) {
    return new l2.default(k3);
  };
  Ie3.id = _3;
  var w3 = function(k3) {
    return new f.default(k3);
  };
  Ie3.nesting = w3;
  var y2 = function(k3) {
    return new s2.default(k3);
  };
  Ie3.pseudo = y2;
  var x = function(k3) {
    return new c2.default(k3);
  };
  Ie3.root = x;
  var g2 = function(k3) {
    return new t8.default(k3);
  };
  Ie3.selector = g2;
  var O3 = function(k3) {
    return new e2.default(k3);
  };
  Ie3.string = O3;
  var A = function(k3) {
    return new r2.default(k3);
  };
  Ie3.tag = A;
  var E2 = function(k3) {
    return new i.default(k3);
  };
  return Ie3.universal = E2, Ie3;
}
var Pe3 = {};
var os2;
function Lu2() {
  if (os2) return Pe3;
  os2 = 1, Pe3.__esModule = true, Pe3.isComment = Pe3.isCombinator = Pe3.isClassName = Pe3.isAttribute = void 0, Pe3.isContainer = y2, Pe3.isIdentifier = void 0, Pe3.isNamespace = x, Pe3.isNesting = void 0, Pe3.isNode = p, Pe3.isPseudo = void 0, Pe3.isPseudoClass = w3, Pe3.isPseudoElement = _3, Pe3.isUniversal = Pe3.isTag = Pe3.isString = Pe3.isSelector = Pe3.isRoot = void 0;
  var u = Fe3(), a, h7 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h7[g2.type];
  }
  function l2(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l2.bind(null, u.ATTRIBUTE);
  Pe3.isAttribute = f;
  var s2 = l2.bind(null, u.CLASS);
  Pe3.isClassName = s2;
  var c2 = l2.bind(null, u.COMBINATOR);
  Pe3.isCombinator = c2;
  var t8 = l2.bind(null, u.COMMENT);
  Pe3.isComment = t8;
  var e2 = l2.bind(null, u.ID);
  Pe3.isIdentifier = e2;
  var r2 = l2.bind(null, u.NESTING);
  Pe3.isNesting = r2;
  var i = l2.bind(null, u.PSEUDO);
  Pe3.isPseudo = i;
  var o2 = l2.bind(null, u.ROOT);
  Pe3.isRoot = o2;
  var v3 = l2.bind(null, u.SELECTOR);
  Pe3.isSelector = v3;
  var m = l2.bind(null, u.STRING);
  Pe3.isString = m;
  var n2 = l2.bind(null, u.TAG);
  Pe3.isTag = n2;
  var d2 = l2.bind(null, u.UNIVERSAL);
  Pe3.isUniversal = d2;
  function _3(g2) {
    return i(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i(g2) && !_3(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x(g2) {
    return f(g2) || n2(g2);
  }
  return Pe3;
}
var ls2;
function Nu2() {
  return ls2 || (ls2 = 1, function(u) {
    u.__esModule = true;
    var a = Fe3();
    Object.keys(a).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === a[l2] || (u[l2] = a[l2]);
    });
    var h7 = qu2();
    Object.keys(h7).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === h7[l2] || (u[l2] = h7[l2]);
    });
    var p = Lu2();
    Object.keys(p).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === p[l2] || (u[l2] = p[l2]);
    });
  }(rn3)), rn3;
}
var us2;
function Fu2() {
  return us2 || (us2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(Du2()), p = f(Nu2());
    function l2(e2) {
      if (typeof WeakMap != "function") return null;
      var r2 = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
      return (l2 = function(v3) {
        return v3 ? i : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i = l2(r2);
      if (i && i.has(e2))
        return i.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i && i.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h7.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t8 = c2;
    a.default = t8, u.exports = a.default;
  }(vt3, vt3.exports)), vt3.exports;
}
var $u2 = Fu2();
var $i2 = He3($u2);
var fs2 = (u) => u.replace(/-(\w|$)/g, (a, h7) => h7.toUpperCase());
var Uu2 = (u) => {
  const a = u.toLowerCase();
  return a.startsWith("--") ? a : a.startsWith("-ms-") ? fs2(a.slice(1)) : fs2(a);
};
function zu2(u) {
  return u.replaceAll(/\\[0-9]|\\/g, "");
}
var Wu2 = (u, a) => {
  u.walkRules((h7) => {
    var p;
    ((p = h7.parent) == null ? void 0 : p.type) !== "atrule" && $i2((l2) => {
      let f = false;
      l2.walkPseudos(() => {
        f = true;
      }), f || a(h7);
    }).processSync(h7.selector);
  });
};
function Vu2(u, a) {
  let p = [...u.split(" ")];
  const l2 = {};
  return Wu2(a, (f) => {
    const s2 = [];
    $i2((c2) => {
      c2.walkClasses((t8) => {
        s2.push(zu2(t8.value));
      });
    }).processSync(f.selector), p = p.filter((c2) => !s2.includes(c2)), f.walkDecls((c2) => {
      l2[Uu2(c2.prop)] = c2.value + (c2.important ? "!important" : "");
    });
  }), {
    styles: l2,
    residualClassName: p.join(" ")
  };
}
var ju2 = (u) => {
  u.walkDecls((a) => {
    const h7 = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/g;
    a.value = a.value.replaceAll(
      h7,
      (p, l2, f, s2, c2) => {
        const t8 = c2 === "1" || typeof c2 > "u" ? "" : `,${c2}`;
        return `rgb(${l2},${f},${s2}${t8})`;
      }
    );
  });
};
var Bu2 = (u) => {
  const a = [], h7 = [], p = $i2();
  return u.walkAtRules((l2) => {
    const f = l2.clone();
    f.walkRules((c2) => {
      const t8 = p.astSync(c2.selector);
      t8.walkClasses((r2) => {
        h7.push(r2.value), cs2(r2);
      });
      const e2 = c2.clone({ selector: t8.toString() });
      e2.walkDecls((r2) => {
        r2.important = true;
      }), c2.replaceWith(e2);
    });
    const s2 = a.find(
      (c2) => c2 instanceof wl && c2.params === f.params
    );
    s2 ? s2.append(f.nodes) : a.push(f);
  }), u.walkRules((l2) => {
    if (l2.parent && l2.parent.type !== "root") return;
    const f = p.astSync(l2.selector);
    let s2 = false;
    if (f.walkPseudos(() => {
      s2 = true;
    }), !!s2 && (f.walkClasses((c2) => {
      h7.push(c2.value), cs2(c2);
    }), s2)) {
      const c2 = l2.clone({ selector: f.toString() });
      c2.walkDecls((t8) => {
        t8.important = true;
      }), a.push(c2);
    }
  }), {
    nonInlinableClasses: h7,
    sanitizedRules: a
  };
};
var cs2 = (u) => {
  u.replaceWith(
    u.clone({
      value: _l(u.value)
    })
  );
};
var Gu2 = (u, a) => {
  const h7 = {};
  let p = [], l2 = [];
  if (u.props.className) {
    const s2 = a.generateRootForClasses(
      u.props.className.split(" ")
    );
    ju2(s2), {
      sanitizedRules: l2,
      nonInlinableClasses: p
    } = Bu2(s2);
    const { styles: c2, residualClassName: t8 } = Vu2(
      u.props.className,
      s2
    );
    if (h7.style = {
      ...c2,
      ...u.props.style
    }, !bl(u))
      if (t8.trim().length > 0) {
        h7.className = t8;
        for (const e2 of p)
          h7.className = h7.className.replace(
            e2,
            _l(e2)
          );
      } else
        h7.className = void 0;
  }
  const f = {
    ...u.props,
    ...h7
  };
  return {
    elementWithInlinedStyles: import_react2.default.cloneElement(
      u,
      f,
      f.children
    ),
    nonInlinableClasses: p,
    nonInlineStyleNodes: l2
  };
};
var nn2 = {};
var ds2;
function Yu2() {
  return ds2 || (ds2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    let a = {
      atrule: [
        "name",
        "params"
      ],
      rule: [
        "selector"
      ]
    }, h7 = new Set(Object.keys(a));
    function p() {
      function l2(f) {
        let s2 = null;
        f.each((c2) => {
          if (!h7.has(c2.type)) {
            s2 = null;
            return;
          }
          if (s2 === null) {
            s2 = c2;
            return;
          }
          let t8 = a[c2.type];
          var e2, r2;
          c2.type === "atrule" && c2.name === "font-face" ? s2 = c2 : t8.every((i) => ((e2 = c2[i]) !== null && e2 !== void 0 ? e2 : "").replace(/\s+/g, " ") === ((r2 = s2[i]) !== null && r2 !== void 0 ? r2 : "").replace(/\s+/g, " ")) ? (c2.nodes && s2.append(c2.nodes), c2.remove()) : s2 = c2;
        }), f.each((c2) => {
          c2.type === "atrule" && l2(c2);
        });
      }
      return (f) => {
        l2(f);
      };
    }
  }(nn2)), nn2;
}
var Qu2 = Yu2();
var Hu2 = He3(Qu2);
var an2 = {};
var ps2;
function Ju2() {
  return ps2 || (ps2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a() {
      return (l2) => {
        l2.walkRules((f) => {
          let s2 = /* @__PURE__ */ new Map(), c2 = /* @__PURE__ */ new Set([]), t8 = /* @__PURE__ */ new Map();
          f.walkDecls((e2) => {
            if (e2.parent === f) {
              if (s2.has(e2.prop)) {
                if (s2.get(e2.prop).value === e2.value) {
                  c2.add(s2.get(e2.prop)), s2.set(e2.prop, e2);
                  return;
                }
                t8.has(e2.prop) || t8.set(e2.prop, /* @__PURE__ */ new Set()), t8.get(e2.prop).add(s2.get(e2.prop)), t8.get(e2.prop).add(e2);
              }
              s2.set(e2.prop, e2);
            }
          });
          for (let e2 of c2)
            e2.remove();
          for (let e2 of t8.values()) {
            let r2 = /* @__PURE__ */ new Map();
            for (let i of e2) {
              let o2 = p(i.value);
              o2 !== null && (r2.has(o2) || r2.set(o2, /* @__PURE__ */ new Set()), r2.get(o2).add(i));
            }
            for (let i of r2.values()) {
              let o2 = Array.from(i).slice(0, -1);
              for (let v3 of o2)
                v3.remove();
            }
          }
        });
      };
    }
    let h7 = Symbol("unitless-number");
    function p(l2) {
      let f = /^-?\d*.?\d+([\w%]+)?$/g.exec(l2);
      if (f) {
        var s2;
        return (s2 = f[1]) !== null && s2 !== void 0 ? s2 : h7;
      }
      return null;
    }
  }(an2)), an2;
}
var Ku2 = Ju2();
var Xu2 = He3(Ku2);
var sn2 = {};
var on3 = { exports: {} };
var hs2;
function Nl() {
  return hs2 || (hs2 = 1, function(u, a) {
    (function(h7, p) {
      u.exports = function(l2, f, s2, c2, t8) {
        for (f = f.split ? f.split(".") : f, c2 = 0; c2 < f.length; c2++) l2 = l2 ? l2[f[c2]] : t8;
        return l2 === t8 ? s2 : l2;
      };
    })();
  }(on3)), on3.exports;
}
var ln3 = { exports: {} };
var vs3;
function Zu2() {
  return vs3 || (vs3 = 1, function(u) {
    (function() {
      function a(l2, f, s2) {
        if (!l2) return null;
        a.caseSensitive || (l2 = l2.toLowerCase());
        var c2 = a.threshold === null ? null : a.threshold * l2.length, t8 = a.thresholdAbsolute, e2;
        c2 !== null && t8 !== null ? e2 = Math.min(c2, t8) : c2 !== null ? e2 = c2 : t8 !== null ? e2 = t8 : e2 = null;
        var r2, i, o2, v3, m, n2 = f.length;
        for (m = 0; m < n2; m++)
          if (i = f[m], s2 && (i = i[s2]), !!i && (a.caseSensitive ? o2 = i : o2 = i.toLowerCase(), v3 = p(l2, o2, e2), (e2 === null || v3 < e2) && (e2 = v3, s2 && a.returnWinningObject ? r2 = f[m] : r2 = i, a.returnFirstMatch)))
            return r2;
        return r2 || a.nullResultValue;
      }
      a.threshold = 0.4, a.thresholdAbsolute = 20, a.caseSensitive = false, a.nullResultValue = null, a.returnWinningObject = null, a.returnFirstMatch = false, u.exports ? u.exports = a : window.didYouMean = a;
      var h7 = Math.pow(2, 32) - 1;
      function p(l2, f, s2) {
        s2 = s2 || s2 === 0 ? s2 : h7;
        var c2 = l2.length, t8 = f.length;
        if (c2 === 0) return Math.min(s2 + 1, t8);
        if (t8 === 0) return Math.min(s2 + 1, c2);
        if (Math.abs(c2 - t8) > s2) return s2 + 1;
        var e2 = [], r2, i, o2, v3, m;
        for (r2 = 0; r2 <= t8; r2++)
          e2[r2] = [r2];
        for (i = 0; i <= c2; i++)
          e2[0][i] = i;
        for (r2 = 1; r2 <= t8; r2++) {
          for (o2 = h7, v3 = 1, r2 > s2 && (v3 = r2 - s2), m = t8 + 1, m > s2 + r2 && (m = s2 + r2), i = 1; i <= c2; i++)
            i < v3 || i > m ? e2[r2][i] = s2 + 1 : f.charAt(r2 - 1) === l2.charAt(i - 1) ? e2[r2][i] = e2[r2 - 1][i - 1] : e2[r2][i] = Math.min(
              e2[r2 - 1][i - 1] + 1,
              // Substitute
              Math.min(
                e2[r2][i - 1] + 1,
                // Insert
                e2[r2 - 1][i] + 1
              )
            ), e2[r2][i] < o2 && (o2 = e2[r2][i]);
          if (o2 > s2) return s2 + 1;
        }
        return e2[t8][c2];
      }
    })();
  }(ln3)), ln3.exports;
}
var un3 = {};
var fn3 = {};
var gs2;
function ut3() {
  return gs2 || (gs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      if (Object.prototype.toString.call(h7) !== "[object Object]")
        return false;
      const p = Object.getPrototypeOf(h7);
      return p === null || Object.getPrototypeOf(p) === null;
    }
  }(fn3)), fn3;
}
var ms2;
function pr3() {
  return ms2 || (ms2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(Be2()), h7 = p(ut3());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      return [
        "fontSize",
        "outline"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2[0]), s2) : f === "fontFamily" ? (s2) => {
        typeof s2 == "function" && (s2 = s2({}));
        let c2 = Array.isArray(s2) && (0, h7.default)(s2[1]) ? s2[0] : s2;
        return Array.isArray(c2) ? c2.join(", ") : c2;
      } : [
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2.join(", ")), s2) : [
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), typeof s2 == "string" && (s2 = a.default.list.comma(s2).join(" ")), s2) : (s2, c2 = {}) => (typeof s2 == "function" && (s2 = s2(c2)), s2);
    }
  }(un3)), un3;
}
var cn3;
var ys2;
function ef() {
  if (ys2) return cn3;
  ys2 = 1;
  var u = 40, a = 41, h7 = 39, p = 34, l2 = 92, f = 47, s2 = 44, c2 = 58, t8 = 42, e2 = 117, r2 = 85, i = 43, o2 = /^[a-f0-9?-]+$/i;
  return cn3 = function(v3) {
    for (var m = [], n2 = v3, d2, _3, w3, y2, x, g2, O3, A, E2 = 0, b3 = n2.charCodeAt(E2), k3 = n2.length, q2 = [
      {
        nodes: m
      }
    ], M2 = 0, W3, S3 = "", P3 = "", C = ""; E2 < k3; )
      if (b3 <= 32) {
        d2 = E2;
        do
          d2 += 1, b3 = n2.charCodeAt(d2);
        while (b3 <= 32);
        y2 = n2.slice(E2, d2), w3 = m[m.length - 1], b3 === a && M2 ? C = y2 : w3 && w3.type === "div" ? (w3.after = y2, w3.sourceEndIndex += y2.length) : b3 === s2 || b3 === c2 || b3 === f && n2.charCodeAt(d2 + 1) !== t8 && (!W3 || W3 && W3.type === "function" && false) ? P3 = y2 : m.push({
          type: "space",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      } else if (b3 === h7 || b3 === p) {
        d2 = E2, _3 = b3 === h7 ? "'" : '"', y2 = {
          type: "string",
          sourceIndex: E2,
          quote: _3
        };
        do
          if (x = false, d2 = n2.indexOf(_3, d2 + 1), ~d2)
            for (g2 = d2; n2.charCodeAt(g2 - 1) === l2; )
              g2 -= 1, x = !x;
          else
            n2 += _3, d2 = n2.length - 1, y2.unclosed = true;
        while (x);
        y2.value = n2.slice(E2 + 1, d2), y2.sourceEndIndex = y2.unclosed ? d2 : d2 + 1, m.push(y2), E2 = d2 + 1, b3 = n2.charCodeAt(E2);
      } else if (b3 === f && n2.charCodeAt(E2 + 1) === t8)
        d2 = n2.indexOf("*/", E2), y2 = {
          type: "comment",
          sourceIndex: E2,
          sourceEndIndex: d2 + 2
        }, d2 === -1 && (y2.unclosed = true, d2 = n2.length, y2.sourceEndIndex = d2), y2.value = n2.slice(E2 + 2, d2), m.push(y2), E2 = d2 + 2, b3 = n2.charCodeAt(E2);
      else if ((b3 === f || b3 === t8) && W3 && W3.type === "function")
        y2 = n2[E2], m.push({
          type: "word",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2
        }), E2 += 1, b3 = n2.charCodeAt(E2);
      else if (b3 === f || b3 === s2 || b3 === c2)
        y2 = n2[E2], m.push({
          type: "div",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2,
          before: P3,
          after: ""
        }), P3 = "", E2 += 1, b3 = n2.charCodeAt(E2);
      else if (u === b3) {
        d2 = E2;
        do
          d2 += 1, b3 = n2.charCodeAt(d2);
        while (b3 <= 32);
        if (A = E2, y2 = {
          type: "function",
          sourceIndex: E2 - S3.length,
          value: S3,
          before: n2.slice(A + 1, d2)
        }, E2 = d2, S3 === "url" && b3 !== h7 && b3 !== p) {
          d2 -= 1;
          do
            if (x = false, d2 = n2.indexOf(")", d2 + 1), ~d2)
              for (g2 = d2; n2.charCodeAt(g2 - 1) === l2; )
                g2 -= 1, x = !x;
            else
              n2 += ")", d2 = n2.length - 1, y2.unclosed = true;
          while (x);
          O3 = d2;
          do
            O3 -= 1, b3 = n2.charCodeAt(O3);
          while (b3 <= 32);
          A < O3 ? (E2 !== O3 + 1 ? y2.nodes = [
            {
              type: "word",
              sourceIndex: E2,
              sourceEndIndex: O3 + 1,
              value: n2.slice(E2, O3 + 1)
            }
          ] : y2.nodes = [], y2.unclosed && O3 + 1 !== d2 ? (y2.after = "", y2.nodes.push({
            type: "space",
            sourceIndex: O3 + 1,
            sourceEndIndex: d2,
            value: n2.slice(O3 + 1, d2)
          })) : (y2.after = n2.slice(O3 + 1, d2), y2.sourceEndIndex = d2)) : (y2.after = "", y2.nodes = []), E2 = d2 + 1, y2.sourceEndIndex = y2.unclosed ? d2 : E2, b3 = n2.charCodeAt(E2), m.push(y2);
        } else
          M2 += 1, y2.after = "", y2.sourceEndIndex = E2 + 1, m.push(y2), q2.push(y2), m = y2.nodes = [], W3 = y2;
        S3 = "";
      } else if (a === b3 && M2)
        E2 += 1, b3 = n2.charCodeAt(E2), W3.after = C, W3.sourceEndIndex += C.length, C = "", M2 -= 1, q2[q2.length - 1].sourceEndIndex = E2, q2.pop(), W3 = q2[M2], m = W3.nodes;
      else {
        d2 = E2;
        do
          b3 === l2 && (d2 += 1), d2 += 1, b3 = n2.charCodeAt(d2);
        while (d2 < k3 && !(b3 <= 32 || b3 === h7 || b3 === p || b3 === s2 || b3 === c2 || b3 === f || b3 === u || b3 === t8 && W3 && W3.type === "function" || b3 === f && W3.type === "function" || b3 === a && M2));
        y2 = n2.slice(E2, d2), u === b3 ? S3 = y2 : (e2 === y2.charCodeAt(0) || r2 === y2.charCodeAt(0)) && i === y2.charCodeAt(1) && o2.test(y2.slice(2)) ? m.push({
          type: "unicode-range",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }) : m.push({
          type: "word",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      }
    for (E2 = q2.length - 1; E2; E2 -= 1)
      q2[E2].unclosed = true, q2[E2].sourceEndIndex = n2.length;
    return q2[0].nodes;
  }, cn3;
}
var dn3;
var ws3;
function tf() {
  return ws3 || (ws3 = 1, dn3 = function u(a, h7, p) {
    var l2, f, s2, c2;
    for (l2 = 0, f = a.length; l2 < f; l2 += 1)
      s2 = a[l2], p || (c2 = h7(s2, l2, a)), c2 !== false && s2.type === "function" && Array.isArray(s2.nodes) && u(s2.nodes, h7, p), p && h7(s2, l2, a);
  }), dn3;
}
var pn3;
var bs2;
function rf() {
  if (bs2) return pn3;
  bs2 = 1;
  function u(h7, p) {
    var l2 = h7.type, f = h7.value, s2, c2;
    return p && (c2 = p(h7)) !== void 0 ? c2 : l2 === "word" || l2 === "space" ? f : l2 === "string" ? (s2 = h7.quote || "", s2 + f + (h7.unclosed ? "" : s2)) : l2 === "comment" ? "/*" + f + (h7.unclosed ? "" : "*/") : l2 === "div" ? (h7.before || "") + f + (h7.after || "") : Array.isArray(h7.nodes) ? (s2 = a(h7.nodes, p), l2 !== "function" ? s2 : f + "(" + (h7.before || "") + s2 + (h7.after || "") + (h7.unclosed ? "" : ")")) : f;
  }
  function a(h7, p) {
    var l2, f;
    if (Array.isArray(h7)) {
      for (l2 = "", f = h7.length - 1; ~f; f -= 1)
        l2 = u(h7[f], p) + l2;
      return l2;
    }
    return u(h7, p);
  }
  return pn3 = a, pn3;
}
var hn3;
var _s2;
function nf() {
  if (_s2) return hn3;
  _s2 = 1;
  var u = 45, a = 43, h7 = 46, p = 101, l2 = 69;
  function f(s2) {
    var c2 = s2.charCodeAt(0), t8;
    if (c2 === a || c2 === u) {
      if (t8 = s2.charCodeAt(1), t8 >= 48 && t8 <= 57)
        return true;
      var e2 = s2.charCodeAt(2);
      return t8 === h7 && e2 >= 48 && e2 <= 57;
    }
    return c2 === h7 ? (t8 = s2.charCodeAt(1), t8 >= 48 && t8 <= 57) : c2 >= 48 && c2 <= 57;
  }
  return hn3 = function(s2) {
    var c2 = 0, t8 = s2.length, e2, r2, i;
    if (t8 === 0 || !f(s2))
      return false;
    for (e2 = s2.charCodeAt(c2), (e2 === a || e2 === u) && c2++; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
      c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), e2 === h7 && r2 >= 48 && r2 <= 57)
      for (c2 += 2; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), i = s2.charCodeAt(c2 + 2), (e2 === p || e2 === l2) && (r2 >= 48 && r2 <= 57 || (r2 === a || r2 === u) && i >= 48 && i <= 57))
      for (c2 += r2 === a || r2 === u ? 3 : 2; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    return {
      number: s2.slice(0, c2),
      unit: s2.slice(c2)
    };
  }, hn3;
}
var vn3;
var Ss2;
function af() {
  if (Ss2) return vn3;
  Ss2 = 1;
  var u = ef(), a = tf(), h7 = rf();
  function p(l2) {
    return this instanceof p ? (this.nodes = u(l2), this) : new p(l2);
  }
  return p.prototype.toString = function() {
    return Array.isArray(this.nodes) ? h7(this.nodes) : "";
  }, p.prototype.walk = function(l2, f) {
    return a(this.nodes, l2, f), this;
  }, p.unit = nf(), p.walk = a, p.stringify = h7, vn3 = p, vn3;
}
var gn3 = {};
var xs2;
function Ui2() {
  return xs2 || (xs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(c2, t8) {
      for (var e2 in t8) Object.defineProperty(c2, e2, {
        enumerable: true,
        get: t8[e2]
      });
    }
    a(u, {
      normalizeScreens: function() {
        return h7;
      },
      isScreenSortable: function() {
        return p;
      },
      compareScreens: function() {
        return l2;
      },
      toScreen: function() {
        return f;
      }
    });
    function h7(c2, t8 = true) {
      return Array.isArray(c2) ? c2.map((e2) => {
        if (t8 && Array.isArray(e2))
          throw new Error("The tuple syntax is not supported for `screens`.");
        if (typeof e2 == "string")
          return {
            name: e2.toString(),
            not: false,
            values: [
              {
                min: e2,
                max: void 0
              }
            ]
          };
        let [r2, i] = e2;
        return r2 = r2.toString(), typeof i == "string" ? {
          name: r2,
          not: false,
          values: [
            {
              min: i,
              max: void 0
            }
          ]
        } : Array.isArray(i) ? {
          name: r2,
          not: false,
          values: i.map((o2) => s2(o2))
        } : {
          name: r2,
          not: false,
          values: [
            s2(i)
          ]
        };
      }) : h7(Object.entries(c2 ?? {}), false);
    }
    function p(c2) {
      return c2.values.length !== 1 ? {
        result: false,
        reason: "multiple-values"
      } : c2.values[0].raw !== void 0 ? {
        result: false,
        reason: "raw-values"
      } : c2.values[0].min !== void 0 && c2.values[0].max !== void 0 ? {
        result: false,
        reason: "min-and-max"
      } : {
        result: true,
        reason: null
      };
    }
    function l2(c2, t8, e2) {
      let r2 = f(t8, c2), i = f(e2, c2), o2 = p(r2), v3 = p(i);
      if (o2.reason === "multiple-values" || v3.reason === "multiple-values")
        throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
      if (o2.reason === "raw-values" || v3.reason === "raw-values")
        throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
      if (o2.reason === "min-and-max" || v3.reason === "min-and-max")
        throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
      let { min: m, max: n2 } = r2.values[0], { min: d2, max: _3 } = i.values[0];
      t8.not && ([m, n2] = [
        n2,
        m
      ]), e2.not && ([d2, _3] = [
        _3,
        d2
      ]), m = m === void 0 ? m : parseFloat(m), n2 = n2 === void 0 ? n2 : parseFloat(n2), d2 = d2 === void 0 ? d2 : parseFloat(d2), _3 = _3 === void 0 ? _3 : parseFloat(_3);
      let [w3, y2] = c2 === "min" ? [
        m,
        d2
      ] : [
        _3,
        n2
      ];
      return w3 - y2;
    }
    function f(c2, t8) {
      return typeof c2 == "object" ? c2 : {
        name: "arbitrary-screen",
        values: [
          {
            [t8]: c2
          }
        ]
      };
    }
    function s2({ "min-width": c2, min: t8 = c2, max: e2, raw: r2 } = {}) {
      return {
        min: t8,
        max: e2,
        raw: r2
      };
    }
  }(gn3)), gn3;
}
var mn3 = {};
var Os2;
function zi2() {
  return Os2 || (Os2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      return h7 = Array.isArray(h7) ? h7 : [
        h7
      ], h7.map((p) => {
        let l2 = p.values.map((f) => f.raw !== void 0 ? f.raw : [
          f.min && `(min-width: ${f.min})`,
          f.max && `(max-width: ${f.max})`
        ].filter(Boolean).join(" and "));
        return p.not ? `not all and ${l2}` : l2;
      }).join(", ");
    }
  }(mn3)), mn3;
}
var yn3 = {};
var ks2;
function Wi2() {
  return ks2 || (ks2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "toPath", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      if (Array.isArray(h7)) return h7;
      let p = h7.split("[").length - 1, l2 = h7.split("]").length - 1;
      if (p !== l2)
        throw new Error(`Path is invalid. Has unbalanced brackets: ${h7}`);
      return h7.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
    }
  }(yn3)), yn3;
}
var wn3 = {};
var bn3 = {};
var _n3 = {};
var Ps2;
function sf() {
  return Ps2 || (Ps2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
  }(_n3)), _n3;
}
var Es2;
function Fl() {
  return Es2 || (Es2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(m, n2) {
      for (var d2 in n2) Object.defineProperty(m, d2, {
        enumerable: true,
        get: n2[d2]
      });
    }
    a(u, {
      parseColor: function() {
        return o2;
      },
      formatColor: function() {
        return v3;
      }
    });
    const h7 = p(sf());
    function p(m) {
      return m && m.__esModule ? m : {
        default: m
      };
    }
    let l2 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, f = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, s2 = /(?:\d+|\d*\.\d+)%?/, c2 = /(?:\s*,\s*|\s+)/, t8 = /\s*[,/]\s*/, e2 = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, r2 = new RegExp(`^(rgba?)\\(\\s*(${s2.source}|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t8.source}(${s2.source}|${e2.source}))?\\s*\\)$`), i = new RegExp(`^(hsla?)\\(\\s*((?:${s2.source})(?:deg|rad|grad|turn)?|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t8.source}(${s2.source}|${e2.source}))?\\s*\\)$`);
    function o2(m, { loose: n2 = false } = {}) {
      var d2, _3;
      if (typeof m != "string")
        return null;
      if (m = m.trim(), m === "transparent")
        return {
          mode: "rgb",
          color: [
            "0",
            "0",
            "0"
          ],
          alpha: "0"
        };
      if (m in h7.default)
        return {
          mode: "rgb",
          color: h7.default[m].map((O3) => O3.toString())
        };
      let w3 = m.replace(f, (O3, A, E2, b3, k3) => [
        "#",
        A,
        A,
        E2,
        E2,
        b3,
        b3,
        k3 ? k3 + k3 : ""
      ].join("")).match(l2);
      if (w3 !== null)
        return {
          mode: "rgb",
          color: [
            parseInt(w3[1], 16),
            parseInt(w3[2], 16),
            parseInt(w3[3], 16)
          ].map((O3) => O3.toString()),
          alpha: w3[4] ? (parseInt(w3[4], 16) / 255).toString() : void 0
        };
      var y2;
      let x = (y2 = m.match(r2)) !== null && y2 !== void 0 ? y2 : m.match(i);
      if (x === null)
        return null;
      let g2 = [
        x[2],
        x[3],
        x[4]
      ].filter(Boolean).map((O3) => O3.toString());
      return g2.length === 2 && g2[0].startsWith("var(") ? {
        mode: x[1],
        color: [
          g2[0]
        ],
        alpha: g2[1]
      } : !n2 && g2.length !== 3 || g2.length < 3 && !g2.some((O3) => /^var\(.*?\)$/.test(O3)) ? null : {
        mode: x[1],
        color: g2,
        alpha: (d2 = x[5]) === null || d2 === void 0 || (_3 = d2.toString) === null || _3 === void 0 ? void 0 : _3.call(d2)
      };
    }
    function v3({ mode: m, color: n2, alpha: d2 }) {
      let _3 = d2 !== void 0;
      return m === "rgba" || m === "hsla" ? `${m}(${n2.join(", ")}${_3 ? `, ${d2}` : ""})` : `${m}(${n2.join(" ")}${_3 ? ` / ${d2}` : ""})`;
    }
  }(bn3)), bn3;
}
var Ts2;
function hr3() {
  return Ts2 || (Ts2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(f, s2) {
      for (var c2 in s2) Object.defineProperty(f, c2, {
        enumerable: true,
        get: s2[c2]
      });
    }
    a(u, {
      withAlphaValue: function() {
        return p;
      },
      default: function() {
        return l2;
      }
    });
    const h7 = Fl();
    function p(f, s2, c2) {
      if (typeof f == "function")
        return f({
          opacityValue: s2
        });
      let t8 = (0, h7.parseColor)(f, {
        loose: true
      });
      return t8 === null ? c2 : (0, h7.formatColor)({
        ...t8,
        alpha: s2
      });
    }
    function l2({ color: f, property: s2, variable: c2 }) {
      let t8 = [].concat(s2);
      if (typeof f == "function")
        return {
          [c2]: "1",
          ...Object.fromEntries(t8.map((r2) => [
            r2,
            f({
              opacityVariable: c2,
              opacityValue: `var(${c2})`
            })
          ]))
        };
      const e2 = (0, h7.parseColor)(f);
      return e2 === null ? Object.fromEntries(t8.map((r2) => [
        r2,
        f
      ])) : e2.alpha !== void 0 ? Object.fromEntries(t8.map((r2) => [
        r2,
        f
      ])) : {
        [c2]: "1",
        ...Object.fromEntries(t8.map((r2) => [
          r2,
          (0, h7.formatColor)({
            ...e2,
            alpha: `var(${c2})`
          })
        ]))
      };
    }
  }(wn3)), wn3;
}
var Sn3 = {};
var xn3 = {};
var As2;
function Vi2() {
  return As2 || (As2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      return h7.replace(/\\,/g, "\\2c ");
    }
  }(xn3)), xn3;
}
var On2 = {};
var kn3 = {};
var Pn3 = {};
var Cs2;
function st3() {
  return Cs2 || (Cs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "splitAtTopLevelOnly", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7, p) {
      let l2 = [], f = [], s2 = 0, c2 = false;
      for (let t8 = 0; t8 < h7.length; t8++) {
        let e2 = h7[t8];
        l2.length === 0 && e2 === p[0] && !c2 && (p.length === 1 || h7.slice(t8, t8 + p.length) === p) && (f.push(h7.slice(s2, t8)), s2 = t8 + p.length), c2 = c2 ? false : e2 === "\\", e2 === "(" || e2 === "[" || e2 === "{" ? l2.push(e2) : (e2 === ")" && l2[l2.length - 1] === "(" || e2 === "]" && l2[l2.length - 1] === "[" || e2 === "}" && l2[l2.length - 1] === "{") && l2.pop();
      }
      return f.push(h7.slice(s2)), f;
    }
  }(Pn3)), Pn3;
}
var Rs2;
function $l() {
  return Rs2 || (Rs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      parseBoxShadowValue: function() {
        return s2;
      },
      formatBoxShadowValue: function() {
        return c2;
      }
    });
    const h7 = st3();
    let p = /* @__PURE__ */ new Set([
      "inset",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]), l2 = /\ +(?![^(]*\))/g, f = /^-?(\d+|\.\d+)(.*?)$/g;
    function s2(t8) {
      return (0, h7.splitAtTopLevelOnly)(t8, ",").map((r2) => {
        let i = r2.trim(), o2 = {
          raw: i
        }, v3 = i.split(l2), m = /* @__PURE__ */ new Set();
        for (let n2 of v3)
          f.lastIndex = 0, !m.has("KEYWORD") && p.has(n2) ? (o2.keyword = n2, m.add("KEYWORD")) : f.test(n2) ? m.has("X") ? m.has("Y") ? m.has("BLUR") ? m.has("SPREAD") || (o2.spread = n2, m.add("SPREAD")) : (o2.blur = n2, m.add("BLUR")) : (o2.y = n2, m.add("Y")) : (o2.x = n2, m.add("X")) : o2.color ? (o2.unknown || (o2.unknown = []), o2.unknown.push(n2)) : o2.color = n2;
        return o2.valid = o2.x !== void 0 && o2.y !== void 0, o2;
      });
    }
    function c2(t8) {
      return t8.map((e2) => e2.valid ? [
        e2.keyword,
        e2.x,
        e2.y,
        e2.blur,
        e2.spread,
        e2.color
      ].filter(Boolean).join(" ") : e2.raw).join(", ");
    }
  }(kn3)), kn3;
}
var Is2;
function vr3() {
  return Is2 || (Is2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(R3, $2) {
      for (var B3 in $2) Object.defineProperty(R3, B3, {
        enumerable: true,
        get: $2[B3]
      });
    }
    a(u, {
      normalize: function() {
        return t8;
      },
      normalizeAttributeSelectors: function() {
        return e2;
      },
      url: function() {
        return i;
      },
      number: function() {
        return o2;
      },
      percentage: function() {
        return v3;
      },
      length: function() {
        return d2;
      },
      lineWidth: function() {
        return w3;
      },
      shadow: function() {
        return y2;
      },
      color: function() {
        return x;
      },
      image: function() {
        return g2;
      },
      gradient: function() {
        return A;
      },
      position: function() {
        return b3;
      },
      familyName: function() {
        return k3;
      },
      genericName: function() {
        return M2;
      },
      absoluteSize: function() {
        return S3;
      },
      relativeSize: function() {
        return C;
      }
    });
    const h7 = Fl(), p = $l(), l2 = st3();
    let f = [
      "min",
      "max",
      "clamp",
      "calc"
    ];
    function s2(R3) {
      return f.some(($2) => new RegExp(`^${$2}\\(.*\\)`).test(R3));
    }
    const c2 = /* @__PURE__ */ new Set([
      // Concrete properties
      "scroll-timeline-name",
      "timeline-scope",
      "view-timeline-name",
      "font-palette",
      "anchor-name",
      "anchor-scope",
      "position-anchor",
      "position-try-options",
      // Shorthand properties
      "scroll-timeline",
      "animation-timeline",
      "view-timeline",
      "position-try"
    ]);
    function t8(R3, $2 = null, B3 = true) {
      let z3 = $2 && c2.has($2.property);
      return R3.startsWith("--") && !z3 ? `var(${R3})` : R3.includes("url(") ? R3.split(/(url\(.*?\))/g).filter(Boolean).map((L3) => /^url\(.*?\)$/.test(L3) ? L3 : t8(L3, $2, false)).join("") : (R3 = R3.replace(/([^\\])_+/g, (L3, F) => F + " ".repeat(L3.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), B3 && (R3 = R3.trim()), R3 = r2(R3), R3);
    }
    function e2(R3) {
      return R3.includes("=") && (R3 = R3.replace(/(=.*)/g, ($2, B3) => {
        if (B3[1] === "'" || B3[1] === '"')
          return B3;
        if (B3.length > 2) {
          let z3 = B3[B3.length - 1];
          if (B3[B3.length - 2] === " " && (z3 === "i" || z3 === "I" || z3 === "s" || z3 === "S"))
            return `="${B3.slice(1, -2)}" ${B3[B3.length - 1]}`;
        }
        return `="${B3.slice(1)}"`;
      })), R3;
    }
    function r2(R3) {
      let $2 = [
        "theme"
      ], B3 = [
        "min-content",
        "max-content",
        "fit-content",
        // Env
        "safe-area-inset-top",
        "safe-area-inset-right",
        "safe-area-inset-bottom",
        "safe-area-inset-left",
        "titlebar-area-x",
        "titlebar-area-y",
        "titlebar-area-width",
        "titlebar-area-height",
        "keyboard-inset-top",
        "keyboard-inset-right",
        "keyboard-inset-bottom",
        "keyboard-inset-left",
        "keyboard-inset-width",
        "keyboard-inset-height",
        "radial-gradient",
        "linear-gradient",
        "conic-gradient",
        "repeating-radial-gradient",
        "repeating-linear-gradient",
        "repeating-conic-gradient"
      ];
      return R3.replace(/(calc|min|max|clamp)\(.+\)/g, (z3) => {
        let L3 = "";
        function F() {
          let D = L3.trimEnd();
          return D[D.length - 1];
        }
        for (let D = 0; D < z3.length; D++) {
          let I3 = function(T3) {
            return T3.split("").every((U2, j3) => z3[D + j3] === U2);
          }, N3 = function(T3) {
            let U2 = 1 / 0;
            for (let H3 of T3) {
              let V4 = z3.indexOf(H3, D);
              V4 !== -1 && V4 < U2 && (U2 = V4);
            }
            let j3 = z3.slice(D, U2);
            return D += j3.length - 1, j3;
          }, J3 = z3[D];
          if (I3("var"))
            L3 += N3([
              ")",
              ","
            ]);
          else if (B3.some((T3) => I3(T3))) {
            let T3 = B3.find((U2) => I3(U2));
            L3 += T3, D += T3.length - 1;
          } else $2.some((T3) => I3(T3)) ? L3 += N3([
            ")"
          ]) : I3("[") ? L3 += N3([
            "]"
          ]) : [
            "+",
            "-",
            "*",
            "/"
          ].includes(J3) && ![
            "(",
            "+",
            "-",
            "*",
            "/",
            ","
          ].includes(F()) ? L3 += ` ${J3} ` : L3 += J3;
        }
        return L3.replace(/\s+/g, " ");
      });
    }
    function i(R3) {
      return R3.startsWith("url(");
    }
    function o2(R3) {
      return !isNaN(Number(R3)) || s2(R3);
    }
    function v3(R3) {
      return R3.endsWith("%") && o2(R3.slice(0, -1)) || s2(R3);
    }
    let n2 = `(?:${[
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px",
      "em",
      "ex",
      "ch",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vmin",
      "vmax",
      "vb",
      "vi",
      "svw",
      "svh",
      "lvw",
      "lvh",
      "dvw",
      "dvh",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ].join("|")})`;
    function d2(R3) {
      return R3 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${n2}$`).test(R3) || s2(R3);
    }
    let _3 = /* @__PURE__ */ new Set([
      "thin",
      "medium",
      "thick"
    ]);
    function w3(R3) {
      return _3.has(R3);
    }
    function y2(R3) {
      let $2 = (0, p.parseBoxShadowValue)(t8(R3));
      for (let B3 of $2)
        if (!B3.valid)
          return false;
      return true;
    }
    function x(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : (0, h7.parseColor)(z3, {
        loose: true
      }) !== null ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    function g2(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : i(z3) || A(z3) || [
        "element(",
        "image(",
        "cross-fade(",
        "image-set("
      ].some((L3) => z3.startsWith(L3)) ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    let O3 = /* @__PURE__ */ new Set([
      "conic-gradient",
      "linear-gradient",
      "radial-gradient",
      "repeating-conic-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient"
    ]);
    function A(R3) {
      R3 = t8(R3);
      for (let $2 of O3)
        if (R3.startsWith(`${$2}(`))
          return true;
      return false;
    }
    let E2 = /* @__PURE__ */ new Set([
      "center",
      "top",
      "right",
      "bottom",
      "left"
    ]);
    function b3(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : E2.has(z3) || d2(z3) || v3(z3) ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    function k3(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : z3.includes(" ") && !/(['"])([^"']+)\1/g.test(z3) || /^\d/g.test(z3) ? false : ($2++, true))) ? $2 > 0 : false;
    }
    let q2 = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "math",
      "emoji",
      "fangsong"
    ]);
    function M2(R3) {
      return q2.has(R3);
    }
    let W3 = /* @__PURE__ */ new Set([
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large"
    ]);
    function S3(R3) {
      return W3.has(R3);
    }
    let P3 = /* @__PURE__ */ new Set([
      "larger",
      "smaller"
    ]);
    function C(R3) {
      return P3.has(R3);
    }
  }(On2)), On2;
}
var En3 = {};
var Ms2;
function ji2() {
  return Ms2 || (Ms2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      if (h7 = `${h7}`, h7 === "0")
        return "0";
      if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(h7))
        return h7.replace(/^[+-]?/, (l2) => l2 === "-" ? "" : "-");
      let p = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
      ];
      for (const l2 of p)
        if (h7.includes(`${l2}(`))
          return `calc(${h7} * -1)`;
    }
  }(En3)), En3;
}
var Tn3 = {};
var Ds2;
function of() {
  return Ds2 || (Ds2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "backgroundSize", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = vr3(), h7 = st3();
    function p(l2) {
      let f = [
        "cover",
        "contain"
      ];
      return (0, h7.splitAtTopLevelOnly)(l2, ",").every((s2) => {
        let c2 = (0, h7.splitAtTopLevelOnly)(s2, "_").filter(Boolean);
        return c2.length === 1 && f.includes(c2[0]) ? true : c2.length !== 1 && c2.length !== 2 ? false : c2.every((t8) => (0, a.length)(t8) || (0, a.percentage)(t8) || t8 === "auto");
      });
    }
  }(Tn3)), Tn3;
}
var An3 = {};
var Cn3 = {};
var qs2;
function tt3() {
  return qs2 || (qs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      dim: function() {
        return s2;
      },
      default: function() {
        return c2;
      }
    });
    const h7 = p(Ti());
    function p(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    let l2 = /* @__PURE__ */ new Set();
    function f(t8, e2, r2) {
      typeof process < "u" && process.env.JEST_WORKER_ID || r2 && l2.has(r2) || (r2 && l2.add(r2), console.warn(""), e2.forEach((i) => console.warn(t8, "-", i)));
    }
    function s2(t8) {
      return h7.default.dim(t8);
    }
    const c2 = {
      info(t8, e2) {
        f(h7.default.bold(h7.default.cyan("info")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      },
      warn(t8, e2) {
        f(h7.default.bold(h7.default.yellow("warn")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      },
      risk(t8, e2) {
        f(h7.default.bold(h7.default.magenta("risk")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      }
    };
  }(Cn3)), Cn3;
}
var Ls2;
function it3() {
  return Ls2 || (Ls2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(i, o2) {
      for (var v3 in o2) Object.defineProperty(i, v3, {
        enumerable: true,
        get: o2[v3]
      });
    }
    a(u, {
      flagEnabled: function() {
        return c2;
      },
      issueFlagNotices: function() {
        return e2;
      },
      default: function() {
        return r2;
      }
    });
    const h7 = l2(Ti()), p = l2(tt3());
    function l2(i) {
      return i && i.__esModule ? i : {
        default: i
      };
    }
    let f = {
      optimizeUniversalDefaults: false,
      generalizedModifiers: true,
      disableColorOpacityUtilitiesByDefault: false,
      relativeContentPathsByDefault: false
    }, s2 = {
      future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
      ],
      experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
      ]
    };
    function c2(i, o2) {
      if (s2.future.includes(o2)) {
        var v3, m, n2;
        return i.future === "all" || ((n2 = (m = i == null || (v3 = i.future) === null || v3 === void 0 ? void 0 : v3[o2]) !== null && m !== void 0 ? m : f[o2]) !== null && n2 !== void 0 ? n2 : false);
      }
      if (s2.experimental.includes(o2)) {
        var d2, _3, w3;
        return i.experimental === "all" || ((w3 = (_3 = i == null || (d2 = i.experimental) === null || d2 === void 0 ? void 0 : d2[o2]) !== null && _3 !== void 0 ? _3 : f[o2]) !== null && w3 !== void 0 ? w3 : false);
      }
      return false;
    }
    function t8(i) {
      if (i.experimental === "all")
        return s2.experimental;
      var o2;
      return Object.keys((o2 = i == null ? void 0 : i.experimental) !== null && o2 !== void 0 ? o2 : {}).filter((v3) => s2.experimental.includes(v3) && i.experimental[v3]);
    }
    function e2(i) {
      if (process.env.JEST_WORKER_ID === void 0 && t8(i).length > 0) {
        let o2 = t8(i).map((v3) => h7.default.yellow(v3)).join(", ");
        p.default.warn("experimental-flags-enabled", [
          `You have enabled experimental features: ${o2}`,
          "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
      }
    }
    const r2 = s2;
  }(An3)), An3;
}
var Ns2;
function gr3() {
  return Ns2 || (Ns2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(b3, k3) {
      for (var q2 in k3) Object.defineProperty(b3, q2, {
        enumerable: true,
        get: k3[q2]
      });
    }
    a(u, {
      updateAllClasses: function() {
        return e2;
      },
      asValue: function() {
        return o2;
      },
      parseColorFormat: function() {
        return n2;
      },
      asColor: function() {
        return _3;
      },
      asLookupValue: function() {
        return w3;
      },
      typeMap: function() {
        return x;
      },
      coerceValue: function() {
        return A;
      },
      getMatchingTypes: function() {
        return E2;
      }
    });
    const h7 = t8(Vi2()), p = hr3(), l2 = vr3(), f = t8(ji2()), s2 = of(), c2 = it3();
    function t8(b3) {
      return b3 && b3.__esModule ? b3 : {
        default: b3
      };
    }
    function e2(b3, k3) {
      b3.walkClasses((q2) => {
        q2.value = k3(q2.value), q2.raws && q2.raws.value && (q2.raws.value = (0, h7.default)(q2.raws.value));
      });
    }
    function r2(b3, k3) {
      if (!v3(b3))
        return;
      let q2 = b3.slice(1, -1);
      if (k3(q2))
        return (0, l2.normalize)(q2);
    }
    function i(b3, k3 = {}, q2) {
      let M2 = k3[b3];
      if (M2 !== void 0)
        return (0, f.default)(M2);
      if (v3(b3)) {
        let W3 = r2(b3, q2);
        return W3 === void 0 ? void 0 : (0, f.default)(W3);
      }
    }
    function o2(b3, k3 = {}, { validate: q2 = () => true } = {}) {
      var M2;
      let W3 = (M2 = k3.values) === null || M2 === void 0 ? void 0 : M2[b3];
      return W3 !== void 0 ? W3 : k3.supportsNegativeValues && b3.startsWith("-") ? i(b3.slice(1), k3.values, q2) : r2(b3, q2);
    }
    function v3(b3) {
      return b3.startsWith("[") && b3.endsWith("]");
    }
    function m(b3) {
      let k3 = b3.lastIndexOf("/"), q2 = b3.lastIndexOf("[", k3), M2 = b3.indexOf("]", k3);
      return b3[k3 - 1] === "]" || b3[k3 + 1] === "[" || q2 !== -1 && M2 !== -1 && q2 < k3 && k3 < M2 && (k3 = b3.lastIndexOf("/", q2)), k3 === -1 || k3 === b3.length - 1 ? [
        b3,
        void 0
      ] : v3(b3) && !b3.includes("]/[") ? [
        b3,
        void 0
      ] : [
        b3.slice(0, k3),
        b3.slice(k3 + 1)
      ];
    }
    function n2(b3) {
      if (typeof b3 == "string" && b3.includes("<alpha-value>")) {
        let k3 = b3;
        return ({ opacityValue: q2 = 1 }) => k3.replace(/<alpha-value>/g, q2);
      }
      return b3;
    }
    function d2(b3) {
      return (0, l2.normalize)(b3.slice(1, -1));
    }
    function _3(b3, k3 = {}, { tailwindConfig: q2 = {} } = {}) {
      var M2;
      if (((M2 = k3.values) === null || M2 === void 0 ? void 0 : M2[b3]) !== void 0) {
        var W3;
        return n2((W3 = k3.values) === null || W3 === void 0 ? void 0 : W3[b3]);
      }
      let [S3, P3] = m(b3);
      if (P3 !== void 0) {
        var C, R3, $2, B3;
        let z3 = (B3 = (C = k3.values) === null || C === void 0 ? void 0 : C[S3]) !== null && B3 !== void 0 ? B3 : v3(S3) ? S3.slice(1, -1) : void 0;
        return z3 === void 0 ? void 0 : (z3 = n2(z3), v3(P3) ? (0, p.withAlphaValue)(z3, d2(P3)) : ((R3 = q2.theme) === null || R3 === void 0 || ($2 = R3.opacity) === null || $2 === void 0 ? void 0 : $2[P3]) === void 0 ? void 0 : (0, p.withAlphaValue)(z3, q2.theme.opacity[P3]));
      }
      return o2(b3, k3, {
        validate: l2.color
      });
    }
    function w3(b3, k3 = {}) {
      var q2;
      return (q2 = k3.values) === null || q2 === void 0 ? void 0 : q2[b3];
    }
    function y2(b3) {
      return (k3, q2) => o2(k3, q2, {
        validate: b3
      });
    }
    let x = {
      any: o2,
      color: _3,
      url: y2(l2.url),
      image: y2(l2.image),
      length: y2(l2.length),
      percentage: y2(l2.percentage),
      position: y2(l2.position),
      lookup: w3,
      "generic-name": y2(l2.genericName),
      "family-name": y2(l2.familyName),
      number: y2(l2.number),
      "line-width": y2(l2.lineWidth),
      "absolute-size": y2(l2.absoluteSize),
      "relative-size": y2(l2.relativeSize),
      shadow: y2(l2.shadow),
      size: y2(s2.backgroundSize)
    }, g2 = Object.keys(x);
    function O3(b3, k3) {
      let q2 = b3.indexOf(k3);
      return q2 === -1 ? [
        void 0,
        b3
      ] : [
        b3.slice(0, q2),
        b3.slice(q2 + 1)
      ];
    }
    function A(b3, k3, q2, M2) {
      if (q2.values && k3 in q2.values)
        for (let { type: S3 } of b3 ?? []) {
          let P3 = x[S3](k3, q2, {
            tailwindConfig: M2
          });
          if (P3 !== void 0)
            return [
              P3,
              S3,
              null
            ];
        }
      if (v3(k3)) {
        let S3 = k3.slice(1, -1), [P3, C] = O3(S3, ":");
        if (!/^[\w-_]+$/g.test(P3))
          C = S3;
        else if (P3 !== void 0 && !g2.includes(P3))
          return [];
        if (C.length > 0 && g2.includes(P3))
          return [
            o2(`[${C}]`, q2),
            P3,
            null
          ];
      }
      let W3 = E2(b3, k3, q2, M2);
      for (let S3 of W3)
        return S3;
      return [];
    }
    function* E2(b3, k3, q2, M2) {
      let W3 = (0, c2.flagEnabled)(M2, "generalizedModifiers"), [S3, P3] = m(k3);
      if (W3 && q2.modifiers != null && (q2.modifiers === "any" || typeof q2.modifiers == "object" && (P3 && v3(P3) || P3 in q2.modifiers)) || (S3 = k3, P3 = void 0), P3 !== void 0 && S3 === "" && (S3 = "DEFAULT"), P3 !== void 0 && typeof q2.modifiers == "object") {
        var R3, $2;
        let B3 = ($2 = (R3 = q2.modifiers) === null || R3 === void 0 ? void 0 : R3[P3]) !== null && $2 !== void 0 ? $2 : null;
        B3 !== null ? P3 = B3 : v3(P3) && (P3 = d2(P3));
      }
      for (let { type: B3 } of b3 ?? []) {
        let z3 = x[B3](S3, q2, {
          tailwindConfig: M2
        });
        z3 !== void 0 && (yield [
          z3,
          B3,
          P3 ?? null
        ]);
      }
    }
  }(Sn3)), Sn3;
}
var Fs2;
function lf() {
  return Fs2 || (Fs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return E2;
      }
    });
    const a = i(Nl()), h7 = i(Zu2()), p = i(pr3()), l2 = i(af()), f = Ui2(), s2 = i(zi2()), c2 = Wi2(), t8 = hr3(), e2 = gr3(), r2 = i(tt3());
    function i(b3) {
      return b3 && b3.__esModule ? b3 : {
        default: b3
      };
    }
    function o2(b3) {
      return typeof b3 == "object" && b3 !== null;
    }
    function v3(b3, k3) {
      let q2 = (0, c2.toPath)(k3);
      do
        if (q2.pop(), (0, a.default)(b3, q2) !== void 0) break;
      while (q2.length);
      return q2.length ? q2 : void 0;
    }
    function m(b3) {
      return typeof b3 == "string" ? b3 : b3.reduce((k3, q2, M2) => q2.includes(".") ? `${k3}[${q2}]` : M2 === 0 ? q2 : `${k3}.${q2}`, "");
    }
    function n2(b3) {
      return b3.map((k3) => `'${k3}'`).join(", ");
    }
    function d2(b3) {
      return n2(Object.keys(b3));
    }
    function _3(b3, k3, q2, M2 = {}) {
      const W3 = Array.isArray(k3) ? m(k3) : k3.replace(/^['"]+|['"]+$/g, ""), S3 = Array.isArray(k3) ? k3 : (0, c2.toPath)(W3), P3 = (0, a.default)(b3.theme, S3, q2);
      if (P3 === void 0) {
        let R3 = `'${W3}' does not exist in your theme config.`;
        const $2 = S3.slice(0, -1), B3 = (0, a.default)(b3.theme, $2);
        if (o2(B3)) {
          const z3 = Object.keys(B3).filter((F) => _3(b3, [
            ...$2,
            F
          ]).isValid), L3 = (0, h7.default)(S3[S3.length - 1], z3);
          L3 ? R3 += ` Did you mean '${m([
            ...$2,
            L3
          ])}'?` : z3.length > 0 && (R3 += ` '${m($2)}' has the following valid keys: ${n2(z3)}`);
        } else {
          const z3 = v3(b3.theme, W3);
          if (z3) {
            const L3 = (0, a.default)(b3.theme, z3);
            o2(L3) ? R3 += ` '${m(z3)}' has the following keys: ${d2(L3)}` : R3 += ` '${m(z3)}' is not an object.`;
          } else
            R3 += ` Your theme has the following top-level keys: ${d2(b3.theme)}`;
        }
        return {
          isValid: false,
          error: R3
        };
      }
      if (!(typeof P3 == "string" || typeof P3 == "number" || typeof P3 == "function" || P3 instanceof String || P3 instanceof Number || Array.isArray(P3))) {
        let R3 = `'${W3}' was found but does not resolve to a string.`;
        if (o2(P3)) {
          let $2 = Object.keys(P3).filter((B3) => _3(b3, [
            ...S3,
            B3
          ]).isValid);
          $2.length && (R3 += ` Did you mean something like '${m([
            ...S3,
            $2[0]
          ])}'?`);
        }
        return {
          isValid: false,
          error: R3
        };
      }
      const [C] = S3;
      return {
        isValid: true,
        value: (0, p.default)(C)(P3, M2)
      };
    }
    function w3(b3, k3, q2) {
      k3 = k3.map((W3) => y2(b3, W3, q2));
      let M2 = [
        ""
      ];
      for (let W3 of k3)
        W3.type === "div" && W3.value === "," ? M2.push("") : M2[M2.length - 1] += l2.default.stringify(W3);
      return M2;
    }
    function y2(b3, k3, q2) {
      if (k3.type === "function" && q2[k3.value] !== void 0) {
        let M2 = w3(b3, k3.nodes, q2);
        k3.type = "word", k3.value = q2[k3.value](b3, ...M2);
      }
      return k3;
    }
    function x(b3, k3, q2) {
      return Object.keys(q2).some((W3) => k3.includes(`${W3}(`)) ? (0, l2.default)(k3).walk((W3) => {
        y2(b3, W3, q2);
      }).toString() : k3;
    }
    let g2 = {
      atrule: "params",
      decl: "value"
    };
    function* O3(b3) {
      b3 = b3.replace(/^['"]+|['"]+$/g, "");
      let k3 = b3.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), q2;
      yield [
        b3,
        void 0
      ], k3 && (b3 = k3[1], q2 = k3[2], yield [
        b3,
        q2
      ]);
    }
    function A(b3, k3, q2) {
      const M2 = Array.from(O3(k3)).map(([S3, P3]) => Object.assign(_3(b3, S3, q2, {
        opacityValue: P3
      }), {
        resolvedPath: S3,
        alpha: P3
      }));
      var W3;
      return (W3 = M2.find((S3) => S3.isValid)) !== null && W3 !== void 0 ? W3 : M2[0];
    }
    function E2(b3) {
      let k3 = b3.tailwindConfig, q2 = {
        theme: (M2, W3, ...S3) => {
          let { isValid: P3, value: C, error: R3, alpha: $2 } = A(k3, W3, S3.length ? S3 : void 0);
          if (!P3) {
            var B3;
            let F = M2.parent, D = (B3 = F == null ? void 0 : F.raws.tailwind) === null || B3 === void 0 ? void 0 : B3.candidate;
            if (F && D !== void 0) {
              b3.markInvalidUtilityNode(F), F.remove(), r2.default.warn("invalid-theme-key-in-class", [
                `The utility \`${D}\` contains an invalid theme value and was not generated.`
              ]);
              return;
            }
            throw M2.error(R3);
          }
          let z3 = (0, e2.parseColorFormat)(C);
          return ($2 !== void 0 || z3 !== void 0 && typeof z3 == "function") && ($2 === void 0 && ($2 = 1), C = (0, t8.withAlphaValue)(z3, $2, z3)), C;
        },
        screen: (M2, W3) => {
          W3 = W3.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
          let P3 = (0, f.normalizeScreens)(k3.theme.screens).find(({ name: C }) => C === W3);
          if (!P3)
            throw M2.error(`The '${W3}' screen does not exist in your theme.`);
          return (0, s2.default)(P3);
        }
      };
      return (M2) => {
        M2.walk((W3) => {
          let S3 = g2[W3.type];
          S3 !== void 0 && (W3[S3] = x(W3, W3[S3], q2));
        });
      };
    }
  }(sn2)), sn2;
}
var uf = lf();
var ff = He3(uf);
var Rn3 = {};
var Nt3 = { exports: {} };
var Ft2 = { exports: {} };
var $t3 = { exports: {} };
var Ut3 = { exports: {} };
var zt3 = { exports: {} };
var Wt3 = { exports: {} };
var Qe3 = {};
var Vt3 = { exports: {} };
var $s;
function Bi2() {
  return $s || ($s = 1, function(u, a) {
    a.__esModule = true, a.default = l2;
    function h7(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t8 = false, e2 = 0; e2 < 6 && s2[e2] !== void 0; e2++) {
        var r2 = s2.charCodeAt(e2), i = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t8 = r2 === 32, !i)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["�", c2.length + (t8 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t8 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l2(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t8 = 0; t8 < f.length; t8++) {
        if (f[t8] === "\\") {
          var e2 = h7(f.slice(t8 + 1, t8 + 7));
          if (e2 !== void 0) {
            c2 += e2[0], t8 += e2[1];
            continue;
          }
          if (f[t8 + 1] === "\\") {
            c2 += "\\", t8++;
            continue;
          }
          f.length === t8 + 1 && (c2 += f[t8]);
          continue;
        }
        c2 += f[t8];
      }
      return c2;
    }
    u.exports = a.default;
  }(Vt3, Vt3.exports)), Vt3.exports;
}
var jt3 = { exports: {} };
var Us2;
function cf() {
  return Us2 || (Us2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  }(jt3, jt3.exports)), jt3.exports;
}
var Bt3 = { exports: {} };
var zs2;
function df() {
  return zs2 || (zs2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  }(Bt3, Bt3.exports)), Bt3.exports;
}
var Gt3 = { exports: {} };
var Ws2;
function pf() {
  return Ws2 || (Ws2 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      for (var l2 = "", f = p.indexOf("/*"), s2 = 0; f >= 0; ) {
        l2 = l2 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l2;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l2 = l2 + p.slice(s2), l2;
    }
    u.exports = a.default;
  }(Gt3, Gt3.exports)), Gt3.exports;
}
var Vs2;
function mr3() {
  if (Vs2) return Qe3;
  Vs2 = 1, Qe3.__esModule = true, Qe3.unesc = Qe3.stripComments = Qe3.getProp = Qe3.ensureObject = void 0;
  var u = l2(Bi2());
  Qe3.unesc = u.default;
  var a = l2(cf());
  Qe3.getProp = a.default;
  var h7 = l2(df());
  Qe3.ensureObject = h7.default;
  var p = l2(pf());
  Qe3.stripComments = p.default;
  function l2(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Qe3;
}
var js2;
function rt3() {
  return js2 || (js2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = mr3();
    function p(c2, t8) {
      for (var e2 = 0; e2 < t8.length; e2++) {
        var r2 = t8[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l2(c2, t8, e2) {
      return t8 && p(c2.prototype, t8), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c2(t8, e2) {
      if (typeof t8 != "object" || t8 === null)
        return t8;
      var r2 = new t8.constructor();
      for (var i in t8)
        if (t8.hasOwnProperty(i)) {
          var o2 = t8[i], v3 = typeof o2;
          i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : o2 instanceof Array ? r2[i] = o2.map(function(m) {
            return c2(m, r2);
          }) : r2[i] = c2(o2, r2);
        }
      return r2;
    }, s2 = function() {
      function c2(e2) {
        e2 === void 0 && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t8 = c2.prototype;
      return t8.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, t8.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t8.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t8.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t8.clone = function(r2) {
        r2 === void 0 && (r2 = {});
        var i = f(this);
        for (var o2 in r2)
          i[o2] = r2[o2];
        return i;
      }, t8.appendToPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i, m || o2 !== i ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t8.setPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {}), this[r2] = i, this.raws[r2] = o2;
      }, t8.setPropertyWithoutEscape = function(r2, i) {
        this[r2] = i, this.raws && delete this.raws[r2];
      }, t8.isAtPosition = function(r2, i) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i || this.source.end.line === r2 && this.source.end.column < i);
      }, t8.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t8.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t8.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l2(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === void 0 && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h7.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === void 0 && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h7.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    }();
    a.default = s2, u.exports = a.default;
  }(Wt3, Wt3.exports)), Wt3.exports;
}
var Me3 = {};
var Bs2;
function $e2() {
  if (Bs2) return Me3;
  Bs2 = 1, Me3.__esModule = true, Me3.UNIVERSAL = Me3.TAG = Me3.STRING = Me3.SELECTOR = Me3.ROOT = Me3.PSEUDO = Me3.NESTING = Me3.ID = Me3.COMMENT = Me3.COMBINATOR = Me3.CLASS = Me3.ATTRIBUTE = void 0;
  var u = "tag";
  Me3.TAG = u;
  var a = "string";
  Me3.STRING = a;
  var h7 = "selector";
  Me3.SELECTOR = h7;
  var p = "root";
  Me3.ROOT = p;
  var l2 = "pseudo";
  Me3.PSEUDO = l2;
  var f = "nesting";
  Me3.NESTING = f;
  var s2 = "id";
  Me3.ID = s2;
  var c2 = "comment";
  Me3.COMMENT = c2;
  var t8 = "combinator";
  Me3.COMBINATOR = t8;
  var e2 = "class";
  Me3.CLASS = e2;
  var r2 = "attribute";
  Me3.ATTRIBUTE = r2;
  var i = "universal";
  return Me3.UNIVERSAL = i, Me3;
}
var Gs2;
function Gi2() {
  return Gs2 || (Gs2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(rt3()), p = f($e2());
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _3 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_3) return (_3 = _3.call(n2)).next.bind(_3);
      if (Array.isArray(n2) || (_3 = t8(n2)) || d2) {
        _3 && (n2 = _3);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t8(n2, d2) {
      if (n2) {
        if (typeof n2 == "string") return e2(n2, d2);
        var _3 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_3 === "Object" && n2.constructor && (_3 = n2.constructor.name), _3 === "Map" || _3 === "Set") return Array.from(n2);
        if (_3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_3)) return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _3 = 0, w3 = new Array(d2); _3 < d2; _3++)
        w3[_3] = n2[_3];
      return w3;
    }
    function r2(n2, d2) {
      for (var _3 = 0; _3 < d2.length; _3++) {
        var w3 = d2[_3];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i(n2, d2, _3) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _3 = d2.prototype;
      return _3.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _3.prepend = function(y2) {
        return y2.parent = this, this.nodes.unshift(y2), this;
      }, _3.at = function(y2) {
        return this.nodes[y2];
      }, _3.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _3.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = void 0, this.nodes.splice(y2, 1);
        var x;
        for (var g2 in this.indexes)
          x = this.indexes[g2], x >= y2 && (this.indexes[g2] = x - 1);
        return this;
      }, _3.removeAll = function() {
        for (var y2 = c2(this.nodes), x; !(x = y2()).done; ) {
          var g2 = x.value;
          g2.parent = void 0;
        }
        return this.nodes = [], this;
      }, _3.empty = function() {
        return this.removeAll();
      }, _3.insertAfter = function(y2, x) {
        x.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2 + 1, 0, x), x.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], g2 <= O3 && (this.indexes[A] = O3 + 1);
        return this;
      }, _3.insertBefore = function(y2, x) {
        x.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2, 0, x), x.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], O3 <= g2 && (this.indexes[A] = O3 + 1);
        return this;
      }, _3._findChildAtPosition = function(y2, x) {
        var g2 = void 0;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x))
            return g2 = O3, false;
        }), g2;
      }, _3.atPosition = function(y2, x) {
        if (this.isAtPosition(y2, x))
          return this._findChildAtPosition(y2, x) || this;
      }, _3._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _3.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x = this.lastEach;
        if (this.indexes[x] = 0, !!this.length) {
          for (var g2, O3; this.indexes[x] < this.length && (g2 = this.indexes[x], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x] += 1;
          if (delete this.indexes[x], O3 === false)
            return false;
        }
      }, _3.walk = function(y2) {
        return this.each(function(x, g2) {
          var O3 = y2(x, g2);
          if (O3 !== false && x.length && (O3 = x.walk(y2)), O3 === false)
            return false;
        });
      }, _3.walkAttributes = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x, g2);
        });
      }, _3.walkClasses = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x, g2);
        });
      }, _3.walkCombinators = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x, g2);
        });
      }, _3.walkComments = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x, g2);
        });
      }, _3.walkIds = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x, g2);
        });
      }, _3.walkNesting = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x, g2);
        });
      }, _3.walkPseudos = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x, g2);
        });
      }, _3.walkTags = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x, g2);
        });
      }, _3.walkUniversals = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x, g2);
        });
      }, _3.split = function(y2) {
        var x = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b3 = y2.call(x, A);
          return g2.push(A), b3 ? (O3.push(g2), g2 = []) : E2 === x.length - 1 && O3.push(g2), O3;
        }, []);
      }, _3.map = function(y2) {
        return this.nodes.map(y2);
      }, _3.reduce = function(y2, x) {
        return this.nodes.reduce(y2, x);
      }, _3.every = function(y2) {
        return this.nodes.every(y2);
      }, _3.some = function(y2) {
        return this.nodes.some(y2);
      }, _3.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _3.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _3.toString = function() {
        return this.map(String).join("");
      }, i(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    }(h7.default);
    a.default = m, u.exports = a.default;
  }(zt3, zt3.exports)), zt3.exports;
}
var Ys2;
function Ul() {
  return Ys2 || (Ys2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Gi2()), p = $e2();
    function l2(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i) {
      for (var o2 = 0; o2 < i.length; o2++) {
        var v3 = i[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i, o2) {
      return i && f(r2.prototype, i), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i) {
      r2.prototype = Object.create(i.prototype), r2.prototype.constructor = r2, t8(r2, i);
    }
    function t8(r2, i) {
      return t8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t8(r2, i);
    }
    var e2 = function(r2) {
      c2(i, r2);
      function i(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i;
    }(h7.default);
    a.default = e2, u.exports = a.default;
  }(Ut3, Ut3.exports)), Ut3.exports;
}
var Yt3 = { exports: {} };
var Qs;
function zl() {
  return Qs || (Qs = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Gi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.SELECTOR, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Yt3, Yt3.exports)), Yt3.exports;
}
var Qt3 = { exports: {} };
var Hs2;
function Wl() {
  return Hs2 || (Hs2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(at3()), p = mr3(), l2 = s2(rt3()), f = $e2();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0; m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t8(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i = function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t8(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _3 = (0, h7.default)(d2, {
              isIdentifier: true
            });
            _3 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _3) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    }(l2.default);
    a.default = i, u.exports = a.default;
  }(Qt3, Qt3.exports)), Qt3.exports;
}
var Ht3 = { exports: {} };
var Js;
function Vl() {
  return Js || (Js = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMMENT, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Ht3, Ht3.exports)), Ht3.exports;
}
var Jt2 = { exports: {} };
var Ks2;
function jl() {
  return Ks2 || (Ks2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t8.prototype.valueToString.call(this);
      }, e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Jt2, Jt2.exports)), Jt2.exports;
}
var Kt3 = { exports: {} };
var Xt3 = { exports: {} };
var Xs2;
function Yi2() {
  return Xs2 || (Xs2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = f(at3()), p = mr3(), l2 = f(rt3());
    function f(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s2(i, o2) {
      for (var v3 = 0; v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i, m.key, m);
      }
    }
    function c2(i, o2, v3) {
      return o2 && s2(i.prototype, o2), Object.defineProperty(i, "prototype", { writable: false }), i;
    }
    function t8(i, o2) {
      i.prototype = Object.create(o2.prototype), i.prototype.constructor = i, e2(i, o2);
    }
    function e2(i, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i, o2);
    }
    var r2 = function(i) {
      t8(o2, i);
      function o2() {
        return i.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h7.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    }(l2.default);
    a.default = r2, u.exports = a.default;
  }(Xt3, Xt3.exports)), Xt3.exports;
}
var Zs;
function Bl() {
  return Zs || (Zs = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Yi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.TAG, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Kt3, Kt3.exports)), Kt3.exports;
}
var Zt2 = { exports: {} };
var eo3;
function Gl() {
  return eo3 || (eo3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.STRING, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(Zt2, Zt2.exports)), Zt2.exports;
}
var er2 = { exports: {} };
var to3;
function Yl() {
  return to3 || (to3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Gi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(er2, er2.exports)), er2.exports;
}
var In3 = {};
var ro3;
function Ql() {
  return ro3 || (ro3 = 1, function(u) {
    u.__esModule = true, u.default = void 0, u.unescapeValue = d2;
    var a = s2(at3()), h7 = s2(Bi2()), p = s2(Yi2()), l2 = $e2(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0; A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t8(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b3) {
        return E2.__proto__ = b3, E2;
      }, r2(g2, O3);
    }
    var i = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b3 = E2.match(o2);
      return b3 && (A = b3[1], E2 = b3[2]), E2 = (0, h7.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _3(g2) {
      if (g2.quoteMark !== void 0 || g2.value === void 0)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === void 0 && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b3;
        return E2 === void 0 && (E2 = {}), b3 = g2.call(this, _3(E2)) || this, b3.type = l2.ATTRIBUTE, b3.raws = b3.raws || {}, Object.defineProperty(b3.raws, "unquoted", {
          get: i(function() {
            return b3.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i(function() {
            return b3.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b3._constructed = true, b3;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b3) {
        b3 === void 0 && (b3 = {});
        var k3 = this._determineQuoteMark(b3), q2 = y2[k3], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b3) {
        return b3.smart ? this.smartQuoteMark(b3) : this.preferredQuoteMark(b3);
      }, A.setValue = function(b3, k3) {
        k3 === void 0 && (k3 = {}), this._value = b3, this._quoteMark = this._determineQuoteMark(k3), this._syncRawValue();
      }, A.smartQuoteMark = function(b3) {
        var k3 = this.value, q2 = k3.replace(/[^']/g, "").length, M2 = k3.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k3, {
            isIdentifier: true
          });
          if (W3 === k3)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b3);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b3.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k3, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else return M2 === q2 ? this.preferredQuoteMark(b3) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b3) {
        var k3 = b3.preferCurrentQuoteMark ? this.quoteMark : b3.quoteMark;
        return k3 === void 0 && (k3 = b3.preferCurrentQuoteMark ? b3.quoteMark : this.quoteMark), k3 === void 0 && (k3 = O3.DOUBLE_QUOTE), k3;
      }, A._syncRawValue = function() {
        var b3 = (0, a.default)(this._value, y2[this.quoteMark]);
        b3 === this._value ? this.raws && delete this.raws.value : this.raws.value = b3;
      }, A._handleEscapes = function(b3, k3) {
        if (this._constructed) {
          var q2 = (0, a.default)(k3, {
            isIdentifier: true
          });
          q2 !== k3 ? this.raws[b3] = q2 : delete this.raws[b3];
        }
      }, A._spacesFor = function(b3) {
        var k3 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b3] || {}, M2 = this.raws.spaces && this.raws.spaces[b3] || {};
        return Object.assign(k3, q2, M2);
      }, A._stringFor = function(b3, k3, q2) {
        k3 === void 0 && (k3 = b3), q2 === void 0 && (q2 = x);
        var M2 = this._spacesFor(k3);
        return q2(this.stringifyProperty(b3), M2);
      }, A.offsetOf = function(b3) {
        var k3 = 1, q2 = this._spacesFor("attribute");
        if (k3 += q2.before.length, b3 === "namespace" || b3 === "ns")
          return this.namespace ? k3 : -1;
        if (b3 === "attributeNS" || (k3 += this.namespaceString.length, this.namespace && (k3 += 1), b3 === "attribute"))
          return k3;
        k3 += this.stringifyProperty("attribute").length, k3 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k3 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b3 === "operator")
          return W3 ? k3 : -1;
        k3 += W3.length, k3 += M2.after.length;
        var S3 = this._spacesFor("value");
        k3 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b3 === "value")
          return P3 ? k3 : -1;
        k3 += P3.length, k3 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k3 += C.before.length, b3 === "insensitive" && this.insensitive ? k3 : -1;
      }, A.toString = function() {
        var b3 = this, k3 = [this.rawSpaceBefore, "["];
        return k3.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k3.push(this._stringFor("operator")), k3.push(this._stringFor("value")), k3.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b3.quoted && M2.before.length === 0 && !(b3.spaces.value && b3.spaces.value.after) && (M2.before = " "), x(q2, M2);
        }))), k3.push("]"), k3.push(this.rawSpaceAfter), k3.join("");
      }, t8(O3, [{
        key: "quoted",
        get: function() {
          var b3 = this.quoteMark;
          return b3 === "'" || b3 === '"';
        },
        set: function(b3) {
          m();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b3) {
          if (!this._constructed) {
            this._quoteMark = b3;
            return;
          }
          this._quoteMark !== b3 && (this._quoteMark = b3, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function(b3) {
            if (this._constructed) {
              var k3 = d2(b3), q2 = k3.deprecatedUsage, M2 = k3.unescaped, W3 = k3.quoteMark;
              if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
                return;
              this._value = M2, this._quoteMark = W3, this._syncRawValue();
            } else
              this._value = b3;
          }
        )
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b3) {
          b3 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = b3;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b3) {
          this._handleEscapes("attribute", b3), this._attribute = b3;
        }
      }]), O3;
    }(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  }(In3)), In3;
}
var tr2 = { exports: {} };
var no3;
function Hl() {
  return no3 || (no3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(Yi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.UNIVERSAL, i.value = "*", i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(tr2, tr2.exports)), tr2.exports;
}
var rr3 = { exports: {} };
var io3;
function Jl() {
  return io3 || (io3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMBINATOR, i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(rr3, rr3.exports)), rr3.exports;
}
var nr3 = { exports: {} };
var ao3;
function Kl() {
  return ao3 || (ao3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.NESTING, i.value = "&", i;
      }
      return e2;
    }(h7.default);
    a.default = c2, u.exports = a.default;
  }(nr3, nr3.exports)), nr3.exports;
}
var ir3 = { exports: {} };
var so3;
function hf() {
  return so3 || (so3 = 1, function(u, a) {
    a.__esModule = true, a.default = h7;
    function h7(p) {
      return p.sort(function(l2, f) {
        return l2 - f;
      });
    }
    u.exports = a.default;
  }(ir3, ir3.exports)), ir3.exports;
}
var Mn3 = {};
var le3 = {};
var oo3;
function Xl() {
  if (oo3) return le3;
  oo3 = 1, le3.__esModule = true, le3.word = le3.tilde = le3.tab = le3.str = le3.space = le3.slash = le3.singleQuote = le3.semicolon = le3.plus = le3.pipe = le3.openSquare = le3.openParenthesis = le3.newline = le3.greaterThan = le3.feed = le3.equals = le3.doubleQuote = le3.dollar = le3.cr = le3.comment = le3.comma = le3.combinator = le3.colon = le3.closeSquare = le3.closeParenthesis = le3.caret = le3.bang = le3.backslash = le3.at = le3.asterisk = le3.ampersand = void 0;
  var u = 38;
  le3.ampersand = u;
  var a = 42;
  le3.asterisk = a;
  var h7 = 64;
  le3.at = h7;
  var p = 44;
  le3.comma = p;
  var l2 = 58;
  le3.colon = l2;
  var f = 59;
  le3.semicolon = f;
  var s2 = 40;
  le3.openParenthesis = s2;
  var c2 = 41;
  le3.closeParenthesis = c2;
  var t8 = 91;
  le3.openSquare = t8;
  var e2 = 93;
  le3.closeSquare = e2;
  var r2 = 36;
  le3.dollar = r2;
  var i = 126;
  le3.tilde = i;
  var o2 = 94;
  le3.caret = o2;
  var v3 = 43;
  le3.plus = v3;
  var m = 61;
  le3.equals = m;
  var n2 = 124;
  le3.pipe = n2;
  var d2 = 62;
  le3.greaterThan = d2;
  var _3 = 32;
  le3.space = _3;
  var w3 = 39;
  le3.singleQuote = w3;
  var y2 = 34;
  le3.doubleQuote = y2;
  var x = 47;
  le3.slash = x;
  var g2 = 33;
  le3.bang = g2;
  var O3 = 92;
  le3.backslash = O3;
  var A = 13;
  le3.cr = A;
  var E2 = 12;
  le3.feed = E2;
  var b3 = 10;
  le3.newline = b3;
  var k3 = 9;
  le3.tab = k3;
  var q2 = w3;
  le3.str = q2;
  var M2 = -1;
  le3.comment = M2;
  var W3 = -2;
  le3.word = W3;
  var S3 = -3;
  return le3.combinator = S3, le3;
}
var lo3;
function vf() {
  return lo3 || (lo3 = 1, function(u) {
    u.__esModule = true, u.FIELDS = void 0, u.default = m;
    var a = f(Xl()), h7, p;
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    for (var s2 = (h7 = {}, h7[a.tab] = true, h7[a.newline] = true, h7[a.cr] = true, h7[a.feed] = true, h7), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t8 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0; r2 < e2.length; r2++)
      t8[e2.charCodeAt(r2)] = true;
    function i(n2, d2) {
      var _3 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_3), c2[w3])
          return _3 - 1;
        w3 === a.backslash ? _3 = o2(n2, _3) + 1 : _3++;
      } while (_3 < n2.length);
      return _3 - 1;
    }
    function o2(n2, d2) {
      var _3 = d2, w3 = n2.charCodeAt(_3 + 1);
      if (!s2[w3]) if (t8[w3]) {
        var y2 = 0;
        do
          _3++, y2++, w3 = n2.charCodeAt(_3 + 1);
        while (t8[w3] && y2 < 6);
        y2 < 6 && w3 === a.space && _3++;
      } else
        _3++;
      return _3;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _3 = n2.css.valueOf(), w3 = _3, y2 = w3.length, x = -1, g2 = 1, O3 = 0, A = 0, E2, b3, k3, q2, M2, W3, S3, P3, C, R3, $2, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _3 += D, C = _3.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x, O3);
      }
      for (; O3 < y2; ) {
        switch (E2 = _3.charCodeAt(O3), E2 === a.newline && (x = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C), E2 === a.newline && (x = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k3 = C - x - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k3 = O3 - x, A = C;
            break;
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _3.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C; _3.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          default:
            E2 === a.slash && _3.charCodeAt(O3 + 1) === a.asterisk ? (C = _3.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b3 = _3.slice(O3, C + 1), P3 = b3.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $2 = C - P3[S3].length) : (R3 = g2, $2 = x), z3 = a.comment, g2 = R3, q2 = R3, k3 = C - $2) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1) : (C = i(_3, O3), z3 = a.word, q2 = g2, k3 = C - x), A = C + 1;
            break;
        }
        d2.push([
          z3,
          // [0] Token type
          g2,
          // [1] Starting line
          O3 - x,
          // [2] Starting column
          q2,
          // [3] Ending line
          k3,
          // [4] Ending column
          O3,
          // [5] Start position / Source index
          A
          // [6] End position
        ]), $2 && (x = $2, $2 = null), O3 = A;
      }
      return d2;
    }
  }(Mn3)), Mn3;
}
var uo3;
function gf() {
  return uo3 || (uo3 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = A(Ul()), p = A(zl()), l2 = A(Wl()), f = A(Vl()), s2 = A(jl()), c2 = A(Bl()), t8 = A(Gl()), e2 = A(Yl()), r2 = O3(Ql()), i = A(Hl()), o2 = A(Jl()), v3 = A(Kl()), m = A(hf()), n2 = O3(vf()), d2 = O3(Xl()), _3 = O3($e2()), w3 = mr3(), y2, x;
    function g2(L3) {
      if (typeof WeakMap != "function") return null;
      var F = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T3 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T3 && (T3.get || T3.set) ? Object.defineProperty(I3, J3, T3) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0; D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b3(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k3 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k3, (x = {}, x[d2.comment] = true, x));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === void 0 && (L3.raws[F] = D)), L3;
    }
    function $2(L3, F) {
      for (var D = -1, I3 = []; (D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = function() {
      function L3(D, I3) {
        I3 === void 0 && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h7.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T3 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false; U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne3 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T3, "spaces", V4);
                var de3 = T3.spaces[V4].after || "";
                T3.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || null;
                _e3 && (T3.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne3[n2.FIELDS.TYPE] === d2.equals)
                T3.operator = Q3, V4 = "operator";
              else if ((!T3.namespace || V4 === "namespace" && !K3) && ne3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = j3, H3 = ""), T3.namespace = (T3.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T3, "raws", "namespace") || null;
                be3 && (T3.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T3, "raws", "value");
                T3.value += "$", ie3 && (T3.raws.value = ie3 + "$");
                break;
              }
            case d2.caret:
              ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne3[n2.FIELDS.TYPE] === d2.equals ? (T3.operator = Q3, V4 = "operator") : !T3.namespace && !T3.attribute && (T3.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne3 && this.content(ne3) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && // this look-ahead probably fails with comment nodes involved.
              !T3.operator && !T3.namespace)
                T3.namespace = Q3, V4 = "namespace";
              else if (!T3.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = H3, H3 = ""), T3.attribute = (T3.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T3, "raws", "attribute") || null;
                ke3 && (T3.raws.attribute += Q3), V4 = "attribute";
              } else if (!T3.value && T3.value !== "" || V4 === "value" && !(K3 || T3.quoteMark)) {
                var Y3 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T3, "raws", "value") || "", te2 = T3.value || "";
                T3.value = te2 + Y3, T3.quoteMark = null, (Y3 !== Q3 || G3) && ((0, w3.ensureObject)(T3, "raws"), T3.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T3.value || T3.value === "") && (T3.quoteMark || K3) ? (T3.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T3, "raws"), T3.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T3, "spaces", "insensitive"), T3.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "insensitive"), T3.raws.spaces.insensitive.before = H3, H3 = "")) : (T3.value || T3.value === "") && (V4 = "value", T3.value += Q3, T3.raws.value && (T3.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T3.attribute || !T3.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T3.value = se3, T3.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T3, "raws"), T3.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T3.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T3.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T3.operator = T3.operator ? T3.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne3 && ne3[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T3, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T3, "raws", "spaces", V4), T3.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T3[V4] || "", ve3 = (0, w3.getProp)(T3, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T3, "raws"), T3.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T3, "attribute"), R3(T3, "namespace"), this.newNode(new r2.default(T3)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T3 = "", U2 = void 0;
        do
          if (k3[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T3 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T3 && (j3.before = T3, T3 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T3) {
          if (U2)
            U2.spaces.after = T3;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t8.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T3,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === void 0 && (N3 = false);
        var T3 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T3 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T3 && (U2 = void 0);
        var j3 = {
          space: T3,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === void 0 && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T3 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T3;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T3 = this.current.last;
            if (T3) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== void 0 && (T3.rawSpaceAfter += H3), T3.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = void 0;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k3[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne3 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne3, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y3 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y3.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y3.spaces.after = ie3.slice(1)) : Y3.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y3
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _3.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T3 = this.current;
          for (I3.append(J3), this.current = J3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T3;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t8.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken; this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T3, U2) {
            N3 += T3, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t8.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T3 = this.nextToken, U2 = this.content(); T3 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T3[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T3 = this.nextToken;
        }
        var V4 = $2(U2, ".").filter(function(ne3) {
          var de3 = U2[ne3 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $2(U2, "#").filter(function(ne3) {
          return U2[ne3 - 1] !== "\\";
        }), X3 = $2(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne3) {
          return !~X3.indexOf(ne3);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne3, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne3, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y3 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne3, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne3)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new l2.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne3)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y3
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (; this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T3 = I3.pop();
          I3 = I3.join(", ") + " or " + T3;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === void 0 && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === void 0 && (I3 = this.position + 1);
        for (var N3 = I3; N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b3(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    }();
    a.default = z3, u.exports = a.default;
  }($t3, $t3.exports)), $t3.exports;
}
var fo2;
function mf() {
  return fo2 || (fo2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = p(gf());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l2 = function() {
      function f(c2, t8) {
        this.func = c2 || function() {
        }, this.funcRes = null, this.options = t8;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t8 != "string";
      }, s2._isLossy = function(t8) {
        t8 === void 0 && (t8 = {});
        var e2 = Object.assign({}, this.options, t8);
        return e2.lossless === false;
      }, s2._root = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = new h7.default(t8, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t8) {
        return {
          lossy: this._isLossy(t8)
        };
      }, s2._run = function(t8, e2) {
        var r2 = this;
        return e2 === void 0 && (e2 = {}), new Promise(function(i, o2) {
          try {
            var v3 = r2._root(t8, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = void 0;
              return r2._shouldUpdateSelector(t8, e2) && (n2 = v3.toString(), t8.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = this._root(t8, e2), i = this.func(r2);
        if (i && typeof i.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = void 0;
        return e2.updateSelector && typeof t8 != "string" && (o2 = r2.toString(), t8.selector = o2), {
          transform: i,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t8, e2) {
        return this._runSync(t8, e2).root;
      }, s2.transform = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t8, e2) {
        return this._runSync(t8, e2).transform;
      }, s2.process = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t8, e2) {
        var r2 = this._runSync(t8, e2);
        return r2.string || r2.root.toString();
      }, f;
    }();
    a.default = l2, u.exports = a.default;
  }(Ft2, Ft2.exports)), Ft2.exports;
}
var Dn3 = {};
var De3 = {};
var co3;
function yf() {
  if (co3) return De3;
  co3 = 1, De3.__esModule = true, De3.universal = De3.tag = De3.string = De3.selector = De3.root = De3.pseudo = De3.nesting = De3.id = De3.comment = De3.combinator = De3.className = De3.attribute = void 0;
  var u = o2(Ql()), a = o2(Wl()), h7 = o2(Jl()), p = o2(Vl()), l2 = o2(jl()), f = o2(Kl()), s2 = o2(Yl()), c2 = o2(Ul()), t8 = o2(zl()), e2 = o2(Gl()), r2 = o2(Bl()), i = o2(Hl());
  function o2(b3) {
    return b3 && b3.__esModule ? b3 : { default: b3 };
  }
  var v3 = function(k3) {
    return new u.default(k3);
  };
  De3.attribute = v3;
  var m = function(k3) {
    return new a.default(k3);
  };
  De3.className = m;
  var n2 = function(k3) {
    return new h7.default(k3);
  };
  De3.combinator = n2;
  var d2 = function(k3) {
    return new p.default(k3);
  };
  De3.comment = d2;
  var _3 = function(k3) {
    return new l2.default(k3);
  };
  De3.id = _3;
  var w3 = function(k3) {
    return new f.default(k3);
  };
  De3.nesting = w3;
  var y2 = function(k3) {
    return new s2.default(k3);
  };
  De3.pseudo = y2;
  var x = function(k3) {
    return new c2.default(k3);
  };
  De3.root = x;
  var g2 = function(k3) {
    return new t8.default(k3);
  };
  De3.selector = g2;
  var O3 = function(k3) {
    return new e2.default(k3);
  };
  De3.string = O3;
  var A = function(k3) {
    return new r2.default(k3);
  };
  De3.tag = A;
  var E2 = function(k3) {
    return new i.default(k3);
  };
  return De3.universal = E2, De3;
}
var Ee3 = {};
var po3;
function wf() {
  if (po3) return Ee3;
  po3 = 1, Ee3.__esModule = true, Ee3.isComment = Ee3.isCombinator = Ee3.isClassName = Ee3.isAttribute = void 0, Ee3.isContainer = y2, Ee3.isIdentifier = void 0, Ee3.isNamespace = x, Ee3.isNesting = void 0, Ee3.isNode = p, Ee3.isPseudo = void 0, Ee3.isPseudoClass = w3, Ee3.isPseudoElement = _3, Ee3.isUniversal = Ee3.isTag = Ee3.isString = Ee3.isSelector = Ee3.isRoot = void 0;
  var u = $e2(), a, h7 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h7[g2.type];
  }
  function l2(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l2.bind(null, u.ATTRIBUTE);
  Ee3.isAttribute = f;
  var s2 = l2.bind(null, u.CLASS);
  Ee3.isClassName = s2;
  var c2 = l2.bind(null, u.COMBINATOR);
  Ee3.isCombinator = c2;
  var t8 = l2.bind(null, u.COMMENT);
  Ee3.isComment = t8;
  var e2 = l2.bind(null, u.ID);
  Ee3.isIdentifier = e2;
  var r2 = l2.bind(null, u.NESTING);
  Ee3.isNesting = r2;
  var i = l2.bind(null, u.PSEUDO);
  Ee3.isPseudo = i;
  var o2 = l2.bind(null, u.ROOT);
  Ee3.isRoot = o2;
  var v3 = l2.bind(null, u.SELECTOR);
  Ee3.isSelector = v3;
  var m = l2.bind(null, u.STRING);
  Ee3.isString = m;
  var n2 = l2.bind(null, u.TAG);
  Ee3.isTag = n2;
  var d2 = l2.bind(null, u.UNIVERSAL);
  Ee3.isUniversal = d2;
  function _3(g2) {
    return i(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i(g2) && !_3(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x(g2) {
    return f(g2) || n2(g2);
  }
  return Ee3;
}
var ho2;
function bf() {
  return ho2 || (ho2 = 1, function(u) {
    u.__esModule = true;
    var a = $e2();
    Object.keys(a).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === a[l2] || (u[l2] = a[l2]);
    });
    var h7 = yf();
    Object.keys(h7).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === h7[l2] || (u[l2] = h7[l2]);
    });
    var p = wf();
    Object.keys(p).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === p[l2] || (u[l2] = p[l2]);
    });
  }(Dn3)), Dn3;
}
var vo2;
function Ke3() {
  return vo2 || (vo2 = 1, function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h7 = s2(mf()), p = f(bf());
    function l2(e2) {
      if (typeof WeakMap != "function") return null;
      var r2 = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
      return (l2 = function(v3) {
        return v3 ? i : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i = l2(r2);
      if (i && i.has(e2))
        return i.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i && i.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h7.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t8 = c2;
    a.default = t8, u.exports = a.default;
  }(Nt3, Nt3.exports)), Nt3.exports;
}
var qn3 = {};
var Ln3 = {};
var ar3 = { exports: {} };
var go2;
function _f() {
  if (go2) return ar3.exports;
  go2 = 1;
  const { AtRule: u, Rule: a } = Be2();
  let h7 = Ke3();
  function p(_3, w3) {
    let y2;
    try {
      h7((x) => {
        y2 = x;
      }).processSync(_3);
    } catch (x) {
      throw _3.includes(":") ? w3 ? w3.error("Missed semicolon") : x : w3 ? w3.error(x.message) : x;
    }
    return y2.at(0);
  }
  function l2(_3, w3) {
    let y2 = false;
    return _3.each((x) => {
      if (x.type === "nesting") {
        let g2 = w3.clone({});
        x.value !== "&" ? x.replaceWith(
          p(x.value.replace("&", g2.toString()))
        ) : x.replaceWith(g2), y2 = true;
      } else "nodes" in x && x.nodes && l2(x, w3) && (y2 = true);
    }), y2;
  }
  function f(_3, w3) {
    let y2 = [];
    return _3.selectors.forEach((x) => {
      let g2 = p(x, _3);
      w3.selectors.forEach((O3) => {
        if (!O3)
          return;
        let A = p(O3, w3);
        l2(A, g2) || (A.prepend(h7.combinator({ value: " " })), A.prepend(g2.clone({}))), y2.push(A.toString());
      });
    }), y2;
  }
  function s2(_3, w3) {
    let y2 = _3.prev();
    for (w3.after(_3); y2 && y2.type === "comment"; ) {
      let x = y2.prev();
      w3.after(y2), y2 = x;
    }
    return _3;
  }
  function c2(_3) {
    return function w3(y2, x, g2, O3 = g2) {
      let A = [];
      if (x.each((E2) => {
        E2.type === "rule" && g2 ? O3 && (E2.selectors = f(y2, E2)) : E2.type === "atrule" && E2.nodes ? _3[E2.name] ? w3(y2, E2, O3) : x[v3] !== false && A.push(E2) : A.push(E2);
      }), g2 && A.length) {
        let E2 = y2.clone({ nodes: [] });
        for (let b3 of A)
          E2.append(b3);
        x.prepend(E2);
      }
    };
  }
  function t8(_3, w3, y2) {
    let x = new a({
      nodes: [],
      selector: _3
    });
    return x.append(w3), y2.after(x), x;
  }
  function e2(_3, w3) {
    let y2 = {};
    for (let x of _3)
      y2[x] = true;
    if (w3)
      for (let x of w3)
        y2[x.replace(/^@/, "")] = true;
    return y2;
  }
  function r2(_3) {
    _3 = _3.trim();
    let w3 = _3.match(/^\((.*)\)$/);
    if (!w3)
      return { selector: _3, type: "basic" };
    let y2 = w3[1].match(/^(with(?:out)?):(.+)$/);
    if (y2) {
      let x = y2[1] === "with", g2 = Object.fromEntries(
        y2[2].trim().split(/\s+/).map((A) => [A, true])
      );
      if (x && g2.all)
        return { type: "noop" };
      let O3 = (A) => !!g2[A];
      return g2.all ? O3 = () => true : x && (O3 = (A) => A === "all" ? false : !g2[A]), {
        escapes: O3,
        type: "withrules"
      };
    }
    return { type: "unknown" };
  }
  function i(_3) {
    let w3 = [], y2 = _3.parent;
    for (; y2 && y2 instanceof u; )
      w3.push(y2), y2 = y2.parent;
    return w3;
  }
  function o2(_3) {
    let w3 = _3[m];
    if (!w3)
      _3.after(_3.nodes);
    else {
      let y2 = _3.nodes, x, g2 = -1, O3, A, E2, b3 = i(_3);
      if (b3.forEach((k3, q2) => {
        if (w3(k3.name))
          x = k3, g2 = q2, A = E2;
        else {
          let M2 = E2;
          E2 = k3.clone({ nodes: [] }), M2 && E2.append(M2), O3 = O3 || E2;
        }
      }), x ? A ? (O3.append(y2), x.after(A)) : x.after(y2) : _3.after(y2), _3.next() && x) {
        let k3;
        b3.slice(0, g2 + 1).forEach((q2, M2, W3) => {
          let S3 = k3;
          k3 = q2.clone({ nodes: [] }), S3 && k3.append(S3);
          let P3 = [], R3 = (W3[M2 - 1] || _3).next();
          for (; R3; )
            P3.push(R3), R3 = R3.next();
          k3.append(P3);
        }), k3 && (A || y2[y2.length - 1]).after(k3);
      }
    }
    _3.remove();
  }
  const v3 = Symbol("rootRuleMergeSel"), m = Symbol("rootRuleEscapes");
  function n2(_3) {
    let { params: w3 } = _3, { escapes: y2, selector: x, type: g2 } = r2(w3);
    if (g2 === "unknown")
      throw _3.error(
        `Unknown @${_3.name} parameter ${JSON.stringify(w3)}`
      );
    if (g2 === "basic" && x) {
      let O3 = new a({ nodes: _3.nodes, selector: x });
      _3.removeAll(), _3.append(O3);
    }
    _3[m] = y2, _3[v3] = y2 ? !y2("all") : g2 === "noop";
  }
  const d2 = Symbol("hasRootRule");
  return ar3.exports = (_3 = {}) => {
    let w3 = e2(
      ["media", "supports", "layer", "container", "starting-style"],
      _3.bubble
    ), y2 = c2(w3), x = e2(
      [
        "document",
        "font-face",
        "keyframes",
        "-webkit-keyframes",
        "-moz-keyframes"
      ],
      _3.unwrap
    ), g2 = (_3.rootRuleName || "at-root").replace(/^@/, ""), O3 = _3.preserveEmpty;
    return {
      Once(A) {
        A.walkAtRules(g2, (E2) => {
          n2(E2), A[d2] = true;
        });
      },
      postcssPlugin: "postcss-nested",
      RootExit(A) {
        A[d2] && (A.walkAtRules(g2, o2), A[d2] = false);
      },
      Rule(A) {
        let E2 = false, b3 = A, k3 = false, q2 = [];
        A.each((M2) => {
          M2.type === "rule" ? (q2.length && (b3 = t8(A.selector, q2, b3), q2 = []), k3 = true, E2 = true, M2.selectors = f(A, M2), b3 = s2(M2, b3)) : M2.type === "atrule" ? (q2.length && (b3 = t8(A.selector, q2, b3), q2 = []), M2.name === g2 ? (E2 = true, y2(A, M2, true, M2[v3]), b3 = s2(M2, b3)) : w3[M2.name] ? (k3 = true, E2 = true, y2(A, M2, true), b3 = s2(M2, b3)) : x[M2.name] ? (k3 = true, E2 = true, y2(A, M2, false), b3 = s2(M2, b3)) : k3 && q2.push(M2)) : M2.type === "decl" && k3 && q2.push(M2);
        }), q2.length && (b3 = t8(A.selector, q2, b3)), E2 && O3 !== true && (A.raws.semicolon = true, A.nodes.length === 0 && A.remove());
      }
    };
  }, ar3.exports.postcss = true, ar3.exports;
}
var Nn3;
var mo2;
function Sf() {
  if (mo2) return Nn3;
  mo2 = 1;
  var u = /-(\w|$)/g, a = function(l2, f) {
    return f.toUpperCase();
  }, h7 = function(l2) {
    return l2 = l2.toLowerCase(), l2 === "float" ? "cssFloat" : l2.charCodeAt(0) === 45 && l2.charCodeAt(1) === 109 && l2.charCodeAt(2) === 115 && l2.charCodeAt(3) === 45 ? l2.substr(1).replace(u, a) : l2.replace(u, a);
  };
  return Nn3 = h7, Nn3;
}
var Fn3;
var yo2;
function Zl() {
  if (yo2) return Fn3;
  yo2 = 1;
  let u = Sf(), a = {
    boxFlex: true,
    boxFlexGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function h7(l2) {
    return typeof l2.nodes > "u" ? true : p(l2);
  }
  function p(l2) {
    let f, s2 = {};
    return l2.each((c2) => {
      if (c2.type === "atrule")
        f = "@" + c2.name, c2.params && (f += " " + c2.params), typeof s2[f] > "u" ? s2[f] = h7(c2) : Array.isArray(s2[f]) ? s2[f].push(h7(c2)) : s2[f] = [s2[f], h7(c2)];
      else if (c2.type === "rule") {
        let t8 = p(c2);
        if (s2[c2.selector])
          for (let e2 in t8)
            s2[c2.selector][e2] = t8[e2];
        else
          s2[c2.selector] = t8;
      } else if (c2.type === "decl") {
        c2.prop[0] === "-" && c2.prop[1] === "-" || c2.parent && c2.parent.selector === ":export" ? f = c2.prop : f = u(c2.prop);
        let t8 = c2.value;
        !isNaN(c2.value) && a[f] && (t8 = parseFloat(c2.value)), c2.important && (t8 += " !important"), typeof s2[f] > "u" ? s2[f] = t8 : Array.isArray(s2[f]) ? s2[f].push(t8) : s2[f] = [s2[f], t8];
      }
    }), s2;
  }
  return Fn3 = p, Fn3;
}
var $n3;
var wo2;
function Qi2() {
  if (wo2) return $n3;
  wo2 = 1;
  let u = Be2(), a = /\s*!important\s*$/i, h7 = {
    "box-flex": true,
    "box-flex-group": true,
    "column-count": true,
    flex: true,
    "flex-grow": true,
    "flex-positive": true,
    "flex-shrink": true,
    "flex-negative": true,
    "font-weight": true,
    "line-clamp": true,
    "line-height": true,
    opacity: true,
    order: true,
    orphans: true,
    "tab-size": true,
    widows: true,
    "z-index": true,
    zoom: true,
    "fill-opacity": true,
    "stroke-dashoffset": true,
    "stroke-opacity": true,
    "stroke-width": true
  };
  function p(c2) {
    return c2.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function l2(c2, t8, e2) {
    e2 === false || e2 === null || (t8.startsWith("--") || (t8 = p(t8)), typeof e2 == "number" && (e2 === 0 || h7[t8] ? e2 = e2.toString() : e2 += "px"), t8 === "css-float" && (t8 = "float"), a.test(e2) ? (e2 = e2.replace(a, ""), c2.push(u.decl({ prop: t8, value: e2, important: true }))) : c2.push(u.decl({ prop: t8, value: e2 })));
  }
  function f(c2, t8, e2) {
    let r2 = u.atRule({ name: t8[1], params: t8[3] || "" });
    typeof e2 == "object" && (r2.nodes = [], s2(e2, r2)), c2.push(r2);
  }
  function s2(c2, t8) {
    let e2, r2, i;
    for (e2 in c2)
      if (r2 = c2[e2], !(r2 === null || typeof r2 > "u"))
        if (e2[0] === "@") {
          let o2 = e2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(r2))
            for (let v3 of r2)
              f(t8, o2, v3);
          else
            f(t8, o2, r2);
        } else if (Array.isArray(r2))
          for (let o2 of r2)
            l2(t8, e2, o2);
        else typeof r2 == "object" ? (i = u.rule({ selector: e2 }), s2(r2, i), t8.push(i)) : l2(t8, e2, r2);
  }
  return $n3 = function(c2) {
    let t8 = u.root();
    return s2(c2, t8), t8;
  }, $n3;
}
var Un3;
var bo2;
function eu3() {
  if (bo2) return Un3;
  bo2 = 1;
  let u = Zl();
  return Un3 = function(h7) {
    return console && console.warn && h7.warnings().forEach((p) => {
      let l2 = p.plugin || "PostCSS";
      console.warn(l2 + ": " + p.text);
    }), u(h7.root);
  }, Un3;
}
var zn3;
var _o2;
function xf() {
  if (_o2) return zn3;
  _o2 = 1;
  let u = Be2(), a = eu3(), h7 = Qi2();
  return zn3 = function(l2) {
    let f = u(l2);
    return async (s2) => {
      let c2 = await f.process(s2, {
        parser: h7,
        from: void 0
      });
      return a(c2);
    };
  }, zn3;
}
var Wn3;
var So2;
function Of() {
  if (So2) return Wn3;
  So2 = 1;
  let u = Be2(), a = eu3(), h7 = Qi2();
  return Wn3 = function(p) {
    let l2 = u(p);
    return (f) => {
      let s2 = l2.process(f, { parser: h7, from: void 0 });
      return a(s2);
    };
  }, Wn3;
}
var Vn3;
var xo2;
function kf() {
  if (xo2) return Vn3;
  xo2 = 1;
  let u = Zl(), a = Qi2(), h7 = xf(), p = Of();
  return Vn3 = {
    objectify: u,
    parse: a,
    async: h7,
    sync: p
  }, Vn3;
}
var Oo3;
function tu3() {
  return Oo3 || (Oo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = l2(Be2()), h7 = l2(_f()), p = l2(kf());
    function l2(s2) {
      return s2 && s2.__esModule ? s2 : {
        default: s2
      };
    }
    function f(s2) {
      return Array.isArray(s2) ? s2.flatMap((c2) => (0, a.default)([
        (0, h7.default)({
          bubble: [
            "screen"
          ]
        })
      ]).process(c2, {
        parser: p.default
      }).root.nodes) : f([
        s2
      ]);
    }
  }(Ln3)), Ln3;
}
var jn3 = {};
var ko2;
function Hi2() {
  return ko2 || (ko2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(
      u,
      /**
      * @template {string | import('postcss-selector-parser').Root} T
      *
      * Prefix all classes in the selector with the given prefix
      *
      * It can take either a string or a selector AST and will return the same type
      *
      * @param {string} prefix
      * @param {T} selector
      * @param {boolean} prependNegative
      * @returns {T}
      */
      "default",
      {
        enumerable: true,
        get: function() {
          return p;
        }
      }
    );
    const a = h7(Ke3());
    function h7(l2) {
      return l2 && l2.__esModule ? l2 : {
        default: l2
      };
    }
    function p(l2, f, s2 = false) {
      if (l2 === "")
        return f;
      let c2 = typeof f == "string" ? (0, a.default)().astSync(f) : f;
      return c2.walkClasses((t8) => {
        let e2 = t8.value, r2 = s2 && e2.startsWith("-");
        t8.value = r2 ? `-${l2}${e2.slice(1)}` : `${l2}${e2}`;
      }), typeof f == "string" ? c2.toString() : c2;
    }
  }(jn3)), jn3;
}
var Bn3 = {};
var Po2;
function yr3() {
  return Po2 || (Po2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(r2, i) {
      for (var o2 in i) Object.defineProperty(r2, o2, {
        enumerable: true,
        get: i[o2]
      });
    }
    a(u, {
      env: function() {
        return h7;
      },
      contextMap: function() {
        return p;
      },
      configContextMap: function() {
        return l2;
      },
      contextSourcesMap: function() {
        return f;
      },
      sourceHashMap: function() {
        return s2;
      },
      NOT_ON_DEMAND: function() {
        return c2;
      },
      NONE: function() {
        return t8;
      },
      resolveDebug: function() {
        return e2;
      }
    });
    const h7 = typeof process < "u" ? {
      NODE_ENV: "development",
      DEBUG: e2(process.env.DEBUG)
    } : {
      NODE_ENV: "production",
      DEBUG: false
    }, p = /* @__PURE__ */ new Map(), l2 = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map(), c2 = new String("*"), t8 = Symbol("__NONE__");
    function e2(r2) {
      if (r2 === void 0)
        return false;
      if (r2 === "true" || r2 === "1")
        return true;
      if (r2 === "false" || r2 === "0")
        return false;
      if (r2 === "*")
        return true;
      let i = r2.split(",").map((o2) => o2.split(":")[0]);
      return i.includes("-tailwindcss") ? false : !!i.includes("tailwindcss");
    }
  }(Bn3)), Bn3;
}
var Gn3 = {};
var Yn3 = {};
var Eo2;
function ft3() {
  return Eo2 || (Eo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(Ke3()), h7 = p(Vi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      var s2;
      let c2 = a.default.className();
      c2.value = f;
      var t8;
      return (0, h7.default)((t8 = c2 == null || (s2 = c2.raws) === null || s2 === void 0 ? void 0 : s2.value) !== null && t8 !== void 0 ? t8 : c2.value);
    }
  }(Yn3)), Yn3;
}
var Qn3 = {};
var To2;
function Ji2() {
  return To2 || (To2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "movePseudos", {
      enumerable: true,
      get: function() {
        return h7;
      }
    });
    let a = {
      // Pseudo elements from the spec
      "::after": [
        "terminal",
        "jumpable"
      ],
      "::backdrop": [
        "terminal",
        "jumpable"
      ],
      "::before": [
        "terminal",
        "jumpable"
      ],
      "::cue": [
        "terminal"
      ],
      "::cue-region": [
        "terminal"
      ],
      "::first-letter": [
        "terminal",
        "jumpable"
      ],
      "::first-line": [
        "terminal",
        "jumpable"
      ],
      "::grammar-error": [
        "terminal"
      ],
      "::marker": [
        "terminal",
        "jumpable"
      ],
      "::part": [
        "terminal",
        "actionable"
      ],
      "::placeholder": [
        "terminal",
        "jumpable"
      ],
      "::selection": [
        "terminal",
        "jumpable"
      ],
      "::slotted": [
        "terminal"
      ],
      "::spelling-error": [
        "terminal"
      ],
      "::target-text": [
        "terminal"
      ],
      // Pseudo elements from the spec with special rules
      "::file-selector-button": [
        "terminal",
        "actionable"
      ],
      // Library-specific pseudo elements used by component libraries
      // These are Shadow DOM-like
      "::deep": [
        "actionable"
      ],
      "::v-deep": [
        "actionable"
      ],
      "::ng-deep": [
        "actionable"
      ],
      // Note: As a rule, double colons (::) should be used instead of a single colon
      // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
      // this distinction was not present in older versions of the W3C spec, most
      // browsers support both syntaxes for the original pseudo-elements.
      ":after": [
        "terminal",
        "jumpable"
      ],
      ":before": [
        "terminal",
        "jumpable"
      ],
      ":first-letter": [
        "terminal",
        "jumpable"
      ],
      ":first-line": [
        "terminal",
        "jumpable"
      ],
      ":where": [],
      ":is": [],
      ":has": [],
      // The default value is used when the pseudo-element is not recognized
      // Because it's not recognized, we don't know if it's terminal or not
      // So we assume it can be moved AND can have user-action pseudo classes attached to it
      __default__: [
        "terminal",
        "actionable"
      ]
    };
    function h7(t8) {
      let [e2] = p(t8);
      return e2.forEach(([r2, i]) => r2.removeChild(i)), t8.nodes.push(...e2.map(([, r2]) => r2)), t8;
    }
    function p(t8) {
      let e2 = [], r2 = null;
      for (let o2 of t8.nodes)
        if (o2.type === "combinator")
          e2 = e2.filter(([, v3]) => c2(v3).includes("jumpable")), r2 = null;
        else if (o2.type === "pseudo") {
          f(o2) ? (r2 = o2, e2.push([
            t8,
            o2,
            null
          ])) : r2 && s2(o2, r2) ? e2.push([
            t8,
            o2,
            r2
          ]) : r2 = null;
          var i;
          for (let v3 of (i = o2.nodes) !== null && i !== void 0 ? i : []) {
            let [m, n2] = p(v3);
            r2 = n2 || r2, e2.push(...m);
          }
        }
      return [
        e2,
        r2
      ];
    }
    function l2(t8) {
      return t8.value.startsWith("::") || a[t8.value] !== void 0;
    }
    function f(t8) {
      return l2(t8) && c2(t8).includes("terminal");
    }
    function s2(t8, e2) {
      return t8.type !== "pseudo" || l2(t8) ? false : c2(e2).includes("actionable");
    }
    function c2(t8) {
      var e2;
      return (e2 = a[t8.value]) !== null && e2 !== void 0 ? e2 : a.__default__;
    }
  }(Qn3)), Qn3;
}
var Ao2;
function ru3() {
  return Ao2 || (Ao2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(d2, _3) {
      for (var w3 in _3) Object.defineProperty(d2, w3, {
        enumerable: true,
        get: _3[w3]
      });
    }
    a(u, {
      formatVariantSelector: function() {
        return r2;
      },
      eliminateIrrelevantSelectors: function() {
        return v3;
      },
      finalizeSelector: function() {
        return m;
      },
      handleMergePseudo: function() {
        return n2;
      }
    });
    const h7 = t8(Ke3()), p = t8(Bi2()), l2 = t8(ft3()), f = t8(Hi2()), s2 = Ji2(), c2 = st3();
    function t8(d2) {
      return d2 && d2.__esModule ? d2 : {
        default: d2
      };
    }
    let e2 = ":merge";
    function r2(d2, { context: _3, candidate: w3 }) {
      var y2;
      let x = (y2 = _3 == null ? void 0 : _3.tailwindConfig.prefix) !== null && y2 !== void 0 ? y2 : "", g2 = d2.map((A) => {
        let E2 = (0, h7.default)().astSync(A.format);
        return {
          ...A,
          ast: A.respectPrefix ? (0, f.default)(x, E2) : E2
        };
      }), O3 = h7.default.root({
        nodes: [
          h7.default.selector({
            nodes: [
              h7.default.className({
                value: (0, l2.default)(w3)
              })
            ]
          })
        ]
      });
      for (let { ast: A } of g2)
        [O3, A] = n2(O3, A), A.walkNesting((E2) => E2.replaceWith(...O3.nodes[0].nodes)), O3 = A;
      return O3;
    }
    function i(d2) {
      let _3 = [];
      for (; d2.prev() && d2.prev().type !== "combinator"; )
        d2 = d2.prev();
      for (; d2 && d2.type !== "combinator"; )
        _3.push(d2), d2 = d2.next();
      return _3;
    }
    function o2(d2) {
      return d2.sort((_3, w3) => _3.type === "tag" && w3.type === "class" ? -1 : _3.type === "class" && w3.type === "tag" ? 1 : _3.type === "class" && w3.type === "pseudo" && w3.value.startsWith("::") ? -1 : _3.type === "pseudo" && _3.value.startsWith("::") && w3.type === "class" ? 1 : d2.index(_3) - d2.index(w3)), d2;
    }
    function v3(d2, _3) {
      let w3 = false;
      d2.walk((y2) => {
        if (y2.type === "class" && y2.value === _3)
          return w3 = true, false;
      }), w3 || d2.remove();
    }
    function m(d2, _3, { context: w3, candidate: y2, base: x }) {
      var g2, O3;
      let A = (O3 = w3 == null || (g2 = w3.tailwindConfig) === null || g2 === void 0 ? void 0 : g2.separator) !== null && O3 !== void 0 ? O3 : ":";
      x = x ?? (0, c2.splitAtTopLevelOnly)(y2, A).pop();
      let E2 = (0, h7.default)().astSync(d2);
      if (E2.walkClasses((M2) => {
        M2.raws && M2.value.includes(x) && (M2.raws.value = (0, l2.default)((0, p.default)(M2.raws.value)));
      }), E2.each((M2) => v3(M2, x)), E2.length === 0)
        return null;
      let b3 = Array.isArray(_3) ? r2(_3, {
        context: w3,
        candidate: y2
      }) : _3;
      if (b3 === null)
        return E2.toString();
      let k3 = h7.default.comment({
        value: "/*__simple__*/"
      }), q2 = h7.default.comment({
        value: "/*__simple__*/"
      });
      return E2.walkClasses((M2) => {
        if (M2.value !== x)
          return;
        let W3 = M2.parent, S3 = b3.nodes[0].nodes;
        if (W3.nodes.length === 1) {
          M2.replaceWith(...S3);
          return;
        }
        let P3 = i(M2);
        W3.insertBefore(P3[0], k3), W3.insertAfter(P3[P3.length - 1], q2);
        for (let R3 of S3)
          W3.insertBefore(P3[0], R3.clone());
        M2.remove(), P3 = i(k3);
        let C = W3.index(k3);
        W3.nodes.splice(C, P3.length, ...o2(h7.default.selector({
          nodes: P3
        })).nodes), k3.remove(), q2.remove();
      }), E2.walkPseudos((M2) => {
        M2.value === e2 && M2.replaceWith(M2.nodes);
      }), E2.each((M2) => (0, s2.movePseudos)(M2)), E2.toString();
    }
    function n2(d2, _3) {
      let w3 = [];
      return d2.walkPseudos((y2) => {
        y2.value === e2 && w3.push({
          pseudo: y2,
          value: y2.nodes[0].toString()
        });
      }), _3.walkPseudos((y2) => {
        if (y2.value !== e2)
          return;
        let x = y2.nodes[0].toString(), g2 = w3.find((b3) => b3.value === x);
        if (!g2)
          return;
        let O3 = [], A = y2.next();
        for (; A && A.type !== "combinator"; )
          O3.push(A), A = A.next();
        let E2 = A;
        g2.pseudo.parent.insertAfter(g2.pseudo, h7.default.selector({
          nodes: O3.map((b3) => b3.clone())
        })), y2.remove(), O3.forEach((b3) => b3.remove()), E2 && E2.type === "combinator" && E2.remove();
      }), [
        d2,
        _3
      ];
    }
  }(Gn3)), Gn3;
}
var Hn3 = {};
var Co;
function nu3() {
  return Co || (Co = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      asClass: function() {
        return f;
      },
      default: function() {
        return s2;
      },
      formatClass: function() {
        return c2;
      }
    });
    const h7 = l2(ft3()), p = l2(Vi2());
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    function f(t8) {
      return (0, p.default)(`.${(0, h7.default)(t8)}`);
    }
    function s2(t8, e2) {
      return f(c2(t8, e2));
    }
    function c2(t8, e2) {
      return e2 === "DEFAULT" ? t8 : e2 === "-" || e2 === "-DEFAULT" ? `-${t8}` : e2.startsWith("-") ? `-${t8}${e2}` : e2.startsWith("/") ? `${t8}${e2}` : `${t8}-${e2}`;
    }
  }(Hn3)), Hn3;
}
var Jn3 = {};
var Kn3 = {};
var Xn3 = {};
var Ro3;
function Pf() {
  return Ro3 || (Ro3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = h7(pr3());
    function h7(l2) {
      return l2 && l2.__esModule ? l2 : {
        default: l2
      };
    }
    function p(l2, f = [
      [
        l2,
        [
          l2
        ]
      ]
    ], { filterDefault: s2 = false, ...c2 } = {}) {
      let t8 = (0, a.default)(l2);
      return function({ matchUtilities: e2, theme: r2 }) {
        for (let o2 of f) {
          let v3 = Array.isArray(o2[0]) ? o2 : [
            o2
          ];
          var i;
          e2(v3.reduce((m, [n2, d2]) => Object.assign(m, {
            [n2]: (_3) => d2.reduce((w3, y2) => Array.isArray(y2) ? Object.assign(w3, {
              [y2[0]]: y2[1]
            }) : Object.assign(w3, {
              [y2]: t8(_3)
            }), {})
          }), {}), {
            ...c2,
            values: s2 ? Object.fromEntries(Object.entries((i = r2(l2)) !== null && i !== void 0 ? i : {}).filter(([m]) => m !== "DEFAULT")) : r2(l2)
          });
        }
      };
    }
  }(Xn3)), Xn3;
}
var Zn3 = {};
var Io3;
function Ef() {
  return Io3 || (Io3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return i;
      }
    });
    const a = /* @__PURE__ */ new Set([
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]), h7 = /* @__PURE__ */ new Set([
      "running",
      "paused"
    ]), p = /* @__PURE__ */ new Set([
      "none",
      "forwards",
      "backwards",
      "both"
    ]), l2 = /* @__PURE__ */ new Set([
      "infinite"
    ]), f = /* @__PURE__ */ new Set([
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "step-start",
      "step-end"
    ]), s2 = [
      "cubic-bezier",
      "steps"
    ], c2 = /\,(?![^(]*\))/g, t8 = /\ +(?![^(]*\))/g, e2 = /^(-?[\d.]+m?s)$/, r2 = /^(\d+)$/;
    function i(o2) {
      return o2.split(c2).map((m) => {
        let n2 = m.trim(), d2 = {
          value: n2
        }, _3 = n2.split(t8), w3 = /* @__PURE__ */ new Set();
        for (let y2 of _3)
          !w3.has("DIRECTIONS") && a.has(y2) ? (d2.direction = y2, w3.add("DIRECTIONS")) : !w3.has("PLAY_STATES") && h7.has(y2) ? (d2.playState = y2, w3.add("PLAY_STATES")) : !w3.has("FILL_MODES") && p.has(y2) ? (d2.fillMode = y2, w3.add("FILL_MODES")) : !w3.has("ITERATION_COUNTS") && (l2.has(y2) || r2.test(y2)) ? (d2.iterationCount = y2, w3.add("ITERATION_COUNTS")) : !w3.has("TIMING_FUNCTION") && f.has(y2) || !w3.has("TIMING_FUNCTION") && s2.some((x) => y2.startsWith(`${x}(`)) ? (d2.timingFunction = y2, w3.add("TIMING_FUNCTION")) : !w3.has("DURATION") && e2.test(y2) ? (d2.duration = y2, w3.add("DURATION")) : !w3.has("DELAY") && e2.test(y2) ? (d2.delay = y2, w3.add("DELAY")) : w3.has("NAME") ? (d2.unknown || (d2.unknown = []), d2.unknown.push(y2)) : (d2.name = y2, w3.add("NAME"));
        return d2;
      });
    }
  }(Zn3)), Zn3;
}
var ei2 = {};
var Mo3;
function Tf() {
  return Mo3 || (Mo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h7;
      }
    });
    const a = (p) => Object.assign({}, ...Object.entries(p ?? {}).flatMap(([l2, f]) => typeof f == "object" ? Object.entries(a(f)).map(([s2, c2]) => ({
      [l2 + (s2 === "DEFAULT" ? "" : `-${s2}`)]: c2
    })) : [
      {
        [`${l2}`]: f
      }
    ])), h7 = a;
  }(ei2)), ei2;
}
var ti3 = {};
var Do2;
function iu3() {
  return Do2 || (Do2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      return typeof h7 == "function" ? h7({}) : h7;
    }
  }(ti3)), ti3;
}
var Af = "3.4.10";
var Cf = {
  version: Af
};
var ri3 = {};
var qo3;
function Rf() {
  return qo3 || (qo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "removeAlphaVariables", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7, p) {
      h7.walkDecls((l2) => {
        if (p.includes(l2.prop)) {
          l2.remove();
          return;
        }
        for (let f of p)
          l2.value.includes(`/ var(${f})`) && (l2.value = l2.value.replace(`/ var(${f})`, ""));
      });
    }
  }(ri3)), ri3;
}
var Lo;
function If() {
  return Lo || (Lo = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(S3, P3) {
      for (var C in P3) Object.defineProperty(S3, C, {
        enumerable: true,
        get: P3[C]
      });
    }
    a(u, {
      variantPlugins: function() {
        return b3;
      },
      corePlugins: function() {
        return W3;
      }
    });
    const h7 = O3(Ne3), p = E2(Ne3), l2 = O3(Be2()), f = O3(Pf()), s2 = O3(zi2()), c2 = O3(ft3()), t8 = O3(Ef()), e2 = O3(Tf()), r2 = E2(hr3()), i = O3(iu3()), o2 = O3(ut3()), v3 = O3(pr3()), m = Cf, n2 = O3(tt3()), d2 = Ui2(), _3 = $l(), w3 = Rf(), y2 = it3(), x = vr3(), g2 = Ki2();
    function O3(S3) {
      return S3 && S3.__esModule ? S3 : {
        default: S3
      };
    }
    function A(S3) {
      if (typeof WeakMap != "function") return null;
      var P3 = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
      return (A = function(R3) {
        return R3 ? C : P3;
      })(S3);
    }
    function E2(S3, P3) {
      if (S3 && S3.__esModule)
        return S3;
      if (S3 === null || typeof S3 != "object" && typeof S3 != "function")
        return {
          default: S3
        };
      var C = A(P3);
      if (C && C.has(S3))
        return C.get(S3);
      var R3 = {}, $2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var B3 in S3)
        if (B3 !== "default" && Object.prototype.hasOwnProperty.call(S3, B3)) {
          var z3 = $2 ? Object.getOwnPropertyDescriptor(S3, B3) : null;
          z3 && (z3.get || z3.set) ? Object.defineProperty(R3, B3, z3) : R3[B3] = S3[B3];
        }
      return R3.default = S3, C && C.set(S3, R3), R3;
    }
    let b3 = {
      childVariant: ({ addVariant: S3 }) => {
        S3("*", "& > *");
      },
      pseudoElementVariants: ({ addVariant: S3 }) => {
        S3("first-letter", "&::first-letter"), S3("first-line", "&::first-line"), S3("marker", [
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "& *::marker"),
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "&::marker")
        ]), S3("selection", [
          "& *::selection",
          "&::selection"
        ]), S3("file", "&::file-selector-button"), S3("placeholder", "&::placeholder"), S3("backdrop", "&::backdrop"), S3("before", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l2.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::before")), S3("after", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l2.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::after"));
      },
      pseudoClassVariants: ({ addVariant: S3, matchVariant: P3, config: C, prefix: R3 }) => {
        let $2 = [
          // Positional
          [
            "first",
            "&:first-child"
          ],
          [
            "last",
            "&:last-child"
          ],
          [
            "only",
            "&:only-child"
          ],
          [
            "odd",
            "&:nth-child(odd)"
          ],
          [
            "even",
            "&:nth-child(even)"
          ],
          "first-of-type",
          "last-of-type",
          "only-of-type",
          // State
          [
            "visited",
            ({ container: z3 }) => ((0, w3.removeAlphaVariables)(z3, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]), "&:visited")
          ],
          "target",
          [
            "open",
            "&[open]"
          ],
          // Forms
          "default",
          "checked",
          "indeterminate",
          "placeholder-shown",
          "autofill",
          "optional",
          "required",
          "valid",
          "invalid",
          "in-range",
          "out-of-range",
          "read-only",
          // Content
          "empty",
          // Interactive
          "focus-within",
          [
            "hover",
            (0, y2.flagEnabled)(C(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
          ],
          "focus",
          "focus-visible",
          "active",
          "enabled",
          "disabled"
        ].map((z3) => Array.isArray(z3) ? z3 : [
          z3,
          `&:${z3}`
        ]);
        for (let [z3, L3] of $2)
          S3(z3, (F) => typeof L3 == "function" ? L3(F) : L3);
        let B3 = {
          group: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".group")}\\/${(0, c2.default)(L3)})`,
            " &"
          ] : [
            `:merge(${R3(".group")})`,
            " &"
          ],
          peer: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".peer")}\\/${(0, c2.default)(L3)})`,
            " ~ &"
          ] : [
            `:merge(${R3(".peer")})`,
            " ~ &"
          ]
        };
        for (let [z3, L3] of Object.entries(B3))
          P3(z3, (F = "", D) => {
            let I3 = (0, x.normalize)(typeof F == "function" ? F(D) : F);
            I3.includes("&") || (I3 = "&" + I3);
            let [N3, J3] = L3("", D), T3 = null, U2 = null, j3 = 0;
            for (let H3 = 0; H3 < I3.length; ++H3) {
              let V4 = I3[H3];
              V4 === "&" ? T3 = H3 : V4 === "'" || V4 === '"' ? j3 += 1 : T3 !== null && V4 === " " && !j3 && (U2 = H3);
            }
            return T3 !== null && U2 === null && (U2 = I3.length), I3.slice(0, T3) + N3 + I3.slice(T3 + 1, U2) + J3 + I3.slice(U2);
          }, {
            values: Object.fromEntries($2),
            [g2.INTERNAL_FEATURES]: {
              respectPrefix: false
            }
          });
      },
      directionVariants: ({ addVariant: S3 }) => {
        S3("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), S3("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
      },
      reducedMotionVariants: ({ addVariant: S3 }) => {
        S3("motion-safe", "@media (prefers-reduced-motion: no-preference)"), S3("motion-reduce", "@media (prefers-reduced-motion: reduce)");
      },
      darkVariants: ({ config: S3, addVariant: P3 }) => {
        let [C, R3 = ".dark"] = [].concat(S3("darkMode", "media"));
        if (C === false && (C = "media", n2.default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ])), C === "variant") {
          let $2;
          if (Array.isArray(R3) || typeof R3 == "function" ? $2 = R3 : typeof R3 == "string" && ($2 = [
            R3
          ]), Array.isArray($2))
            for (let B3 of $2)
              B3 === ".dark" ? (C = false, n2.default.warn("darkmode-variant-without-selector", [
                "When using `variant` for `darkMode`, you must provide a selector.",
                'Example: `darkMode: ["variant", ".your-selector &"]`'
              ])) : B3.includes("&") || (C = false, n2.default.warn("darkmode-variant-without-ampersand", [
                "When using `variant` for `darkMode`, your selector must contain `&`.",
                'Example `darkMode: ["variant", ".your-selector &"]`'
              ]));
          R3 = $2;
        }
        C === "selector" ? P3("dark", `&:where(${R3}, ${R3} *)`) : C === "media" ? P3("dark", "@media (prefers-color-scheme: dark)") : C === "variant" ? P3("dark", R3) : C === "class" && P3("dark", `&:is(${R3} *)`);
      },
      printVariant: ({ addVariant: S3 }) => {
        S3("print", "@media print");
      },
      screenVariants: ({ theme: S3, addVariant: P3, matchVariant: C }) => {
        var R3;
        let $2 = (R3 = S3("screens")) !== null && R3 !== void 0 ? R3 : {}, B3 = Object.values($2).every((K3) => typeof K3 == "string"), z3 = (0, d2.normalizeScreens)(S3("screens")), L3 = /* @__PURE__ */ new Set([]);
        function F(K3) {
          var X3, Q3;
          return (Q3 = (X3 = K3.match(/(\D+)$/)) === null || X3 === void 0 ? void 0 : X3[1]) !== null && Q3 !== void 0 ? Q3 : "(none)";
        }
        function D(K3) {
          K3 !== void 0 && L3.add(F(K3));
        }
        function I3(K3) {
          return D(K3), L3.size === 1;
        }
        for (const K3 of z3)
          for (const X3 of K3.values)
            D(X3.min), D(X3.max);
        let N3 = L3.size <= 1;
        function J3(K3) {
          return Object.fromEntries(z3.filter((X3) => (0, d2.isScreenSortable)(X3).result).map((X3) => {
            let { min: Q3, max: ne3 } = X3.values[0];
            if (ne3 !== void 0)
              return X3;
            if (Q3 !== void 0)
              return {
                ...X3,
                not: !X3.not
              };
          }).map((X3) => [
            X3.name,
            X3
          ]));
        }
        function T3(K3) {
          return (X3, Q3) => (0, d2.compareScreens)(K3, X3.value, Q3.value);
        }
        let U2 = T3("max"), j3 = T3("min");
        function H3(K3) {
          return (X3) => {
            if (B3)
              if (N3) {
                if (typeof X3 == "string" && !I3(X3))
                  return n2.default.warn("minmax-have-mixed-units", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                  ]), [];
              } else return n2.default.warn("mixed-screen-units", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
              ]), [];
            else return n2.default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]), [];
            return [
              `@media ${(0, s2.default)((0, d2.toScreen)(X3, K3))}`
            ];
          };
        }
        C("max", H3("max"), {
          sort: U2,
          values: B3 ? J3() : {}
        });
        let V4 = "min-screens";
        for (let K3 of z3)
          P3(K3.name, `@media ${(0, s2.default)(K3)}`, {
            id: V4,
            sort: B3 && N3 ? j3 : void 0,
            value: K3
          });
        C("min", H3("min"), {
          id: V4,
          sort: j3
        });
      },
      supportsVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("supports", (R3 = "") => {
          let $2 = (0, x.normalize)(R3), B3 = /^\w*\s*\(/.test($2);
          return $2 = B3 ? $2.replace(/\b(and|or|not)\b/g, " $1 ") : $2, B3 ? `@supports ${$2}` : ($2.includes(":") || ($2 = `${$2}: var(--tw)`), $2.startsWith("(") && $2.endsWith(")") || ($2 = `(${$2})`), `@supports ${$2}`);
        }, {
          values: (C = P3("supports")) !== null && C !== void 0 ? C : {}
        });
      },
      hasVariants: ({ matchVariant: S3, prefix: P3 }) => {
        S3("has", (C) => `&:has(${(0, x.normalize)(C)})`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("group-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".group")}\\/${R3}):has(${(0, x.normalize)(C)}) &` : `:merge(${P3(".group")}):has(${(0, x.normalize)(C)}) &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("peer-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".peer")}\\/${R3}):has(${(0, x.normalize)(C)}) ~ &` : `:merge(${P3(".peer")}):has(${(0, x.normalize)(C)}) ~ &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        });
      },
      ariaVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("aria", (B3) => `&[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}]`, {
          values: (C = P3("aria")) !== null && C !== void 0 ? C : {}
        });
        var R3;
        S3("group-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &` : `:merge(.group)[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &`, {
          values: (R3 = P3("aria")) !== null && R3 !== void 0 ? R3 : {}
        });
        var $2;
        S3("peer-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &` : `:merge(.peer)[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &`, {
          values: ($2 = P3("aria")) !== null && $2 !== void 0 ? $2 : {}
        });
      },
      dataVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("data", (B3) => `&[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}]`, {
          values: (C = P3("data")) !== null && C !== void 0 ? C : {}
        });
        var R3;
        S3("group-data", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &` : `:merge(.group)[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &`, {
          values: (R3 = P3("data")) !== null && R3 !== void 0 ? R3 : {}
        });
        var $2;
        S3("peer-data", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &` : `:merge(.peer)[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &`, {
          values: ($2 = P3("data")) !== null && $2 !== void 0 ? $2 : {}
        });
      },
      orientationVariants: ({ addVariant: S3 }) => {
        S3("portrait", "@media (orientation: portrait)"), S3("landscape", "@media (orientation: landscape)");
      },
      prefersContrastVariants: ({ addVariant: S3 }) => {
        S3("contrast-more", "@media (prefers-contrast: more)"), S3("contrast-less", "@media (prefers-contrast: less)");
      },
      forcedColorsVariants: ({ addVariant: S3 }) => {
        S3("forced-colors", "@media (forced-colors: active)");
      }
    }, k3 = [
      "translate(var(--tw-translate-x), var(--tw-translate-y))",
      "rotate(var(--tw-rotate))",
      "skewX(var(--tw-skew-x))",
      "skewY(var(--tw-skew-y))",
      "scaleX(var(--tw-scale-x))",
      "scaleY(var(--tw-scale-y))"
    ].join(" "), q2 = [
      "var(--tw-blur)",
      "var(--tw-brightness)",
      "var(--tw-contrast)",
      "var(--tw-grayscale)",
      "var(--tw-hue-rotate)",
      "var(--tw-invert)",
      "var(--tw-saturate)",
      "var(--tw-sepia)",
      "var(--tw-drop-shadow)"
    ].join(" "), M2 = [
      "var(--tw-backdrop-blur)",
      "var(--tw-backdrop-brightness)",
      "var(--tw-backdrop-contrast)",
      "var(--tw-backdrop-grayscale)",
      "var(--tw-backdrop-hue-rotate)",
      "var(--tw-backdrop-invert)",
      "var(--tw-backdrop-opacity)",
      "var(--tw-backdrop-saturate)",
      "var(--tw-backdrop-sepia)"
    ].join(" "), W3 = {
      preflight: ({ addBase: S3 }) => {
        let P3 = l2.default.parse(h7.default.readFileSync(p.join(__dirname, "./css/preflight.css"), "utf8"));
        S3([
          l2.default.comment({
            text: `! tailwindcss v${m.version} | MIT License | https://tailwindcss.com`
          }),
          ...P3.nodes
        ]);
      },
      container: /* @__PURE__ */ (() => {
        function S3(C = []) {
          return C.flatMap((R3) => R3.values.map(($2) => $2.min)).filter((R3) => R3 !== void 0);
        }
        function P3(C, R3, $2) {
          if (typeof $2 > "u")
            return [];
          if (!(typeof $2 == "object" && $2 !== null))
            return [
              {
                screen: "DEFAULT",
                minWidth: 0,
                padding: $2
              }
            ];
          let B3 = [];
          $2.DEFAULT && B3.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: $2.DEFAULT
          });
          for (let z3 of C)
            for (let L3 of R3)
              for (let { min: F } of L3.values)
                F === z3 && B3.push({
                  minWidth: z3,
                  padding: $2[L3.name]
                });
          return B3;
        }
        return function({ addComponents: C, theme: R3 }) {
          let $2 = (0, d2.normalizeScreens)(R3("container.screens", R3("screens"))), B3 = S3($2), z3 = P3(B3, $2, R3("container.padding")), L3 = (D) => {
            let I3 = z3.find((N3) => N3.minWidth === D);
            return I3 ? {
              paddingRight: I3.padding,
              paddingLeft: I3.padding
            } : {};
          }, F = Array.from(new Set(B3.slice().sort((D, I3) => parseInt(D) - parseInt(I3)))).map((D) => ({
            [`@media (min-width: ${D})`]: {
              ".container": {
                "max-width": D,
                ...L3(D)
              }
            }
          }));
          C([
            {
              ".container": Object.assign({
                width: "100%"
              }, R3("container.center", false) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, L3(0))
            },
            ...F
          ]);
        };
      })(),
      accessibility: ({ addUtilities: S3 }) => {
        S3({
          ".sr-only": {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: "0",
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0"
          },
          ".not-sr-only": {
            position: "static",
            width: "auto",
            height: "auto",
            padding: "0",
            margin: "0",
            overflow: "visible",
            clip: "auto",
            whiteSpace: "normal"
          }
        });
      },
      pointerEvents: ({ addUtilities: S3 }) => {
        S3({
          ".pointer-events-none": {
            "pointer-events": "none"
          },
          ".pointer-events-auto": {
            "pointer-events": "auto"
          }
        });
      },
      visibility: ({ addUtilities: S3 }) => {
        S3({
          ".visible": {
            visibility: "visible"
          },
          ".invisible": {
            visibility: "hidden"
          },
          ".collapse": {
            visibility: "collapse"
          }
        });
      },
      position: ({ addUtilities: S3 }) => {
        S3({
          ".static": {
            position: "static"
          },
          ".fixed": {
            position: "fixed"
          },
          ".absolute": {
            position: "absolute"
          },
          ".relative": {
            position: "relative"
          },
          ".sticky": {
            position: "sticky"
          }
        });
      },
      inset: (0, f.default)("inset", [
        [
          "inset",
          [
            "inset"
          ]
        ],
        [
          [
            "inset-x",
            [
              "left",
              "right"
            ]
          ],
          [
            "inset-y",
            [
              "top",
              "bottom"
            ]
          ]
        ],
        [
          [
            "start",
            [
              "inset-inline-start"
            ]
          ],
          [
            "end",
            [
              "inset-inline-end"
            ]
          ],
          [
            "top",
            [
              "top"
            ]
          ],
          [
            "right",
            [
              "right"
            ]
          ],
          [
            "bottom",
            [
              "bottom"
            ]
          ],
          [
            "left",
            [
              "left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      isolation: ({ addUtilities: S3 }) => {
        S3({
          ".isolate": {
            isolation: "isolate"
          },
          ".isolation-auto": {
            isolation: "auto"
          }
        });
      },
      zIndex: (0, f.default)("zIndex", [
        [
          "z",
          [
            "zIndex"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      order: (0, f.default)("order", void 0, {
        supportsNegativeValues: true
      }),
      gridColumn: (0, f.default)("gridColumn", [
        [
          "col",
          [
            "gridColumn"
          ]
        ]
      ]),
      gridColumnStart: (0, f.default)("gridColumnStart", [
        [
          "col-start",
          [
            "gridColumnStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridColumnEnd: (0, f.default)("gridColumnEnd", [
        [
          "col-end",
          [
            "gridColumnEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRow: (0, f.default)("gridRow", [
        [
          "row",
          [
            "gridRow"
          ]
        ]
      ]),
      gridRowStart: (0, f.default)("gridRowStart", [
        [
          "row-start",
          [
            "gridRowStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRowEnd: (0, f.default)("gridRowEnd", [
        [
          "row-end",
          [
            "gridRowEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      float: ({ addUtilities: S3 }) => {
        S3({
          ".float-start": {
            float: "inline-start"
          },
          ".float-end": {
            float: "inline-end"
          },
          ".float-right": {
            float: "right"
          },
          ".float-left": {
            float: "left"
          },
          ".float-none": {
            float: "none"
          }
        });
      },
      clear: ({ addUtilities: S3 }) => {
        S3({
          ".clear-start": {
            clear: "inline-start"
          },
          ".clear-end": {
            clear: "inline-end"
          },
          ".clear-left": {
            clear: "left"
          },
          ".clear-right": {
            clear: "right"
          },
          ".clear-both": {
            clear: "both"
          },
          ".clear-none": {
            clear: "none"
          }
        });
      },
      margin: (0, f.default)("margin", [
        [
          "m",
          [
            "margin"
          ]
        ],
        [
          [
            "mx",
            [
              "margin-left",
              "margin-right"
            ]
          ],
          [
            "my",
            [
              "margin-top",
              "margin-bottom"
            ]
          ]
        ],
        [
          [
            "ms",
            [
              "margin-inline-start"
            ]
          ],
          [
            "me",
            [
              "margin-inline-end"
            ]
          ],
          [
            "mt",
            [
              "margin-top"
            ]
          ],
          [
            "mr",
            [
              "margin-right"
            ]
          ],
          [
            "mb",
            [
              "margin-bottom"
            ]
          ],
          [
            "ml",
            [
              "margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      boxSizing: ({ addUtilities: S3 }) => {
        S3({
          ".box-border": {
            "box-sizing": "border-box"
          },
          ".box-content": {
            "box-sizing": "content-box"
          }
        });
      },
      lineClamp: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "line-clamp": (R3) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${R3}`
          })
        }, {
          values: C("lineClamp")
        }), P3({
          ".line-clamp-none": {
            overflow: "visible",
            display: "block",
            "-webkit-box-orient": "horizontal",
            "-webkit-line-clamp": "none"
          }
        });
      },
      display: ({ addUtilities: S3 }) => {
        S3({
          ".block": {
            display: "block"
          },
          ".inline-block": {
            display: "inline-block"
          },
          ".inline": {
            display: "inline"
          },
          ".flex": {
            display: "flex"
          },
          ".inline-flex": {
            display: "inline-flex"
          },
          ".table": {
            display: "table"
          },
          ".inline-table": {
            display: "inline-table"
          },
          ".table-caption": {
            display: "table-caption"
          },
          ".table-cell": {
            display: "table-cell"
          },
          ".table-column": {
            display: "table-column"
          },
          ".table-column-group": {
            display: "table-column-group"
          },
          ".table-footer-group": {
            display: "table-footer-group"
          },
          ".table-header-group": {
            display: "table-header-group"
          },
          ".table-row-group": {
            display: "table-row-group"
          },
          ".table-row": {
            display: "table-row"
          },
          ".flow-root": {
            display: "flow-root"
          },
          ".grid": {
            display: "grid"
          },
          ".inline-grid": {
            display: "inline-grid"
          },
          ".contents": {
            display: "contents"
          },
          ".list-item": {
            display: "list-item"
          },
          ".hidden": {
            display: "none"
          }
        });
      },
      aspectRatio: (0, f.default)("aspectRatio", [
        [
          "aspect",
          [
            "aspect-ratio"
          ]
        ]
      ]),
      size: (0, f.default)("size", [
        [
          "size",
          [
            "width",
            "height"
          ]
        ]
      ]),
      height: (0, f.default)("height", [
        [
          "h",
          [
            "height"
          ]
        ]
      ]),
      maxHeight: (0, f.default)("maxHeight", [
        [
          "max-h",
          [
            "maxHeight"
          ]
        ]
      ]),
      minHeight: (0, f.default)("minHeight", [
        [
          "min-h",
          [
            "minHeight"
          ]
        ]
      ]),
      width: (0, f.default)("width", [
        [
          "w",
          [
            "width"
          ]
        ]
      ]),
      minWidth: (0, f.default)("minWidth", [
        [
          "min-w",
          [
            "minWidth"
          ]
        ]
      ]),
      maxWidth: (0, f.default)("maxWidth", [
        [
          "max-w",
          [
            "maxWidth"
          ]
        ]
      ]),
      flex: (0, f.default)("flex"),
      flexShrink: (0, f.default)("flexShrink", [
        [
          "flex-shrink",
          [
            "flex-shrink"
          ]
        ],
        [
          "shrink",
          [
            "flex-shrink"
          ]
        ]
      ]),
      flexGrow: (0, f.default)("flexGrow", [
        [
          "flex-grow",
          [
            "flex-grow"
          ]
        ],
        [
          "grow",
          [
            "flex-grow"
          ]
        ]
      ]),
      flexBasis: (0, f.default)("flexBasis", [
        [
          "basis",
          [
            "flex-basis"
          ]
        ]
      ]),
      tableLayout: ({ addUtilities: S3 }) => {
        S3({
          ".table-auto": {
            "table-layout": "auto"
          },
          ".table-fixed": {
            "table-layout": "fixed"
          }
        });
      },
      captionSide: ({ addUtilities: S3 }) => {
        S3({
          ".caption-top": {
            "caption-side": "top"
          },
          ".caption-bottom": {
            "caption-side": "bottom"
          }
        });
      },
      borderCollapse: ({ addUtilities: S3 }) => {
        S3({
          ".border-collapse": {
            "border-collapse": "collapse"
          },
          ".border-separate": {
            "border-collapse": "separate"
          }
        });
      },
      borderSpacing: ({ addDefaults: S3, matchUtilities: P3, theme: C }) => {
        S3("border-spacing", {
          "--tw-border-spacing-x": 0,
          "--tw-border-spacing-y": 0
        }), P3({
          "border-spacing": (R3) => ({
            "--tw-border-spacing-x": R3,
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-x": (R3) => ({
            "--tw-border-spacing-x": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-y": (R3) => ({
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          })
        }, {
          values: C("borderSpacing")
        });
      },
      transformOrigin: (0, f.default)("transformOrigin", [
        [
          "origin",
          [
            "transformOrigin"
          ]
        ]
      ]),
      translate: (0, f.default)("translate", [
        [
          [
            "translate-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "translate-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      rotate: (0, f.default)("rotate", [
        [
          "rotate",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-rotate",
            [
              "transform",
              k3
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      skew: (0, f.default)("skew", [
        [
          [
            "skew-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "skew-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scale: (0, f.default)("scale", [
        [
          "scale",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            "--tw-scale-y",
            [
              "transform",
              k3
            ]
          ]
        ],
        [
          [
            "scale-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "scale-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      transform: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("transform", {
          "--tw-translate-x": "0",
          "--tw-translate-y": "0",
          "--tw-rotate": "0",
          "--tw-skew-x": "0",
          "--tw-skew-y": "0",
          "--tw-scale-x": "1",
          "--tw-scale-y": "1"
        }), P3({
          ".transform": {
            "@defaults transform": {},
            transform: k3
          },
          ".transform-cpu": {
            transform: k3
          },
          ".transform-gpu": {
            transform: k3.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
          },
          ".transform-none": {
            transform: "none"
          }
        });
      },
      animation: ({ matchUtilities: S3, theme: P3, config: C }) => {
        let R3 = (z3) => (0, c2.default)(C("prefix") + z3);
        var $2;
        let B3 = Object.fromEntries(Object.entries(($2 = P3("keyframes")) !== null && $2 !== void 0 ? $2 : {}).map(([z3, L3]) => [
          z3,
          {
            [`@keyframes ${R3(z3)}`]: L3
          }
        ]));
        S3({
          animate: (z3) => {
            let L3 = (0, t8.default)(z3);
            return [
              ...L3.flatMap((F) => B3[F.name]),
              {
                animation: L3.map(({ name: F, value: D }) => F === void 0 || B3[F] === void 0 ? D : D.replace(F, R3(F))).join(", ")
              }
            ];
          }
        }, {
          values: P3("animation")
        });
      },
      cursor: (0, f.default)("cursor"),
      touchAction: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("touch-action", {
          "--tw-pan-x": " ",
          "--tw-pan-y": " ",
          "--tw-pinch-zoom": " "
        });
        let C = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        P3({
          ".touch-auto": {
            "touch-action": "auto"
          },
          ".touch-none": {
            "touch-action": "none"
          },
          ".touch-pan-x": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-x",
            "touch-action": C
          },
          ".touch-pan-left": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-left",
            "touch-action": C
          },
          ".touch-pan-right": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-right",
            "touch-action": C
          },
          ".touch-pan-y": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-y",
            "touch-action": C
          },
          ".touch-pan-up": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-up",
            "touch-action": C
          },
          ".touch-pan-down": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-down",
            "touch-action": C
          },
          ".touch-pinch-zoom": {
            "@defaults touch-action": {},
            "--tw-pinch-zoom": "pinch-zoom",
            "touch-action": C
          },
          ".touch-manipulation": {
            "touch-action": "manipulation"
          }
        });
      },
      userSelect: ({ addUtilities: S3 }) => {
        S3({
          ".select-none": {
            "user-select": "none"
          },
          ".select-text": {
            "user-select": "text"
          },
          ".select-all": {
            "user-select": "all"
          },
          ".select-auto": {
            "user-select": "auto"
          }
        });
      },
      resize: ({ addUtilities: S3 }) => {
        S3({
          ".resize-none": {
            resize: "none"
          },
          ".resize-y": {
            resize: "vertical"
          },
          ".resize-x": {
            resize: "horizontal"
          },
          ".resize": {
            resize: "both"
          }
        });
      },
      scrollSnapType: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("scroll-snap-type", {
          "--tw-scroll-snap-strictness": "proximity"
        }), P3({
          ".snap-none": {
            "scroll-snap-type": "none"
          },
          ".snap-x": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
          },
          ".snap-y": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
          },
          ".snap-both": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
          },
          ".snap-mandatory": {
            "--tw-scroll-snap-strictness": "mandatory"
          },
          ".snap-proximity": {
            "--tw-scroll-snap-strictness": "proximity"
          }
        });
      },
      scrollSnapAlign: ({ addUtilities: S3 }) => {
        S3({
          ".snap-start": {
            "scroll-snap-align": "start"
          },
          ".snap-end": {
            "scroll-snap-align": "end"
          },
          ".snap-center": {
            "scroll-snap-align": "center"
          },
          ".snap-align-none": {
            "scroll-snap-align": "none"
          }
        });
      },
      scrollSnapStop: ({ addUtilities: S3 }) => {
        S3({
          ".snap-normal": {
            "scroll-snap-stop": "normal"
          },
          ".snap-always": {
            "scroll-snap-stop": "always"
          }
        });
      },
      scrollMargin: (0, f.default)("scrollMargin", [
        [
          "scroll-m",
          [
            "scroll-margin"
          ]
        ],
        [
          [
            "scroll-mx",
            [
              "scroll-margin-left",
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-my",
            [
              "scroll-margin-top",
              "scroll-margin-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ms",
            [
              "scroll-margin-inline-start"
            ]
          ],
          [
            "scroll-me",
            [
              "scroll-margin-inline-end"
            ]
          ],
          [
            "scroll-mt",
            [
              "scroll-margin-top"
            ]
          ],
          [
            "scroll-mr",
            [
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-mb",
            [
              "scroll-margin-bottom"
            ]
          ],
          [
            "scroll-ml",
            [
              "scroll-margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scrollPadding: (0, f.default)("scrollPadding", [
        [
          "scroll-p",
          [
            "scroll-padding"
          ]
        ],
        [
          [
            "scroll-px",
            [
              "scroll-padding-left",
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-py",
            [
              "scroll-padding-top",
              "scroll-padding-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ps",
            [
              "scroll-padding-inline-start"
            ]
          ],
          [
            "scroll-pe",
            [
              "scroll-padding-inline-end"
            ]
          ],
          [
            "scroll-pt",
            [
              "scroll-padding-top"
            ]
          ],
          [
            "scroll-pr",
            [
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-pb",
            [
              "scroll-padding-bottom"
            ]
          ],
          [
            "scroll-pl",
            [
              "scroll-padding-left"
            ]
          ]
        ]
      ]),
      listStylePosition: ({ addUtilities: S3 }) => {
        S3({
          ".list-inside": {
            "list-style-position": "inside"
          },
          ".list-outside": {
            "list-style-position": "outside"
          }
        });
      },
      listStyleType: (0, f.default)("listStyleType", [
        [
          "list",
          [
            "listStyleType"
          ]
        ]
      ]),
      listStyleImage: (0, f.default)("listStyleImage", [
        [
          "list-image",
          [
            "listStyleImage"
          ]
        ]
      ]),
      appearance: ({ addUtilities: S3 }) => {
        S3({
          ".appearance-none": {
            appearance: "none"
          },
          ".appearance-auto": {
            appearance: "auto"
          }
        });
      },
      columns: (0, f.default)("columns", [
        [
          "columns",
          [
            "columns"
          ]
        ]
      ]),
      breakBefore: ({ addUtilities: S3 }) => {
        S3({
          ".break-before-auto": {
            "break-before": "auto"
          },
          ".break-before-avoid": {
            "break-before": "avoid"
          },
          ".break-before-all": {
            "break-before": "all"
          },
          ".break-before-avoid-page": {
            "break-before": "avoid-page"
          },
          ".break-before-page": {
            "break-before": "page"
          },
          ".break-before-left": {
            "break-before": "left"
          },
          ".break-before-right": {
            "break-before": "right"
          },
          ".break-before-column": {
            "break-before": "column"
          }
        });
      },
      breakInside: ({ addUtilities: S3 }) => {
        S3({
          ".break-inside-auto": {
            "break-inside": "auto"
          },
          ".break-inside-avoid": {
            "break-inside": "avoid"
          },
          ".break-inside-avoid-page": {
            "break-inside": "avoid-page"
          },
          ".break-inside-avoid-column": {
            "break-inside": "avoid-column"
          }
        });
      },
      breakAfter: ({ addUtilities: S3 }) => {
        S3({
          ".break-after-auto": {
            "break-after": "auto"
          },
          ".break-after-avoid": {
            "break-after": "avoid"
          },
          ".break-after-all": {
            "break-after": "all"
          },
          ".break-after-avoid-page": {
            "break-after": "avoid-page"
          },
          ".break-after-page": {
            "break-after": "page"
          },
          ".break-after-left": {
            "break-after": "left"
          },
          ".break-after-right": {
            "break-after": "right"
          },
          ".break-after-column": {
            "break-after": "column"
          }
        });
      },
      gridAutoColumns: (0, f.default)("gridAutoColumns", [
        [
          "auto-cols",
          [
            "gridAutoColumns"
          ]
        ]
      ]),
      gridAutoFlow: ({ addUtilities: S3 }) => {
        S3({
          ".grid-flow-row": {
            gridAutoFlow: "row"
          },
          ".grid-flow-col": {
            gridAutoFlow: "column"
          },
          ".grid-flow-dense": {
            gridAutoFlow: "dense"
          },
          ".grid-flow-row-dense": {
            gridAutoFlow: "row dense"
          },
          ".grid-flow-col-dense": {
            gridAutoFlow: "column dense"
          }
        });
      },
      gridAutoRows: (0, f.default)("gridAutoRows", [
        [
          "auto-rows",
          [
            "gridAutoRows"
          ]
        ]
      ]),
      gridTemplateColumns: (0, f.default)("gridTemplateColumns", [
        [
          "grid-cols",
          [
            "gridTemplateColumns"
          ]
        ]
      ]),
      gridTemplateRows: (0, f.default)("gridTemplateRows", [
        [
          "grid-rows",
          [
            "gridTemplateRows"
          ]
        ]
      ]),
      flexDirection: ({ addUtilities: S3 }) => {
        S3({
          ".flex-row": {
            "flex-direction": "row"
          },
          ".flex-row-reverse": {
            "flex-direction": "row-reverse"
          },
          ".flex-col": {
            "flex-direction": "column"
          },
          ".flex-col-reverse": {
            "flex-direction": "column-reverse"
          }
        });
      },
      flexWrap: ({ addUtilities: S3 }) => {
        S3({
          ".flex-wrap": {
            "flex-wrap": "wrap"
          },
          ".flex-wrap-reverse": {
            "flex-wrap": "wrap-reverse"
          },
          ".flex-nowrap": {
            "flex-wrap": "nowrap"
          }
        });
      },
      placeContent: ({ addUtilities: S3 }) => {
        S3({
          ".place-content-center": {
            "place-content": "center"
          },
          ".place-content-start": {
            "place-content": "start"
          },
          ".place-content-end": {
            "place-content": "end"
          },
          ".place-content-between": {
            "place-content": "space-between"
          },
          ".place-content-around": {
            "place-content": "space-around"
          },
          ".place-content-evenly": {
            "place-content": "space-evenly"
          },
          ".place-content-baseline": {
            "place-content": "baseline"
          },
          ".place-content-stretch": {
            "place-content": "stretch"
          }
        });
      },
      placeItems: ({ addUtilities: S3 }) => {
        S3({
          ".place-items-start": {
            "place-items": "start"
          },
          ".place-items-end": {
            "place-items": "end"
          },
          ".place-items-center": {
            "place-items": "center"
          },
          ".place-items-baseline": {
            "place-items": "baseline"
          },
          ".place-items-stretch": {
            "place-items": "stretch"
          }
        });
      },
      alignContent: ({ addUtilities: S3 }) => {
        S3({
          ".content-normal": {
            "align-content": "normal"
          },
          ".content-center": {
            "align-content": "center"
          },
          ".content-start": {
            "align-content": "flex-start"
          },
          ".content-end": {
            "align-content": "flex-end"
          },
          ".content-between": {
            "align-content": "space-between"
          },
          ".content-around": {
            "align-content": "space-around"
          },
          ".content-evenly": {
            "align-content": "space-evenly"
          },
          ".content-baseline": {
            "align-content": "baseline"
          },
          ".content-stretch": {
            "align-content": "stretch"
          }
        });
      },
      alignItems: ({ addUtilities: S3 }) => {
        S3({
          ".items-start": {
            "align-items": "flex-start"
          },
          ".items-end": {
            "align-items": "flex-end"
          },
          ".items-center": {
            "align-items": "center"
          },
          ".items-baseline": {
            "align-items": "baseline"
          },
          ".items-stretch": {
            "align-items": "stretch"
          }
        });
      },
      justifyContent: ({ addUtilities: S3 }) => {
        S3({
          ".justify-normal": {
            "justify-content": "normal"
          },
          ".justify-start": {
            "justify-content": "flex-start"
          },
          ".justify-end": {
            "justify-content": "flex-end"
          },
          ".justify-center": {
            "justify-content": "center"
          },
          ".justify-between": {
            "justify-content": "space-between"
          },
          ".justify-around": {
            "justify-content": "space-around"
          },
          ".justify-evenly": {
            "justify-content": "space-evenly"
          },
          ".justify-stretch": {
            "justify-content": "stretch"
          }
        });
      },
      justifyItems: ({ addUtilities: S3 }) => {
        S3({
          ".justify-items-start": {
            "justify-items": "start"
          },
          ".justify-items-end": {
            "justify-items": "end"
          },
          ".justify-items-center": {
            "justify-items": "center"
          },
          ".justify-items-stretch": {
            "justify-items": "stretch"
          }
        });
      },
      gap: (0, f.default)("gap", [
        [
          "gap",
          [
            "gap"
          ]
        ],
        [
          [
            "gap-x",
            [
              "columnGap"
            ]
          ],
          [
            "gap-y",
            [
              "rowGap"
            ]
          ]
        ]
      ]),
      space: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "space-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${R3} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${R3} * calc(1 - var(--tw-space-x-reverse)))`
            }
          }),
          "space-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${R3} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${R3} * var(--tw-space-y-reverse))`
            }
          })
        }, {
          values: C("space"),
          supportsNegativeValues: true
        }), P3({
          ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "1"
          },
          ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "1"
          }
        });
      },
      divideWidth: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "divide-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${R3} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${R3} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          }),
          "divide-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${R3} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${R3} * var(--tw-divide-y-reverse))`
            }
          })
        }, {
          values: C("divideWidth"),
          type: [
            "line-width",
            "length",
            "any"
          ]
        }), P3({
          ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "1"
          },
          ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "1"
          }
        });
      },
      divideStyle: ({ addUtilities: S3 }) => {
        S3({
          ".divide-solid > :not([hidden]) ~ :not([hidden])": {
            "border-style": "solid"
          },
          ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dashed"
          },
          ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dotted"
          },
          ".divide-double > :not([hidden]) ~ :not([hidden])": {
            "border-style": "double"
          },
          ".divide-none > :not([hidden]) ~ :not([hidden])": {
            "border-style": "none"
          }
        });
      },
      divideColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          divide: (R3) => C("divideOpacity") ? {
            "& > :not([hidden]) ~ :not([hidden])": (0, r2.default)({
              color: R3,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          } : {
            "& > :not([hidden]) ~ :not([hidden])": {
              "border-color": (0, i.default)(R3)
            }
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("divideColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      divideOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "divide-opacity": (C) => ({
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-divide-opacity": C
            }
          })
        }, {
          values: P3("divideOpacity")
        });
      },
      placeSelf: ({ addUtilities: S3 }) => {
        S3({
          ".place-self-auto": {
            "place-self": "auto"
          },
          ".place-self-start": {
            "place-self": "start"
          },
          ".place-self-end": {
            "place-self": "end"
          },
          ".place-self-center": {
            "place-self": "center"
          },
          ".place-self-stretch": {
            "place-self": "stretch"
          }
        });
      },
      alignSelf: ({ addUtilities: S3 }) => {
        S3({
          ".self-auto": {
            "align-self": "auto"
          },
          ".self-start": {
            "align-self": "flex-start"
          },
          ".self-end": {
            "align-self": "flex-end"
          },
          ".self-center": {
            "align-self": "center"
          },
          ".self-stretch": {
            "align-self": "stretch"
          },
          ".self-baseline": {
            "align-self": "baseline"
          }
        });
      },
      justifySelf: ({ addUtilities: S3 }) => {
        S3({
          ".justify-self-auto": {
            "justify-self": "auto"
          },
          ".justify-self-start": {
            "justify-self": "start"
          },
          ".justify-self-end": {
            "justify-self": "end"
          },
          ".justify-self-center": {
            "justify-self": "center"
          },
          ".justify-self-stretch": {
            "justify-self": "stretch"
          }
        });
      },
      overflow: ({ addUtilities: S3 }) => {
        S3({
          ".overflow-auto": {
            overflow: "auto"
          },
          ".overflow-hidden": {
            overflow: "hidden"
          },
          ".overflow-clip": {
            overflow: "clip"
          },
          ".overflow-visible": {
            overflow: "visible"
          },
          ".overflow-scroll": {
            overflow: "scroll"
          },
          ".overflow-x-auto": {
            "overflow-x": "auto"
          },
          ".overflow-y-auto": {
            "overflow-y": "auto"
          },
          ".overflow-x-hidden": {
            "overflow-x": "hidden"
          },
          ".overflow-y-hidden": {
            "overflow-y": "hidden"
          },
          ".overflow-x-clip": {
            "overflow-x": "clip"
          },
          ".overflow-y-clip": {
            "overflow-y": "clip"
          },
          ".overflow-x-visible": {
            "overflow-x": "visible"
          },
          ".overflow-y-visible": {
            "overflow-y": "visible"
          },
          ".overflow-x-scroll": {
            "overflow-x": "scroll"
          },
          ".overflow-y-scroll": {
            "overflow-y": "scroll"
          }
        });
      },
      overscrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".overscroll-auto": {
            "overscroll-behavior": "auto"
          },
          ".overscroll-contain": {
            "overscroll-behavior": "contain"
          },
          ".overscroll-none": {
            "overscroll-behavior": "none"
          },
          ".overscroll-y-auto": {
            "overscroll-behavior-y": "auto"
          },
          ".overscroll-y-contain": {
            "overscroll-behavior-y": "contain"
          },
          ".overscroll-y-none": {
            "overscroll-behavior-y": "none"
          },
          ".overscroll-x-auto": {
            "overscroll-behavior-x": "auto"
          },
          ".overscroll-x-contain": {
            "overscroll-behavior-x": "contain"
          },
          ".overscroll-x-none": {
            "overscroll-behavior-x": "none"
          }
        });
      },
      scrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".scroll-auto": {
            "scroll-behavior": "auto"
          },
          ".scroll-smooth": {
            "scroll-behavior": "smooth"
          }
        });
      },
      textOverflow: ({ addUtilities: S3 }) => {
        S3({
          ".truncate": {
            overflow: "hidden",
            "text-overflow": "ellipsis",
            "white-space": "nowrap"
          },
          ".overflow-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-clip": {
            "text-overflow": "clip"
          }
        });
      },
      hyphens: ({ addUtilities: S3 }) => {
        S3({
          ".hyphens-none": {
            hyphens: "none"
          },
          ".hyphens-manual": {
            hyphens: "manual"
          },
          ".hyphens-auto": {
            hyphens: "auto"
          }
        });
      },
      whitespace: ({ addUtilities: S3 }) => {
        S3({
          ".whitespace-normal": {
            "white-space": "normal"
          },
          ".whitespace-nowrap": {
            "white-space": "nowrap"
          },
          ".whitespace-pre": {
            "white-space": "pre"
          },
          ".whitespace-pre-line": {
            "white-space": "pre-line"
          },
          ".whitespace-pre-wrap": {
            "white-space": "pre-wrap"
          },
          ".whitespace-break-spaces": {
            "white-space": "break-spaces"
          }
        });
      },
      textWrap: ({ addUtilities: S3 }) => {
        S3({
          ".text-wrap": {
            "text-wrap": "wrap"
          },
          ".text-nowrap": {
            "text-wrap": "nowrap"
          },
          ".text-balance": {
            "text-wrap": "balance"
          },
          ".text-pretty": {
            "text-wrap": "pretty"
          }
        });
      },
      wordBreak: ({ addUtilities: S3 }) => {
        S3({
          ".break-normal": {
            "overflow-wrap": "normal",
            "word-break": "normal"
          },
          ".break-words": {
            "overflow-wrap": "break-word"
          },
          ".break-all": {
            "word-break": "break-all"
          },
          ".break-keep": {
            "word-break": "keep-all"
          }
        });
      },
      borderRadius: (0, f.default)("borderRadius", [
        [
          "rounded",
          [
            "border-radius"
          ]
        ],
        [
          [
            "rounded-s",
            [
              "border-start-start-radius",
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-e",
            [
              "border-start-end-radius",
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-t",
            [
              "border-top-left-radius",
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-r",
            [
              "border-top-right-radius",
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-b",
            [
              "border-bottom-right-radius",
              "border-bottom-left-radius"
            ]
          ],
          [
            "rounded-l",
            [
              "border-top-left-radius",
              "border-bottom-left-radius"
            ]
          ]
        ],
        [
          [
            "rounded-ss",
            [
              "border-start-start-radius"
            ]
          ],
          [
            "rounded-se",
            [
              "border-start-end-radius"
            ]
          ],
          [
            "rounded-ee",
            [
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-es",
            [
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-tl",
            [
              "border-top-left-radius"
            ]
          ],
          [
            "rounded-tr",
            [
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-br",
            [
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-bl",
            [
              "border-bottom-left-radius"
            ]
          ]
        ]
      ]),
      borderWidth: (0, f.default)("borderWidth", [
        [
          "border",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-width"
          ]
        ],
        [
          [
            "border-x",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width",
              "border-right-width"
            ]
          ],
          [
            "border-y",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width",
              "border-bottom-width"
            ]
          ]
        ],
        [
          [
            "border-s",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-start-width"
            ]
          ],
          [
            "border-e",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-end-width"
            ]
          ],
          [
            "border-t",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width"
            ]
          ],
          [
            "border-r",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-right-width"
            ]
          ],
          [
            "border-b",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-bottom-width"
            ]
          ],
          [
            "border-l",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width"
            ]
          ]
        ]
      ], {
        type: [
          "line-width",
          "length"
        ]
      }),
      borderStyle: ({ addUtilities: S3 }) => {
        S3({
          ".border-solid": {
            "border-style": "solid"
          },
          ".border-dashed": {
            "border-style": "dashed"
          },
          ".border-dotted": {
            "border-style": "dotted"
          },
          ".border-double": {
            "border-style": "double"
          },
          ".border-hidden": {
            "border-style": "hidden"
          },
          ".border-none": {
            "border-style": "none"
          }
        });
      },
      borderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          border: (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-x": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-left-color",
              "border-right-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i.default)(R3),
            "border-right-color": (0, i.default)(R3)
          },
          "border-y": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-top-color",
              "border-bottom-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i.default)(R3),
            "border-bottom-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-s": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-start-color": (0, i.default)(R3)
          },
          "border-e": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-end-color": (0, i.default)(R3)
          },
          "border-t": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i.default)(R3)
          },
          "border-r": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-right-color": (0, i.default)(R3)
          },
          "border-b": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-bottom-color": (0, i.default)(R3)
          },
          "border-l": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      borderOpacity: (0, f.default)("borderOpacity", [
        [
          "border-opacity",
          [
            "--tw-border-opacity"
          ]
        ]
      ]),
      backgroundColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          bg: (R3) => C("backgroundOpacity") ? (0, r2.default)({
            color: R3,
            property: "background-color",
            variable: "--tw-bg-opacity"
          }) : {
            "background-color": (0, i.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("backgroundColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      backgroundOpacity: (0, f.default)("backgroundOpacity", [
        [
          "bg-opacity",
          [
            "--tw-bg-opacity"
          ]
        ]
      ]),
      backgroundImage: (0, f.default)("backgroundImage", [
        [
          "bg",
          [
            "background-image"
          ]
        ]
      ], {
        type: [
          "lookup",
          "image",
          "url"
        ]
      }),
      gradientColorStops: /* @__PURE__ */ (() => {
        function S3(P3) {
          return (0, r2.withAlphaValue)(P3, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities: P3, theme: C, addDefaults: R3 }) {
          R3("gradient-color-stops", {
            "--tw-gradient-from-position": " ",
            "--tw-gradient-via-position": " ",
            "--tw-gradient-to-position": " "
          });
          let $2 = {
            values: (0, e2.default)(C("gradientColorStops")),
            type: [
              "color",
              "any"
            ]
          }, B3 = {
            values: C("gradientColorStopPositions"),
            type: [
              "length",
              "percentage"
            ]
          };
          P3({
            from: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${(0, i.default)(z3)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${L3} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
              };
            }
          }, $2), P3({
            from: (z3) => ({
              "--tw-gradient-from-position": z3
            })
          }, B3), P3({
            via: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${L3}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, i.default)(z3)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          }, $2), P3({
            via: (z3) => ({
              "--tw-gradient-via-position": z3
            })
          }, B3), P3({
            to: (z3) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${(0, i.default)(z3)} var(--tw-gradient-to-position)`
            })
          }, $2), P3({
            to: (z3) => ({
              "--tw-gradient-to-position": z3
            })
          }, B3);
        };
      })(),
      boxDecorationBreak: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".decoration-clone": {
            "box-decoration-break": "clone"
          },
          ".box-decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".box-decoration-clone": {
            "box-decoration-break": "clone"
          }
        });
      },
      backgroundSize: (0, f.default)("backgroundSize", [
        [
          "bg",
          [
            "background-size"
          ]
        ]
      ], {
        type: [
          "lookup",
          "length",
          "percentage",
          "size"
        ]
      }),
      backgroundAttachment: ({ addUtilities: S3 }) => {
        S3({
          ".bg-fixed": {
            "background-attachment": "fixed"
          },
          ".bg-local": {
            "background-attachment": "local"
          },
          ".bg-scroll": {
            "background-attachment": "scroll"
          }
        });
      },
      backgroundClip: ({ addUtilities: S3 }) => {
        S3({
          ".bg-clip-border": {
            "background-clip": "border-box"
          },
          ".bg-clip-padding": {
            "background-clip": "padding-box"
          },
          ".bg-clip-content": {
            "background-clip": "content-box"
          },
          ".bg-clip-text": {
            "background-clip": "text"
          }
        });
      },
      backgroundPosition: (0, f.default)("backgroundPosition", [
        [
          "bg",
          [
            "background-position"
          ]
        ]
      ], {
        type: [
          "lookup",
          [
            "position",
            {
              preferOnConflict: true
            }
          ]
        ]
      }),
      backgroundRepeat: ({ addUtilities: S3 }) => {
        S3({
          ".bg-repeat": {
            "background-repeat": "repeat"
          },
          ".bg-no-repeat": {
            "background-repeat": "no-repeat"
          },
          ".bg-repeat-x": {
            "background-repeat": "repeat-x"
          },
          ".bg-repeat-y": {
            "background-repeat": "repeat-y"
          },
          ".bg-repeat-round": {
            "background-repeat": "round"
          },
          ".bg-repeat-space": {
            "background-repeat": "space"
          }
        });
      },
      backgroundOrigin: ({ addUtilities: S3 }) => {
        S3({
          ".bg-origin-border": {
            "background-origin": "border-box"
          },
          ".bg-origin-padding": {
            "background-origin": "padding-box"
          },
          ".bg-origin-content": {
            "background-origin": "content-box"
          }
        });
      },
      fill: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          fill: (C) => ({
            fill: (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("fill")),
          type: [
            "color",
            "any"
          ]
        });
      },
      stroke: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          stroke: (C) => ({
            stroke: (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("stroke")),
          type: [
            "color",
            "url",
            "any"
          ]
        });
      },
      strokeWidth: (0, f.default)("strokeWidth", [
        [
          "stroke",
          [
            "stroke-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      objectFit: ({ addUtilities: S3 }) => {
        S3({
          ".object-contain": {
            "object-fit": "contain"
          },
          ".object-cover": {
            "object-fit": "cover"
          },
          ".object-fill": {
            "object-fit": "fill"
          },
          ".object-none": {
            "object-fit": "none"
          },
          ".object-scale-down": {
            "object-fit": "scale-down"
          }
        });
      },
      objectPosition: (0, f.default)("objectPosition", [
        [
          "object",
          [
            "object-position"
          ]
        ]
      ]),
      padding: (0, f.default)("padding", [
        [
          "p",
          [
            "padding"
          ]
        ],
        [
          [
            "px",
            [
              "padding-left",
              "padding-right"
            ]
          ],
          [
            "py",
            [
              "padding-top",
              "padding-bottom"
            ]
          ]
        ],
        [
          [
            "ps",
            [
              "padding-inline-start"
            ]
          ],
          [
            "pe",
            [
              "padding-inline-end"
            ]
          ],
          [
            "pt",
            [
              "padding-top"
            ]
          ],
          [
            "pr",
            [
              "padding-right"
            ]
          ],
          [
            "pb",
            [
              "padding-bottom"
            ]
          ],
          [
            "pl",
            [
              "padding-left"
            ]
          ]
        ]
      ]),
      textAlign: ({ addUtilities: S3 }) => {
        S3({
          ".text-left": {
            "text-align": "left"
          },
          ".text-center": {
            "text-align": "center"
          },
          ".text-right": {
            "text-align": "right"
          },
          ".text-justify": {
            "text-align": "justify"
          },
          ".text-start": {
            "text-align": "start"
          },
          ".text-end": {
            "text-align": "end"
          }
        });
      },
      textIndent: (0, f.default)("textIndent", [
        [
          "indent",
          [
            "text-indent"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      verticalAlign: ({ addUtilities: S3, matchUtilities: P3 }) => {
        S3({
          ".align-baseline": {
            "vertical-align": "baseline"
          },
          ".align-top": {
            "vertical-align": "top"
          },
          ".align-middle": {
            "vertical-align": "middle"
          },
          ".align-bottom": {
            "vertical-align": "bottom"
          },
          ".align-text-top": {
            "vertical-align": "text-top"
          },
          ".align-text-bottom": {
            "vertical-align": "text-bottom"
          },
          ".align-sub": {
            "vertical-align": "sub"
          },
          ".align-super": {
            "vertical-align": "super"
          }
        }), P3({
          align: (C) => ({
            "vertical-align": C
          })
        });
      },
      fontFamily: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          font: (C) => {
            let [R3, $2 = {}] = Array.isArray(C) && (0, o2.default)(C[1]) ? C : [
              C
            ], { fontFeatureSettings: B3, fontVariationSettings: z3 } = $2;
            return {
              "font-family": Array.isArray(R3) ? R3.join(", ") : R3,
              ...B3 === void 0 ? {} : {
                "font-feature-settings": B3
              },
              ...z3 === void 0 ? {} : {
                "font-variation-settings": z3
              }
            };
          }
        }, {
          values: P3("fontFamily"),
          type: [
            "lookup",
            "generic-name",
            "family-name"
          ]
        });
      },
      fontSize: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          text: (C, { modifier: R3 }) => {
            let [$2, B3] = Array.isArray(C) ? C : [
              C
            ];
            if (R3)
              return {
                "font-size": $2,
                "line-height": R3
              };
            let { lineHeight: z3, letterSpacing: L3, fontWeight: F } = (0, o2.default)(B3) ? B3 : {
              lineHeight: B3
            };
            return {
              "font-size": $2,
              ...z3 === void 0 ? {} : {
                "line-height": z3
              },
              ...L3 === void 0 ? {} : {
                "letter-spacing": L3
              },
              ...F === void 0 ? {} : {
                "font-weight": F
              }
            };
          }
        }, {
          values: P3("fontSize"),
          modifiers: P3("lineHeight"),
          type: [
            "absolute-size",
            "relative-size",
            "length",
            "percentage"
          ]
        });
      },
      fontWeight: (0, f.default)("fontWeight", [
        [
          "font",
          [
            "fontWeight"
          ]
        ]
      ], {
        type: [
          "lookup",
          "number",
          "any"
        ]
      }),
      textTransform: ({ addUtilities: S3 }) => {
        S3({
          ".uppercase": {
            "text-transform": "uppercase"
          },
          ".lowercase": {
            "text-transform": "lowercase"
          },
          ".capitalize": {
            "text-transform": "capitalize"
          },
          ".normal-case": {
            "text-transform": "none"
          }
        });
      },
      fontStyle: ({ addUtilities: S3 }) => {
        S3({
          ".italic": {
            "font-style": "italic"
          },
          ".not-italic": {
            "font-style": "normal"
          }
        });
      },
      fontVariantNumeric: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        S3("font-variant-numeric", {
          "--tw-ordinal": " ",
          "--tw-slashed-zero": " ",
          "--tw-numeric-figure": " ",
          "--tw-numeric-spacing": " ",
          "--tw-numeric-fraction": " "
        }), P3({
          ".normal-nums": {
            "font-variant-numeric": "normal"
          },
          ".ordinal": {
            "@defaults font-variant-numeric": {},
            "--tw-ordinal": "ordinal",
            "font-variant-numeric": C
          },
          ".slashed-zero": {
            "@defaults font-variant-numeric": {},
            "--tw-slashed-zero": "slashed-zero",
            "font-variant-numeric": C
          },
          ".lining-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "lining-nums",
            "font-variant-numeric": C
          },
          ".oldstyle-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "oldstyle-nums",
            "font-variant-numeric": C
          },
          ".proportional-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "proportional-nums",
            "font-variant-numeric": C
          },
          ".tabular-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "tabular-nums",
            "font-variant-numeric": C
          },
          ".diagonal-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "diagonal-fractions",
            "font-variant-numeric": C
          },
          ".stacked-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "stacked-fractions",
            "font-variant-numeric": C
          }
        });
      },
      lineHeight: (0, f.default)("lineHeight", [
        [
          "leading",
          [
            "lineHeight"
          ]
        ]
      ]),
      letterSpacing: (0, f.default)("letterSpacing", [
        [
          "tracking",
          [
            "letterSpacing"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      textColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          text: (R3) => C("textOpacity") ? (0, r2.default)({
            color: R3,
            property: "color",
            variable: "--tw-text-opacity"
          }) : {
            color: (0, i.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("textColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textOpacity: (0, f.default)("textOpacity", [
        [
          "text-opacity",
          [
            "--tw-text-opacity"
          ]
        ]
      ]),
      textDecoration: ({ addUtilities: S3 }) => {
        S3({
          ".underline": {
            "text-decoration-line": "underline"
          },
          ".overline": {
            "text-decoration-line": "overline"
          },
          ".line-through": {
            "text-decoration-line": "line-through"
          },
          ".no-underline": {
            "text-decoration-line": "none"
          }
        });
      },
      textDecorationColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          decoration: (C) => ({
            "text-decoration-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("textDecorationColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textDecorationStyle: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-solid": {
            "text-decoration-style": "solid"
          },
          ".decoration-double": {
            "text-decoration-style": "double"
          },
          ".decoration-dotted": {
            "text-decoration-style": "dotted"
          },
          ".decoration-dashed": {
            "text-decoration-style": "dashed"
          },
          ".decoration-wavy": {
            "text-decoration-style": "wavy"
          }
        });
      },
      textDecorationThickness: (0, f.default)("textDecorationThickness", [
        [
          "decoration",
          [
            "text-decoration-thickness"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage"
        ]
      }),
      textUnderlineOffset: (0, f.default)("textUnderlineOffset", [
        [
          "underline-offset",
          [
            "text-underline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage",
          "any"
        ]
      }),
      fontSmoothing: ({ addUtilities: S3 }) => {
        S3({
          ".antialiased": {
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          ".subpixel-antialiased": {
            "-webkit-font-smoothing": "auto",
            "-moz-osx-font-smoothing": "auto"
          }
        });
      },
      placeholderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          placeholder: (R3) => C("placeholderOpacity") ? {
            "&::placeholder": (0, r2.default)({
              color: R3,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          } : {
            "&::placeholder": {
              color: (0, i.default)(R3)
            }
          }
        }, {
          values: (0, e2.default)(P3("placeholderColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      placeholderOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "placeholder-opacity": (C) => ({
            "&::placeholder": {
              "--tw-placeholder-opacity": C
            }
          })
        }, {
          values: P3("placeholderOpacity")
        });
      },
      caretColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          caret: (C) => ({
            "caret-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("caretColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      accentColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          accent: (C) => ({
            "accent-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("accentColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      opacity: (0, f.default)("opacity", [
        [
          "opacity",
          [
            "opacity"
          ]
        ]
      ]),
      backgroundBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".bg-blend-normal": {
            "background-blend-mode": "normal"
          },
          ".bg-blend-multiply": {
            "background-blend-mode": "multiply"
          },
          ".bg-blend-screen": {
            "background-blend-mode": "screen"
          },
          ".bg-blend-overlay": {
            "background-blend-mode": "overlay"
          },
          ".bg-blend-darken": {
            "background-blend-mode": "darken"
          },
          ".bg-blend-lighten": {
            "background-blend-mode": "lighten"
          },
          ".bg-blend-color-dodge": {
            "background-blend-mode": "color-dodge"
          },
          ".bg-blend-color-burn": {
            "background-blend-mode": "color-burn"
          },
          ".bg-blend-hard-light": {
            "background-blend-mode": "hard-light"
          },
          ".bg-blend-soft-light": {
            "background-blend-mode": "soft-light"
          },
          ".bg-blend-difference": {
            "background-blend-mode": "difference"
          },
          ".bg-blend-exclusion": {
            "background-blend-mode": "exclusion"
          },
          ".bg-blend-hue": {
            "background-blend-mode": "hue"
          },
          ".bg-blend-saturation": {
            "background-blend-mode": "saturation"
          },
          ".bg-blend-color": {
            "background-blend-mode": "color"
          },
          ".bg-blend-luminosity": {
            "background-blend-mode": "luminosity"
          }
        });
      },
      mixBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".mix-blend-normal": {
            "mix-blend-mode": "normal"
          },
          ".mix-blend-multiply": {
            "mix-blend-mode": "multiply"
          },
          ".mix-blend-screen": {
            "mix-blend-mode": "screen"
          },
          ".mix-blend-overlay": {
            "mix-blend-mode": "overlay"
          },
          ".mix-blend-darken": {
            "mix-blend-mode": "darken"
          },
          ".mix-blend-lighten": {
            "mix-blend-mode": "lighten"
          },
          ".mix-blend-color-dodge": {
            "mix-blend-mode": "color-dodge"
          },
          ".mix-blend-color-burn": {
            "mix-blend-mode": "color-burn"
          },
          ".mix-blend-hard-light": {
            "mix-blend-mode": "hard-light"
          },
          ".mix-blend-soft-light": {
            "mix-blend-mode": "soft-light"
          },
          ".mix-blend-difference": {
            "mix-blend-mode": "difference"
          },
          ".mix-blend-exclusion": {
            "mix-blend-mode": "exclusion"
          },
          ".mix-blend-hue": {
            "mix-blend-mode": "hue"
          },
          ".mix-blend-saturation": {
            "mix-blend-mode": "saturation"
          },
          ".mix-blend-color": {
            "mix-blend-mode": "color"
          },
          ".mix-blend-luminosity": {
            "mix-blend-mode": "luminosity"
          },
          ".mix-blend-plus-darker": {
            "mix-blend-mode": "plus-darker"
          },
          ".mix-blend-plus-lighter": {
            "mix-blend-mode": "plus-lighter"
          }
        });
      },
      boxShadow: (() => {
        let S3 = (0, v3.default)("boxShadow"), P3 = [
          "var(--tw-ring-offset-shadow, 0 0 #0000)",
          "var(--tw-ring-shadow, 0 0 #0000)",
          "var(--tw-shadow)"
        ].join(", ");
        return function({ matchUtilities: C, addDefaults: R3, theme: $2 }) {
          R3("box-shadow", {
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          }), C({
            shadow: (B3) => {
              B3 = S3(B3);
              let z3 = (0, _3.parseBoxShadowValue)(B3);
              for (let L3 of z3)
                L3.valid && (L3.color = "var(--tw-shadow-color)");
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": B3 === "none" ? "0 0 #0000" : B3,
                "--tw-shadow-colored": B3 === "none" ? "0 0 #0000" : (0, _3.formatBoxShadowValue)(z3),
                "box-shadow": P3
              };
            }
          }, {
            values: $2("boxShadow"),
            type: [
              "shadow"
            ]
          });
        };
      })(),
      boxShadowColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          shadow: (C) => ({
            "--tw-shadow-color": (0, i.default)(C),
            "--tw-shadow": "var(--tw-shadow-colored)"
          })
        }, {
          values: (0, e2.default)(P3("boxShadowColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      outlineStyle: ({ addUtilities: S3 }) => {
        S3({
          ".outline-none": {
            outline: "2px solid transparent",
            "outline-offset": "2px"
          },
          ".outline": {
            "outline-style": "solid"
          },
          ".outline-dashed": {
            "outline-style": "dashed"
          },
          ".outline-dotted": {
            "outline-style": "dotted"
          },
          ".outline-double": {
            "outline-style": "double"
          }
        });
      },
      outlineWidth: (0, f.default)("outlineWidth", [
        [
          "outline",
          [
            "outline-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      outlineOffset: (0, f.default)("outlineOffset", [
        [
          "outline-offset",
          [
            "outline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage",
          "any"
        ],
        supportsNegativeValues: true
      }),
      outlineColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          outline: (C) => ({
            "outline-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("outlineColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringWidth: ({ matchUtilities: S3, addDefaults: P3, addUtilities: C, theme: R3, config: $2 }) => {
        let B3 = (() => {
          var z3, L3;
          if ((0, y2.flagEnabled)($2(), "respectDefaultRingColorOpacity"))
            return R3("ringColor.DEFAULT");
          let F = R3("ringOpacity.DEFAULT", "0.5");
          return !((z3 = R3("ringColor")) === null || z3 === void 0) && z3.DEFAULT ? (0, r2.withAlphaValue)((L3 = R3("ringColor")) === null || L3 === void 0 ? void 0 : L3.DEFAULT, F, `rgb(147 197 253 / ${F})`) : `rgb(147 197 253 / ${F})`;
        })();
        P3("ring-width", {
          "--tw-ring-inset": " ",
          "--tw-ring-offset-width": R3("ringOffsetWidth.DEFAULT", "0px"),
          "--tw-ring-offset-color": R3("ringOffsetColor.DEFAULT", "#fff"),
          "--tw-ring-color": B3,
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), S3({
          ring: (z3) => ({
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${z3} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              "var(--tw-ring-offset-shadow)",
              "var(--tw-ring-shadow)",
              "var(--tw-shadow, 0 0 #0000)"
            ].join(", ")
          })
        }, {
          values: R3("ringWidth"),
          type: "length"
        }), C({
          ".ring-inset": {
            "@defaults ring-width": {},
            "--tw-ring-inset": "inset"
          }
        });
      },
      ringColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          ring: (R3) => C("ringOpacity") ? (0, r2.default)({
            color: R3,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          }) : {
            "--tw-ring-color": (0, i.default)(R3)
          }
        }, {
          values: Object.fromEntries(Object.entries((0, e2.default)(P3("ringColor"))).filter(([R3]) => R3 !== "DEFAULT")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringOpacity: (S3) => {
        let { config: P3 } = S3;
        return (0, f.default)("ringOpacity", [
          [
            "ring-opacity",
            [
              "--tw-ring-opacity"
            ]
          ]
        ], {
          filterDefault: !(0, y2.flagEnabled)(P3(), "respectDefaultRingColorOpacity")
        })(S3);
      },
      ringOffsetWidth: (0, f.default)("ringOffsetWidth", [
        [
          "ring-offset",
          [
            "--tw-ring-offset-width"
          ]
        ]
      ], {
        type: "length"
      }),
      ringOffsetColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "ring-offset": (C) => ({
            "--tw-ring-offset-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("ringOffsetColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      blur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          blur: (C) => ({
            "--tw-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("blur")
        });
      },
      brightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          brightness: (C) => ({
            "--tw-brightness": `brightness(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("brightness")
        });
      },
      contrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          contrast: (C) => ({
            "--tw-contrast": `contrast(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("contrast")
        });
      },
      dropShadow: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "drop-shadow": (C) => ({
            "--tw-drop-shadow": Array.isArray(C) ? C.map((R3) => `drop-shadow(${R3})`).join(" ") : `drop-shadow(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("dropShadow")
        });
      },
      grayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          grayscale: (C) => ({
            "--tw-grayscale": `grayscale(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("grayscale")
        });
      },
      hueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "hue-rotate": (C) => ({
            "--tw-hue-rotate": `hue-rotate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("hueRotate"),
          supportsNegativeValues: true
        });
      },
      invert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          invert: (C) => ({
            "--tw-invert": `invert(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("invert")
        });
      },
      saturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          saturate: (C) => ({
            "--tw-saturate": `saturate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("saturate")
        });
      },
      sepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          sepia: (C) => ({
            "--tw-sepia": `sepia(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("sepia")
        });
      },
      filter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("filter", {
          "--tw-blur": " ",
          "--tw-brightness": " ",
          "--tw-contrast": " ",
          "--tw-grayscale": " ",
          "--tw-hue-rotate": " ",
          "--tw-invert": " ",
          "--tw-saturate": " ",
          "--tw-sepia": " ",
          "--tw-drop-shadow": " "
        }), P3({
          ".filter": {
            "@defaults filter": {},
            filter: q2
          },
          ".filter-none": {
            filter: "none"
          }
        });
      },
      backdropBlur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-blur": (C) => ({
            "--tw-backdrop-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBlur")
        });
      },
      backdropBrightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-brightness": (C) => ({
            "--tw-backdrop-brightness": `brightness(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBrightness")
        });
      },
      backdropContrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-contrast": (C) => ({
            "--tw-backdrop-contrast": `contrast(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropContrast")
        });
      },
      backdropGrayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-grayscale": (C) => ({
            "--tw-backdrop-grayscale": `grayscale(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropGrayscale")
        });
      },
      backdropHueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-hue-rotate": (C) => ({
            "--tw-backdrop-hue-rotate": `hue-rotate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropHueRotate"),
          supportsNegativeValues: true
        });
      },
      backdropInvert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-invert": (C) => ({
            "--tw-backdrop-invert": `invert(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropInvert")
        });
      },
      backdropOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-opacity": (C) => ({
            "--tw-backdrop-opacity": `opacity(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropOpacity")
        });
      },
      backdropSaturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-saturate": (C) => ({
            "--tw-backdrop-saturate": `saturate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSaturate")
        });
      },
      backdropSepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-sepia": (C) => ({
            "--tw-backdrop-sepia": `sepia(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSepia")
        });
      },
      backdropFilter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("backdrop-filter", {
          "--tw-backdrop-blur": " ",
          "--tw-backdrop-brightness": " ",
          "--tw-backdrop-contrast": " ",
          "--tw-backdrop-grayscale": " ",
          "--tw-backdrop-hue-rotate": " ",
          "--tw-backdrop-invert": " ",
          "--tw-backdrop-opacity": " ",
          "--tw-backdrop-saturate": " ",
          "--tw-backdrop-sepia": " "
        }), P3({
          ".backdrop-filter": {
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          },
          ".backdrop-filter-none": {
            "-webkit-backdrop-filter": "none",
            "backdrop-filter": "none"
          }
        });
      },
      transitionProperty: ({ matchUtilities: S3, theme: P3 }) => {
        let C = P3("transitionTimingFunction.DEFAULT"), R3 = P3("transitionDuration.DEFAULT");
        S3({
          transition: ($2) => ({
            "transition-property": $2,
            ...$2 === "none" ? {} : {
              "transition-timing-function": C,
              "transition-duration": R3
            }
          })
        }, {
          values: P3("transitionProperty")
        });
      },
      transitionDelay: (0, f.default)("transitionDelay", [
        [
          "delay",
          [
            "transitionDelay"
          ]
        ]
      ]),
      transitionDuration: (0, f.default)("transitionDuration", [
        [
          "duration",
          [
            "transitionDuration"
          ]
        ]
      ], {
        filterDefault: true
      }),
      transitionTimingFunction: (0, f.default)("transitionTimingFunction", [
        [
          "ease",
          [
            "transitionTimingFunction"
          ]
        ]
      ], {
        filterDefault: true
      }),
      willChange: (0, f.default)("willChange", [
        [
          "will-change",
          [
            "will-change"
          ]
        ]
      ]),
      contain: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
        S3("contain", {
          "--tw-contain-size": " ",
          "--tw-contain-layout": " ",
          "--tw-contain-paint": " ",
          "--tw-contain-style": " "
        }), P3({
          ".contain-none": {
            contain: "none"
          },
          ".contain-content": {
            contain: "content"
          },
          ".contain-strict": {
            contain: "strict"
          },
          ".contain-size": {
            "@defaults contain": {},
            "--tw-contain-size": "size",
            contain: C
          },
          ".contain-inline-size": {
            "@defaults contain": {},
            "--tw-contain-size": "inline-size",
            contain: C
          },
          ".contain-layout": {
            "@defaults contain": {},
            "--tw-contain-layout": "layout",
            contain: C
          },
          ".contain-paint": {
            "@defaults contain": {},
            "--tw-contain-paint": "paint",
            contain: C
          },
          ".contain-style": {
            "@defaults contain": {},
            "--tw-contain-style": "style",
            contain: C
          }
        });
      },
      content: (0, f.default)("content", [
        [
          "content",
          [
            "--tw-content",
            [
              "content",
              "var(--tw-content)"
            ]
          ]
        ]
      ]),
      forcedColorAdjust: ({ addUtilities: S3 }) => {
        S3({
          ".forced-color-adjust-auto": {
            "forced-color-adjust": "auto"
          },
          ".forced-color-adjust-none": {
            "forced-color-adjust": "none"
          }
        });
      }
    };
  }(Kn3)), Kn3;
}
var ni3 = {};
var No2;
function au3() {
  return No2 || (No2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(
      u,
      // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
      // values don't count, and brackets inside quotes also don't count.
      //
      // E.g.: w-[this-is]w-[weird-and-invalid]
      // E.g.: w-[this-is\\]w-\\[weird-but-valid]
      // E.g.: content-['this-is-also-valid]-weirdly-enough']
      "default",
      {
        enumerable: true,
        get: function() {
          return l2;
        }
      }
    );
    let a = /* @__PURE__ */ new Map([
      [
        "{",
        "}"
      ],
      [
        "[",
        "]"
      ],
      [
        "(",
        ")"
      ]
    ]), h7 = new Map(Array.from(a.entries()).map(([f, s2]) => [
      s2,
      f
    ])), p = /* @__PURE__ */ new Set([
      '"',
      "'",
      "`"
    ]);
    function l2(f) {
      let s2 = [], c2 = false;
      for (let t8 = 0; t8 < f.length; t8++) {
        let e2 = f[t8];
        if (e2 === ":" && !c2 && s2.length === 0)
          return false;
        if (p.has(e2) && f[t8 - 1] !== "\\" && (c2 = !c2), !c2 && f[t8 - 1] !== "\\") {
          if (a.has(e2))
            s2.push(e2);
          else if (h7.has(e2)) {
            let r2 = h7.get(e2);
            if (s2.length <= 0 || s2.pop() !== r2)
              return false;
          }
        }
      }
      return !(s2.length > 0);
    }
  }(ni3)), ni3;
}
var ii2 = {};
var Fo2;
function Mf() {
  return Fo2 || (Fo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "hasContentChanged", {
      enumerable: true,
      get: function() {
        return c2;
      }
    });
    const a = p(Ne3), h7 = f(yr3());
    function p(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    function l2(t8) {
      if (typeof WeakMap != "function") return null;
      var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(i) {
        return i ? r2 : e2;
      })(t8);
    }
    function f(t8, e2) {
      if (t8 && t8.__esModule)
        return t8;
      if (t8 === null || typeof t8 != "object" && typeof t8 != "function")
        return {
          default: t8
        };
      var r2 = l2(e2);
      if (r2 && r2.has(t8))
        return r2.get(t8);
      var i = {}, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var v3 in t8)
        if (v3 !== "default" && Object.prototype.hasOwnProperty.call(t8, v3)) {
          var m = o2 ? Object.getOwnPropertyDescriptor(t8, v3) : null;
          m && (m.get || m.set) ? Object.defineProperty(i, v3, m) : i[v3] = t8[v3];
        }
      return i.default = t8, r2 && r2.set(t8, i), i;
    }
    function s2(t8) {
      try {
        return a.default.createHash("md5").update(t8, "utf-8").digest("binary");
      } catch {
        return "";
      }
    }
    function c2(t8, e2) {
      let r2 = e2.toString();
      if (!r2.includes("@tailwind"))
        return false;
      let i = h7.sourceHashMap.get(t8), o2 = s2(r2), v3 = i !== o2;
      return h7.sourceHashMap.set(t8, o2), v3;
    }
  }(ii2)), ii2;
}
var ai = {};
var si2 = {};
var $o3;
function Df() {
  return $o3 || ($o3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      return (h7 > 0n) - (h7 < 0n);
    }
  }(si2)), si2;
}
var oi = {};
var Uo3;
function qf() {
  return Uo3 || (Uo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "remapBitfield", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7, p) {
      let l2 = 0n, f = 0n;
      for (let [s2, c2] of p)
        h7 & s2 && (l2 = l2 | s2, f = f | c2);
      return h7 & ~l2 | f;
    }
  }(oi)), oi;
}
var zo3;
function Lf() {
  return zo3 || (zo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "Offsets", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(Df()), h7 = qf();
    function p(c2) {
      return c2 && c2.__esModule ? c2 : {
        default: c2
      };
    }
    class l2 {
      constructor() {
        this.offsets = {
          defaults: 0n,
          base: 0n,
          components: 0n,
          utilities: 0n,
          variants: 0n,
          user: 0n
        }, this.layerPositions = {
          defaults: 0n,
          base: 1n,
          components: 2n,
          utilities: 3n,
          // There isn't technically a "user" layer, but we need to give it a position
          // Because it's used for ordering user-css from @apply
          user: 4n,
          variants: 5n
        }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
      }
      /**
      * @param {Layer} layer
      * @returns {RuleOffset}
      */
      create(t8) {
        return {
          layer: t8,
          parentLayer: t8,
          arbitrary: 0n,
          variants: 0n,
          parallelIndex: 0n,
          index: this.offsets[t8]++,
          propertyOffset: 0n,
          property: "",
          options: []
        };
      }
      /**
      * @param {string} name
      * @returns {RuleOffset}
      */
      arbitraryProperty(t8) {
        return {
          ...this.create("utilities"),
          arbitrary: 1n,
          property: t8
        };
      }
      /**
      * Get the offset for a variant
      *
      * @param {string} variant
      * @param {number} index
      * @returns {RuleOffset}
      */
      forVariant(t8, e2 = 0) {
        let r2 = this.variantOffsets.get(t8);
        if (r2 === void 0)
          throw new Error(`Cannot find offset for unknown variant ${t8}`);
        return {
          ...this.create("variants"),
          variants: r2 << BigInt(e2)
        };
      }
      /**
      * @param {RuleOffset} rule
      * @param {RuleOffset} variant
      * @param {VariantOption} options
      * @returns {RuleOffset}
      */
      applyVariantOffset(t8, e2, r2) {
        return r2.variant = e2.variants, {
          ...t8,
          layer: "variants",
          parentLayer: t8.layer === "variants" ? t8.parentLayer : t8.layer,
          variants: t8.variants | e2.variants,
          options: r2.sort ? [].concat(r2, t8.options) : t8.options,
          // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
          // We'll take the max of all the parallel indexes for now.
          // @ts-ignore
          parallelIndex: f([
            t8.parallelIndex,
            e2.parallelIndex
          ])
        };
      }
      /**
      * @param {RuleOffset} offset
      * @param {number} parallelIndex
      * @returns {RuleOffset}
      */
      applyParallelOffset(t8, e2) {
        return {
          ...t8,
          parallelIndex: BigInt(e2)
        };
      }
      /**
      * Each variant gets 1 bit per function / rule registered.
      * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
      * Additionally, every unique group of variants is grouped together in the stylesheet.
      *
      * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
      *
      * @param {string[]} variants
      * @param {(name: string) => number} getLength
      */
      recordVariants(t8, e2) {
        for (let r2 of t8)
          this.recordVariant(r2, e2(r2));
      }
      /**
      * The same as `recordVariants` but for a single arbitrary variant at runtime.
      * @param {string} variant
      * @param {number} fnCount
      *
      * @returns {RuleOffset} The highest offset for this variant
      */
      recordVariant(t8, e2 = 1) {
        return this.variantOffsets.set(t8, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(e2), {
          ...this.create("variants"),
          variants: this.variantOffsets.get(t8)
        };
      }
      /**
      * @param {RuleOffset} a
      * @param {RuleOffset} b
      * @returns {bigint}
      */
      compare(t8, e2) {
        if (t8.layer !== e2.layer)
          return this.layerPositions[t8.layer] - this.layerPositions[e2.layer];
        if (t8.parentLayer !== e2.parentLayer)
          return this.layerPositions[t8.parentLayer] - this.layerPositions[e2.parentLayer];
        for (let i of t8.options)
          for (let o2 of e2.options) {
            if (i.id !== o2.id || !i.sort || !o2.sort) continue;
            var r2;
            let v3 = (r2 = f([
              i.variant,
              o2.variant
            ])) !== null && r2 !== void 0 ? r2 : 0n, m = ~(v3 | v3 - 1n), n2 = t8.variants & m, d2 = e2.variants & m;
            if (n2 !== d2)
              continue;
            let _3 = i.sort({
              value: i.value,
              modifier: i.modifier
            }, {
              value: o2.value,
              modifier: o2.modifier
            });
            if (_3 !== 0) return _3;
          }
        return t8.variants !== e2.variants ? t8.variants - e2.variants : t8.parallelIndex !== e2.parallelIndex ? t8.parallelIndex - e2.parallelIndex : t8.arbitrary !== e2.arbitrary ? t8.arbitrary - e2.arbitrary : t8.propertyOffset !== e2.propertyOffset ? t8.propertyOffset - e2.propertyOffset : t8.index - e2.index;
      }
      /**
      * Arbitrary variants are recorded in the order they're encountered.
      * This means that the order is not stable between environments and sets of content files.
      *
      * In order to make the order stable, we need to remap the arbitrary variant offsets to
      * be in alphabetical order starting from the offset of the first arbitrary variant.
      */
      recalculateVariantOffsets() {
        let t8 = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [o2]) => s2(i, o2)), e2 = t8.map(([, i]) => i).sort((i, o2) => (0, a.default)(i - o2));
        return t8.map(([, i], o2) => [
          i,
          e2[o2]
        ]).filter(([i, o2]) => i !== o2);
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      remapArbitraryVariantOffsets(t8) {
        let e2 = this.recalculateVariantOffsets();
        return e2.length === 0 ? t8 : t8.map((r2) => {
          let [i, o2] = r2;
          return i = {
            ...i,
            variants: (0, h7.remapBitfield)(i.variants, e2)
          }, [
            i,
            o2
          ];
        });
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      sortArbitraryProperties(t8) {
        let e2 = /* @__PURE__ */ new Set();
        for (let [v3] of t8)
          v3.arbitrary === 1n && e2.add(v3.property);
        if (e2.size === 0)
          return t8;
        let r2 = Array.from(e2).sort(), i = /* @__PURE__ */ new Map(), o2 = 1n;
        for (let v3 of r2)
          i.set(v3, o2++);
        return t8.map((v3) => {
          let [m, n2] = v3;
          var d2;
          return m = {
            ...m,
            propertyOffset: (d2 = i.get(m.property)) !== null && d2 !== void 0 ? d2 : 0n
          }, [
            m,
            n2
          ];
        });
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      sort(t8) {
        return t8 = this.remapArbitraryVariantOffsets(t8), t8 = this.sortArbitraryProperties(t8), t8.sort(([e2], [r2]) => (0, a.default)(this.compare(e2, r2)));
      }
    }
    function f(c2) {
      let t8 = null;
      for (const e2 of c2)
        t8 = t8 ?? e2, t8 = t8 > e2 ? t8 : e2;
      return t8;
    }
    function s2(c2, t8) {
      let e2 = c2.length, r2 = t8.length, i = e2 < r2 ? e2 : r2;
      for (let o2 = 0; o2 < i; o2++) {
        let v3 = c2.charCodeAt(o2) - t8.charCodeAt(o2);
        if (v3 !== 0) return v3;
      }
      return e2 - r2;
    }
  }(ai)), ai;
}
var Wo3;
function Ki2() {
  return Wo3 || (Wo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(Y3, G3) {
      for (var te2 in G3) Object.defineProperty(Y3, te2, {
        enumerable: true,
        get: G3[te2]
      });
    }
    a(u, {
      INTERNAL_FEATURES: function() {
        return M2;
      },
      isValidVariantFormatString: function() {
        return I3;
      },
      parseVariant: function() {
        return N3;
      },
      getFileModifiedMap: function() {
        return U2;
      },
      createContext: function() {
        return de3;
      },
      getContext: function() {
        return ke3;
      }
    });
    const h7 = b3(Ne3), p = b3(Ne3), l2 = b3(Be2()), f = b3(Nl()), s2 = b3(Ke3()), c2 = b3(pr3()), t8 = b3(tu3()), e2 = b3(Hi2()), r2 = b3(ut3()), i = b3(ft3()), o2 = q2(nu3()), v3 = gr3(), m = If(), n2 = q2(yr3()), d2 = Wi2(), _3 = b3(tt3()), w3 = b3(ji2()), y2 = b3(au3()), x = wr3(), g2 = Mf(), O3 = Lf(), A = it3(), E2 = ru3();
    function b3(Y3) {
      return Y3 && Y3.__esModule ? Y3 : {
        default: Y3
      };
    }
    function k3(Y3) {
      if (typeof WeakMap != "function") return null;
      var G3 = /* @__PURE__ */ new WeakMap(), te2 = /* @__PURE__ */ new WeakMap();
      return (k3 = function(Z3) {
        return Z3 ? te2 : G3;
      })(Y3);
    }
    function q2(Y3, G3) {
      if (Y3 && Y3.__esModule)
        return Y3;
      if (Y3 === null || typeof Y3 != "object" && typeof Y3 != "function")
        return {
          default: Y3
        };
      var te2 = k3(G3);
      if (te2 && te2.has(Y3))
        return te2.get(Y3);
      var Z3 = {}, ee3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var se3 in Y3)
        if (se3 !== "default" && Object.prototype.hasOwnProperty.call(Y3, se3)) {
          var ue = ee3 ? Object.getOwnPropertyDescriptor(Y3, se3) : null;
          ue && (ue.get || ue.set) ? Object.defineProperty(Z3, se3, ue) : Z3[se3] = Y3[se3];
        }
      return Z3.default = Y3, te2 && te2.set(Y3, Z3), Z3;
    }
    const M2 = Symbol(), W3 = {
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, S3 = {
      Base: 1,
      Dynamic: 2
    };
    function P3(Y3, G3) {
      let te2 = Y3.tailwindConfig.prefix;
      return typeof te2 == "function" ? te2(G3) : te2 + G3;
    }
    function C({ type: Y3 = "any", ...G3 }) {
      let te2 = [].concat(Y3);
      return {
        ...G3,
        types: te2.map((Z3) => Array.isArray(Z3) ? {
          type: Z3[0],
          ...Z3[1]
        } : {
          type: Z3,
          preferOnConflict: false
        })
      };
    }
    function R3(Y3) {
      let G3 = [], te2 = "", Z3 = 0;
      for (let ee3 = 0; ee3 < Y3.length; ee3++) {
        let se3 = Y3[ee3];
        if (se3 === "\\")
          te2 += "\\" + Y3[++ee3];
        else if (se3 === "{")
          ++Z3, G3.push(te2.trim()), te2 = "";
        else if (se3 === "}") {
          if (--Z3 < 0)
            throw new Error("Your { and } are unbalanced.");
          G3.push(te2.trim()), te2 = "";
        } else
          te2 += se3;
      }
      return te2.length > 0 && G3.push(te2.trim()), G3 = G3.filter((ee3) => ee3 !== ""), G3;
    }
    function $2(Y3, G3, { before: te2 = [] } = {}) {
      if (te2 = [].concat(te2), te2.length <= 0) {
        Y3.push(G3);
        return;
      }
      let Z3 = Y3.length - 1;
      for (let ee3 of te2) {
        let se3 = Y3.indexOf(ee3);
        se3 !== -1 && (Z3 = Math.min(Z3, se3));
      }
      Y3.splice(Z3, 0, G3);
    }
    function B3(Y3) {
      return Array.isArray(Y3) ? Y3.flatMap((G3) => !Array.isArray(G3) && !(0, r2.default)(G3) ? G3 : (0, t8.default)(G3)) : B3([
        Y3
      ]);
    }
    function z3(Y3, G3) {
      return (0, s2.default)((Z3) => {
        let ee3 = [];
        return G3 && G3(Z3), Z3.walkClasses((se3) => {
          ee3.push(se3.value);
        }), ee3;
      }).transformSync(Y3);
    }
    function L3(Y3) {
      Y3.walkPseudos((G3) => {
        G3.value === ":not" && G3.remove();
      });
    }
    function F(Y3, G3 = {
      containsNonOnDemandable: false
    }, te2 = 0) {
      let Z3 = [], ee3 = [];
      Y3.type === "rule" ? ee3.push(...Y3.selectors) : Y3.type === "atrule" && Y3.walkRules((se3) => ee3.push(...se3.selectors));
      for (let se3 of ee3) {
        let ue = z3(se3, L3);
        ue.length === 0 && (G3.containsNonOnDemandable = true);
        for (let xe3 of ue)
          Z3.push(xe3);
      }
      return te2 === 0 ? [
        G3.containsNonOnDemandable || Z3.length === 0,
        Z3
      ] : Z3;
    }
    function D(Y3) {
      return B3(Y3).flatMap((G3) => {
        let te2 = /* @__PURE__ */ new Map(), [Z3, ee3] = F(G3);
        return Z3 && ee3.unshift(n2.NOT_ON_DEMAND), ee3.map((se3) => (te2.has(G3) || te2.set(G3, G3), [
          se3,
          te2.get(G3)
        ]));
      });
    }
    function I3(Y3) {
      return Y3.startsWith("@") || Y3.includes("&");
    }
    function N3(Y3) {
      Y3 = Y3.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let G3 = R3(Y3).map((te2) => {
        if (!te2.startsWith("@"))
          return ({ format: ue }) => ue(te2);
        let [, Z3, ee3] = /@(\S*)( .+|[({].*)?/g.exec(te2);
        var se3;
        return ({ wrap: ue }) => ue(l2.default.atRule({
          name: Z3,
          params: (se3 = ee3 == null ? void 0 : ee3.trim()) !== null && se3 !== void 0 ? se3 : ""
        }));
      }).reverse();
      return (te2) => {
        for (let Z3 of G3)
          Z3(te2);
      };
    }
    function J3(Y3, G3, { variantList: te2, variantMap: Z3, offsets: ee3, classList: se3 }) {
      function ue(ae3, re3) {
        return ae3 ? (0, f.default)(Y3, ae3, re3) : Y3;
      }
      function xe3(ae3) {
        return (0, e2.default)(Y3.prefix, ae3);
      }
      function ce3(ae3, re3) {
        return ae3 === n2.NOT_ON_DEMAND ? n2.NOT_ON_DEMAND : re3.respectPrefix ? G3.tailwindConfig.prefix + ae3 : ae3;
      }
      function Te3(ae3, re3, fe3 = {}) {
        let we3 = (0, d2.toPath)(ae3), ye2 = ue([
          "theme",
          ...we3
        ], re3);
        return (0, c2.default)(we3[0])(ye2, fe3);
      }
      let ve3 = 0, Ae3 = {
        postcss: l2.default,
        prefix: xe3,
        e: i.default,
        config: ue,
        theme: Te3,
        corePlugins: (ae3) => Array.isArray(Y3.corePlugins) ? Y3.corePlugins.includes(ae3) : ue([
          "corePlugins",
          ae3
        ], true),
        variants: () => [],
        addBase(ae3) {
          for (let [re3, fe3] of D(ae3)) {
            let we3 = ce3(re3, {}), ye2 = ee3.create("base");
            G3.candidateRuleMap.has(we3) || G3.candidateRuleMap.set(we3, []), G3.candidateRuleMap.get(we3).push([
              {
                sort: ye2,
                layer: "base"
              },
              fe3
            ]);
          }
        },
        /**
        * @param {string} group
        * @param {Record<string, string | string[]>} declarations
        */
        addDefaults(ae3, re3) {
          const fe3 = {
            [`@defaults ${ae3}`]: re3
          };
          for (let [we3, ye2] of D(fe3)) {
            let he3 = ce3(we3, {});
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("defaults"),
                layer: "defaults"
              },
              ye2
            ]);
          }
        },
        addComponents(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: false
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("components"),
                layer: "components",
                options: re3
              },
              ye2
            ]);
          }
        },
        addUtilities(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: true
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("utilities"),
                layer: "utilities",
                options: re3
              },
              ye2
            ]);
          }
        },
        matchUtilities: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: true,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("utilities");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y3);
              if (pe3 === void 0)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _3.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _3.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "utilities",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        matchComponents: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: false,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("components");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y3);
              if (pe3 === void 0)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _3.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _3.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "components",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        addVariant(ae3, re3, fe3 = {}) {
          re3 = [].concat(re3).map((we3) => {
            if (typeof we3 != "string")
              return (ye2 = {}) => {
                let { args: he3, modifySelectors: Ce3, container: qe3, separator: ge3, wrap: Se3, format: me3 } = ye2, pe3 = we3(Object.assign({
                  modifySelectors: Ce3,
                  container: qe3,
                  separator: ge3
                }, fe3.type === W3.MatchVariant && {
                  args: he3,
                  wrap: Se3,
                  format: me3
                }));
                if (typeof pe3 == "string" && !I3(pe3))
                  throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(pe3) ? pe3.filter((Oe3) => typeof Oe3 == "string").map((Oe3) => N3(Oe3)) : pe3 && typeof pe3 == "string" && N3(pe3)(ye2);
              };
            if (!I3(we3))
              throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return N3(we3);
          }), $2(te2, ae3, fe3), Z3.set(ae3, re3), G3.variantOptions.set(ae3, fe3);
        },
        matchVariant(ae3, re3, fe3) {
          var we3;
          let ye2 = (we3 = fe3 == null ? void 0 : fe3.id) !== null && we3 !== void 0 ? we3 : ++ve3, he3 = ae3 === "@", Ce3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
          var qe3;
          for (let [me3, pe3] of Object.entries((qe3 = fe3 == null ? void 0 : fe3.values) !== null && qe3 !== void 0 ? qe3 : {}))
            me3 !== "DEFAULT" && Ae3.addVariant(he3 ? `${ae3}${me3}` : `${ae3}-${me3}`, ({ args: Oe3, container: Ue3 }) => re3(pe3, Ce3 ? {
              modifier: Oe3 == null ? void 0 : Oe3.modifier,
              container: Ue3
            } : {
              container: Ue3
            }), {
              ...fe3,
              value: pe3,
              id: ye2,
              type: W3.MatchVariant,
              variantInfo: S3.Base
            });
          var ge3;
          let Se3 = "DEFAULT" in ((ge3 = fe3 == null ? void 0 : fe3.values) !== null && ge3 !== void 0 ? ge3 : {});
          Ae3.addVariant(ae3, ({ args: me3, container: pe3 }) => {
            if ((me3 == null ? void 0 : me3.value) === n2.NONE && !Se3)
              return null;
            var Oe3;
            return re3((me3 == null ? void 0 : me3.value) === n2.NONE ? fe3.values.DEFAULT : (Oe3 = me3 == null ? void 0 : me3.value) !== null && Oe3 !== void 0 ? Oe3 : typeof me3 == "string" ? me3 : "", Ce3 ? {
              modifier: me3 == null ? void 0 : me3.modifier,
              container: pe3
            } : {
              container: pe3
            });
          }, {
            ...fe3,
            id: ye2,
            type: W3.MatchVariant,
            variantInfo: S3.Dynamic
          });
        }
      };
      return Ae3;
    }
    let T3 = /* @__PURE__ */ new WeakMap();
    function U2(Y3) {
      return T3.has(Y3) || T3.set(Y3, /* @__PURE__ */ new Map()), T3.get(Y3);
    }
    function j3(Y3, G3) {
      let te2 = false, Z3 = /* @__PURE__ */ new Map();
      for (let se3 of Y3) {
        var ee3;
        if (!se3) continue;
        let ue = p.default.parse(se3), xe3 = ue.hash ? ue.href.replace(ue.hash, "") : ue.href;
        xe3 = ue.search ? xe3.replace(ue.search, "") : xe3;
        let ce3 = (ee3 = h7.default.statSync(decodeURIComponent(xe3), {
          throwIfNoEntry: false
        })) === null || ee3 === void 0 ? void 0 : ee3.mtimeMs;
        ce3 && ((!G3.has(se3) || ce3 > G3.get(se3)) && (te2 = true), Z3.set(se3, ce3));
      }
      return [
        te2,
        Z3
      ];
    }
    function H3(Y3) {
      Y3.walkAtRules((G3) => {
        [
          "responsive",
          "variants"
        ].includes(G3.name) && (H3(G3), G3.before(G3.nodes), G3.remove());
      });
    }
    function V4(Y3) {
      let G3 = [];
      return Y3.each((te2) => {
        te2.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(te2.name) && (te2.name = "layer", te2.params = "utilities");
      }), Y3.walkAtRules("layer", (te2) => {
        if (H3(te2), te2.params === "base") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addBase: ee3 }) {
              ee3(Z3, {
                respectPrefix: false
              });
            });
          te2.remove();
        } else if (te2.params === "components") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addComponents: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        } else if (te2.params === "utilities") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addUtilities: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        }
      }), G3;
    }
    function K3(Y3, G3) {
      let te2 = Object.entries({
        ...m.variantPlugins,
        ...m.corePlugins
      }).map(([ce3, Te3]) => Y3.tailwindConfig.corePlugins.includes(ce3) ? Te3 : null).filter(Boolean), Z3 = Y3.tailwindConfig.plugins.map((ce3) => (ce3.__isOptionsFunction && (ce3 = ce3()), typeof ce3 == "function" ? ce3 : ce3.handler)), ee3 = V4(G3), se3 = [
        m.variantPlugins.childVariant,
        m.variantPlugins.pseudoElementVariants,
        m.variantPlugins.pseudoClassVariants,
        m.variantPlugins.hasVariants,
        m.variantPlugins.ariaVariants,
        m.variantPlugins.dataVariants
      ], ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ];
      return (Y3.tailwindConfig.darkMode === "class" || Array.isArray(Y3.tailwindConfig.darkMode) && Y3.tailwindConfig.darkMode[0] === "class") && (ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ]), [
        ...te2,
        ...se3,
        ...Z3,
        ...ue,
        ...ee3
      ];
    }
    function X3(Y3, G3) {
      let te2 = [], Z3 = /* @__PURE__ */ new Map();
      G3.variantMap = Z3;
      let ee3 = new O3.Offsets();
      G3.offsets = ee3;
      let se3 = /* @__PURE__ */ new Set(), ue = J3(G3.tailwindConfig, G3, {
        variantList: te2,
        variantMap: Z3,
        offsets: ee3,
        classList: se3
      });
      for (let re3 of Y3)
        if (Array.isArray(re3))
          for (let fe3 of re3)
            fe3(ue);
        else
          re3 == null || re3(ue);
      ee3.recordVariants(te2, (re3) => Z3.get(re3).length);
      for (let [re3, fe3] of Z3.entries())
        G3.variantMap.set(re3, fe3.map((we3, ye2) => [
          ee3.forVariant(re3, ye2),
          we3
        ]));
      var xe3;
      let ce3 = ((xe3 = G3.tailwindConfig.safelist) !== null && xe3 !== void 0 ? xe3 : []).filter(Boolean);
      if (ce3.length > 0) {
        let re3 = [];
        for (let fe3 of ce3) {
          if (typeof fe3 == "string") {
            G3.changedContent.push({
              content: fe3,
              extension: "html"
            });
            continue;
          }
          if (fe3 instanceof RegExp) {
            _3.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          re3.push(fe3);
        }
        if (re3.length > 0) {
          let fe3 = /* @__PURE__ */ new Map(), we3 = G3.tailwindConfig.prefix.length, ye2 = re3.some((he3) => he3.pattern.source.includes("!"));
          for (let he3 of se3) {
            let Ce3 = Array.isArray(he3) ? (() => {
              let [qe3, ge3] = he3;
              var Se3;
              let pe3 = Object.keys((Se3 = ge3 == null ? void 0 : ge3.values) !== null && Se3 !== void 0 ? Se3 : {}).map((Oe3) => (0, o2.formatClass)(qe3, Oe3));
              return ge3 != null && ge3.supportsNegativeValues && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "-" + Oe3)
              ], pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => Oe3.slice(0, we3) + "-" + Oe3.slice(we3))
              ]), ge3.types.some(({ type: Oe3 }) => Oe3 === "color") && (pe3 = [
                ...pe3,
                ...pe3.flatMap((Oe3) => Object.keys(G3.tailwindConfig.theme.opacity).map((Ue3) => `${Oe3}/${Ue3}`))
              ]), ye2 && (ge3 != null && ge3.respectImportant) && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "!" + Oe3)
              ]), pe3;
            })() : [
              he3
            ];
            for (let qe3 of Ce3)
              for (let { pattern: ge3, variants: Se3 = [] } of re3)
                if (ge3.lastIndex = 0, fe3.has(ge3) || fe3.set(ge3, 0), !!ge3.test(qe3)) {
                  fe3.set(ge3, fe3.get(ge3) + 1), G3.changedContent.push({
                    content: qe3,
                    extension: "html"
                  });
                  for (let me3 of Se3)
                    G3.changedContent.push({
                      content: me3 + G3.tailwindConfig.separator + qe3,
                      extension: "html"
                    });
                }
          }
          for (let [he3, Ce3] of fe3.entries())
            Ce3 === 0 && _3.default.warn([
              `The safelist pattern \`${he3}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var Te3, ve3;
      let Ae3 = (ve3 = [].concat((Te3 = G3.tailwindConfig.darkMode) !== null && Te3 !== void 0 ? Te3 : "media")[1]) !== null && ve3 !== void 0 ? ve3 : "dark", ae3 = [
        P3(G3, Ae3),
        P3(G3, "group"),
        P3(G3, "peer")
      ];
      G3.getClassOrder = function(fe3) {
        let we3 = [
          ...fe3
        ].sort((ge3, Se3) => ge3 === Se3 ? 0 : ge3 < Se3 ? -1 : 1), ye2 = new Map(we3.map((ge3) => [
          ge3,
          null
        ])), he3 = (0, x.generateRules)(new Set(we3), G3, true);
        he3 = G3.offsets.sort(he3);
        let Ce3 = BigInt(ae3.length);
        for (const [, ge3] of he3) {
          let Se3 = ge3.raws.tailwind.candidate;
          var qe3;
          ye2.set(Se3, (qe3 = ye2.get(Se3)) !== null && qe3 !== void 0 ? qe3 : Ce3++);
        }
        return fe3.map((ge3) => {
          var Se3;
          let me3 = (Se3 = ye2.get(ge3)) !== null && Se3 !== void 0 ? Se3 : null, pe3 = ae3.indexOf(ge3);
          return me3 === null && pe3 !== -1 && (me3 = BigInt(pe3)), [
            ge3,
            me3
          ];
        });
      }, G3.getClassList = function(fe3 = {}) {
        let we3 = [];
        for (let ge3 of se3)
          if (Array.isArray(ge3)) {
            var ye2;
            let [Se3, me3] = ge3, pe3 = [];
            var he3;
            let Oe3 = Object.keys((he3 = me3 == null ? void 0 : me3.modifiers) !== null && he3 !== void 0 ? he3 : {});
            if (!(me3 == null || (ye2 = me3.types) === null || ye2 === void 0) && ye2.some(({ type: ze3 }) => ze3 === "color")) {
              var Ce3;
              Oe3.push(...Object.keys((Ce3 = G3.tailwindConfig.theme.opacity) !== null && Ce3 !== void 0 ? Ce3 : {}));
            }
            let Ue3 = {
              modifiers: Oe3
            }, Xe3 = fe3.includeMetadata && Oe3.length > 0;
            var qe3;
            for (let [ze3, Ze3] of Object.entries((qe3 = me3 == null ? void 0 : me3.values) !== null && qe3 !== void 0 ? qe3 : {})) {
              if (Ze3 == null)
                continue;
              let We2 = (0, o2.formatClass)(Se3, ze3);
              if (we3.push(Xe3 ? [
                We2,
                Ue3
              ] : We2), me3 != null && me3.supportsNegativeValues && (0, w3.default)(Ze3)) {
                let Je3 = (0, o2.formatClass)(Se3, `-${ze3}`);
                pe3.push(Xe3 ? [
                  Je3,
                  Ue3
                ] : Je3);
              }
            }
            we3.push(...pe3);
          } else
            we3.push(ge3);
        return we3;
      }, G3.getVariants = function() {
        let fe3 = Math.random().toString(36).substring(7).toUpperCase(), we3 = [];
        for (let [he3, Ce3] of G3.variantOptions.entries())
          if (Ce3.variantInfo !== S3.Base) {
            var ye2;
            we3.push({
              name: he3,
              isArbitrary: Ce3.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((ye2 = Ce3.values) !== null && ye2 !== void 0 ? ye2 : {}),
              hasDash: he3 !== "@",
              selectors({ modifier: qe3, value: ge3 } = {}) {
                let Se3 = `TAILWINDPLACEHOLDER${fe3}`, me3 = l2.default.rule({
                  selector: `.${Se3}`
                }), pe3 = l2.default.root({
                  nodes: [
                    me3.clone()
                  ]
                }), Oe3 = pe3.toString();
                var Ue3;
                let Xe3 = ((Ue3 = G3.variantMap.get(he3)) !== null && Ue3 !== void 0 ? Ue3 : []).flatMap(([Ve3, je3]) => je3), ze3 = [];
                for (let Ve3 of Xe3) {
                  var Ze3;
                  let je3 = [];
                  var We2;
                  let ct3 = {
                    args: {
                      modifier: qe3,
                      value: (We2 = (Ze3 = Ce3.values) === null || Ze3 === void 0 ? void 0 : Ze3[ge3]) !== null && We2 !== void 0 ? We2 : ge3
                    },
                    separator: G3.tailwindConfig.separator,
                    modifySelectors(Ge4) {
                      return pe3.each((xr3) => {
                        xr3.type === "rule" && (xr3.selectors = xr3.selectors.map((ea2) => Ge4({
                          get className() {
                            return (0, x.getClassNameFromSelector)(ea2);
                          },
                          selector: ea2
                        })));
                      }), pe3;
                    },
                    format(Ge4) {
                      je3.push(Ge4);
                    },
                    wrap(Ge4) {
                      je3.push(`@${Ge4.name} ${Ge4.params} { & }`);
                    },
                    container: pe3
                  }, dt2 = Ve3(ct3);
                  if (je3.length > 0 && ze3.push(je3), Array.isArray(dt2))
                    for (let Ge4 of dt2)
                      je3 = [], Ge4(ct3), ze3.push(je3);
                }
                let Je3 = [], ou3 = pe3.toString();
                Oe3 !== ou3 && (pe3.walkRules((Ve3) => {
                  let je3 = Ve3.selector, ct3 = (0, s2.default)((dt2) => {
                    dt2.walkClasses((Ge4) => {
                      Ge4.value = `${he3}${G3.tailwindConfig.separator}${Ge4.value}`;
                    });
                  }).processSync(je3);
                  Je3.push(je3.replace(ct3, "&").replace(Se3, "&"));
                }), pe3.walkAtRules((Ve3) => {
                  Je3.push(`@${Ve3.name} (${Ve3.params}) { & }`);
                }));
                var br3;
                let lu = !(ge3 in ((br3 = Ce3.values) !== null && br3 !== void 0 ? br3 : {}));
                var _r3;
                let uu3 = (_r3 = Ce3[M2]) !== null && _r3 !== void 0 ? _r3 : {}, Xi2 = !(lu || uu3.respectPrefix === false);
                ze3 = ze3.map((Ve3) => Ve3.map((je3) => ({
                  format: je3,
                  respectPrefix: Xi2
                }))), Je3 = Je3.map((Ve3) => ({
                  format: Ve3,
                  respectPrefix: Xi2
                }));
                let Sr3 = {
                  candidate: Se3,
                  context: G3
                }, Zi2 = ze3.map((Ve3) => (0, E2.finalizeSelector)(`.${Se3}`, (0, E2.formatVariantSelector)(Ve3, Sr3), Sr3).replace(`.${Se3}`, "&").replace("{ & }", "").trim());
                return Je3.length > 0 && Zi2.push((0, E2.formatVariantSelector)(Je3, Sr3).toString().replace(`.${Se3}`, "&")), Zi2;
              }
            });
          }
        return we3;
      };
    }
    function Q3(Y3, G3) {
      Y3.classCache.has(G3) && (Y3.notClassCache.add(G3), Y3.classCache.delete(G3), Y3.applyClassCache.delete(G3), Y3.candidateRuleMap.delete(G3), Y3.candidateRuleCache.delete(G3), Y3.stylesheetCache = null);
    }
    function ne3(Y3, G3) {
      let te2 = G3.raws.tailwind.candidate;
      if (te2) {
        for (const Z3 of Y3.ruleCache)
          Z3[1].raws.tailwind.candidate === te2 && Y3.ruleCache.delete(Z3);
        Q3(Y3, te2);
      }
    }
    function de3(Y3, G3 = [], te2 = l2.default.root()) {
      var Z3;
      let ee3 = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((Z3 = Y3.blocklist) !== null && Z3 !== void 0 ? Z3 : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig: Y3,
        changedContent: G3,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (ue) => Q3(ee3, ue),
        markInvalidUtilityNode: (ue) => ne3(ee3, ue)
      }, se3 = K3(ee3, te2);
      return X3(se3, ee3), ee3;
    }
    let _e3 = n2.contextMap, be3 = n2.configContextMap, ie3 = n2.contextSourcesMap;
    function ke3(Y3, G3, te2, Z3, ee3, se3) {
      let ue = G3.opts.from, xe3 = Z3 !== null;
      n2.env.DEBUG && console.log("Source path:", ue);
      let ce3;
      if (xe3 && _e3.has(ue))
        ce3 = _e3.get(ue);
      else if (be3.has(ee3)) {
        let ae3 = be3.get(ee3);
        ie3.get(ae3).add(ue), _e3.set(ue, ae3), ce3 = ae3;
      }
      let Te3 = (0, g2.hasContentChanged)(ue, Y3);
      if (ce3) {
        let [ae3, re3] = j3([
          ...se3
        ], U2(ce3));
        if (!ae3 && !Te3)
          return [
            ce3,
            false,
            re3
          ];
      }
      if (_e3.has(ue)) {
        let ae3 = _e3.get(ue);
        if (ie3.has(ae3) && (ie3.get(ae3).delete(ue), ie3.get(ae3).size === 0)) {
          ie3.delete(ae3);
          for (let [re3, fe3] of be3)
            fe3 === ae3 && be3.delete(re3);
          for (let re3 of ae3.disposables.splice(0))
            re3(ae3);
        }
      }
      n2.env.DEBUG && console.log("Setting up new context...");
      let ve3 = de3(te2, [], Y3);
      Object.assign(ve3, {
        userConfigPath: Z3
      });
      let [, Ae3] = j3([
        ...se3
      ], U2(ve3));
      return be3.set(ee3, ve3), _e3.set(ue, ve3), ie3.has(ve3) || ie3.set(ve3, /* @__PURE__ */ new Set()), ie3.get(ve3).add(ue), [
        ve3,
        true,
        Ae3
      ];
    }
  }(Jn3)), Jn3;
}
var li2 = {};
var Vo3;
function su3() {
  return Vo3 || (Vo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "applyImportantSelector", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(Ke3()), h7 = Ji2();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f, s2) {
      let c2 = (0, a.default)().astSync(f);
      return c2.each((t8) => {
        t8.nodes.some((r2) => r2.type === "combinator") && (t8.nodes = [
          a.default.pseudo({
            value: ":is",
            nodes: [
              t8.clone()
            ]
          })
        ]), (0, h7.movePseudos)(t8);
      }), `${s2} ${c2.toString()}`;
    }
  }(li2)), li2;
}
var jo3;
function wr3() {
  return jo3 || (jo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(T3, U2) {
      for (var j3 in U2) Object.defineProperty(T3, j3, {
        enumerable: true,
        get: U2[j3]
      });
    }
    a(u, {
      getClassNameFromSelector: function() {
        return O3;
      },
      resolveMatches: function() {
        return L3;
      },
      generateRules: function() {
        return N3;
      }
    });
    const h7 = w3(Be2()), p = w3(Ke3()), l2 = w3(tu3()), f = w3(ut3()), s2 = w3(Hi2()), c2 = gr3(), t8 = w3(tt3()), e2 = x(yr3()), r2 = ru3(), i = nu3(), o2 = vr3(), v3 = Ki2(), m = w3(au3()), n2 = st3(), d2 = it3(), _3 = su3();
    function w3(T3) {
      return T3 && T3.__esModule ? T3 : {
        default: T3
      };
    }
    function y2(T3) {
      if (typeof WeakMap != "function") return null;
      var U2 = /* @__PURE__ */ new WeakMap(), j3 = /* @__PURE__ */ new WeakMap();
      return (y2 = function(H3) {
        return H3 ? j3 : U2;
      })(T3);
    }
    function x(T3, U2) {
      if (T3 && T3.__esModule)
        return T3;
      if (T3 === null || typeof T3 != "object" && typeof T3 != "function")
        return {
          default: T3
        };
      var j3 = y2(U2);
      if (j3 && j3.has(T3))
        return j3.get(T3);
      var H3 = {}, V4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var K3 in T3)
        if (K3 !== "default" && Object.prototype.hasOwnProperty.call(T3, K3)) {
          var X3 = V4 ? Object.getOwnPropertyDescriptor(T3, K3) : null;
          X3 && (X3.get || X3.set) ? Object.defineProperty(H3, K3, X3) : H3[K3] = T3[K3];
        }
      return H3.default = T3, j3 && j3.set(T3, H3), H3;
    }
    let g2 = (0, p.default)((T3) => T3.first.filter(({ type: U2 }) => U2 === "class").pop().value);
    function O3(T3) {
      return g2.transformSync(T3);
    }
    function* A(T3) {
      let U2 = 1 / 0;
      for (; U2 >= 0; ) {
        let j3, H3 = false;
        if (U2 === 1 / 0 && T3.endsWith("]")) {
          let X3 = T3.indexOf("[");
          T3[X3 - 1] === "-" ? j3 = X3 - 1 : T3[X3 - 1] === "/" ? (j3 = X3 - 1, H3 = true) : j3 = -1;
        } else U2 === 1 / 0 && T3.includes("/") ? (j3 = T3.lastIndexOf("/"), H3 = true) : j3 = T3.lastIndexOf("-", U2);
        if (j3 < 0)
          break;
        let V4 = T3.slice(0, j3), K3 = T3.slice(H3 ? j3 : j3 + 1);
        U2 = j3 - 1, !(V4 === "" || K3 === "/") && (yield [
          V4,
          K3
        ]);
      }
    }
    function E2(T3, U2) {
      if (T3.length === 0 || U2.tailwindConfig.prefix === "")
        return T3;
      for (let j3 of T3) {
        let [H3] = j3;
        if (H3.options.respectPrefix) {
          let V4 = h7.default.root({
            nodes: [
              j3[1].clone()
            ]
          }), K3 = j3[1].raws.tailwind.classCandidate;
          V4.walkRules((X3) => {
            let Q3 = K3.startsWith("-");
            X3.selector = (0, s2.default)(U2.tailwindConfig.prefix, X3.selector, Q3);
          }), j3[1] = V4.nodes[0];
        }
      }
      return T3;
    }
    function b3(T3, U2) {
      if (T3.length === 0)
        return T3;
      let j3 = [];
      function H3(V4) {
        return V4.parent && V4.parent.type === "atrule" && V4.parent.name === "keyframes";
      }
      for (let [V4, K3] of T3) {
        let X3 = h7.default.root({
          nodes: [
            K3.clone()
          ]
        });
        X3.walkRules((Q3) => {
          if (H3(Q3))
            return;
          let ne3 = (0, p.default)().astSync(Q3.selector);
          ne3.each((de3) => (0, r2.eliminateIrrelevantSelectors)(de3, U2)), (0, c2.updateAllClasses)(ne3, (de3) => de3 === U2 ? `!${de3}` : de3), Q3.selector = ne3.toString(), Q3.walkDecls((de3) => de3.important = true);
        }), j3.push([
          {
            ...V4,
            important: true
          },
          X3.nodes[0]
        ]);
      }
      return j3;
    }
    function k3(T3, U2, j3) {
      if (U2.length === 0)
        return U2;
      let H3 = {
        modifier: null,
        value: e2.NONE
      };
      {
        let [Q3, ...ne3] = (0, n2.splitAtTopLevelOnly)(T3, "/");
        if (ne3.length > 1 && (Q3 = Q3 + "/" + ne3.slice(0, -1).join("/"), ne3 = ne3.slice(-1)), ne3.length && !j3.variantMap.has(T3) && (T3 = Q3, H3.modifier = ne3[0], !(0, d2.flagEnabled)(j3.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if (T3.endsWith("]") && !T3.startsWith("[")) {
        let Q3 = /(.)(-?)\[(.*)\]/g.exec(T3);
        if (Q3) {
          let [, ne3, de3, _e3] = Q3;
          if (ne3 === "@" && de3 === "-") return [];
          if (ne3 !== "@" && de3 === "") return [];
          T3 = T3.replace(`${de3}[${_e3}]`, ""), H3.value = _e3;
        }
      }
      if (J3(T3) && !j3.variantMap.has(T3)) {
        let Q3 = j3.offsets.recordVariant(T3), ne3 = (0, o2.normalize)(T3.slice(1, -1)), de3 = (0, n2.splitAtTopLevelOnly)(ne3, ",");
        if (de3.length > 1)
          return [];
        if (!de3.every(v3.isValidVariantFormatString))
          return [];
        let _e3 = de3.map((be3, ie3) => [
          j3.offsets.applyParallelOffset(Q3, ie3),
          (0, v3.parseVariant)(be3.trim())
        ]);
        j3.variantMap.set(T3, _e3);
      }
      if (j3.variantMap.has(T3)) {
        var V4;
        let Q3 = J3(T3);
        var K3;
        let ne3 = (K3 = (V4 = j3.variantOptions.get(T3)) === null || V4 === void 0 ? void 0 : V4[v3.INTERNAL_FEATURES]) !== null && K3 !== void 0 ? K3 : {}, de3 = j3.variantMap.get(T3).slice(), _e3 = [], be3 = !(Q3 || ne3.respectPrefix === false);
        for (let [ie3, ke3] of U2) {
          if (ie3.layer === "user")
            continue;
          let Y3 = h7.default.root({
            nodes: [
              ke3.clone()
            ]
          });
          for (let [G3, te2, Z3] of de3) {
            let ue = function() {
              ee3.raws.neededBackup || (ee3.raws.neededBackup = true, ee3.walkRules((ve3) => ve3.raws.originalSelector = ve3.selector));
            }, xe3 = function(ve3) {
              return ue(), ee3.each((Ae3) => {
                Ae3.type === "rule" && (Ae3.selectors = Ae3.selectors.map((ae3) => ve3({
                  get className() {
                    return O3(ae3);
                  },
                  selector: ae3
                })));
              }), ee3;
            }, ee3 = (Z3 ?? Y3).clone(), se3 = [], ce3 = te2({
              // Public API
              get container() {
                return ue(), ee3;
              },
              separator: j3.tailwindConfig.separator,
              modifySelectors: xe3,
              // Private API for now
              wrap(ve3) {
                let Ae3 = ee3.nodes;
                ee3.removeAll(), ve3.append(Ae3), ee3.append(ve3);
              },
              format(ve3) {
                se3.push({
                  format: ve3,
                  respectPrefix: be3
                });
              },
              args: H3
            });
            if (Array.isArray(ce3)) {
              for (let [ve3, Ae3] of ce3.entries())
                de3.push([
                  j3.offsets.applyParallelOffset(G3, ve3),
                  Ae3,
                  // If the clone has been modified we have to pass that back
                  // though so each rule can use the modified container
                  ee3.clone()
                ]);
              continue;
            }
            if (typeof ce3 == "string" && se3.push({
              format: ce3,
              respectPrefix: be3
            }), ce3 === null)
              continue;
            ee3.raws.neededBackup && (delete ee3.raws.neededBackup, ee3.walkRules((ve3) => {
              let Ae3 = ve3.raws.originalSelector;
              if (!Ae3 || (delete ve3.raws.originalSelector, Ae3 === ve3.selector)) return;
              let ae3 = ve3.selector, re3 = (0, p.default)((fe3) => {
                fe3.walkClasses((we3) => {
                  we3.value = `${T3}${j3.tailwindConfig.separator}${we3.value}`;
                });
              }).processSync(Ae3);
              se3.push({
                format: ae3.replace(re3, "&"),
                respectPrefix: be3
              }), ve3.selector = Ae3;
            })), ee3.nodes[0].raws.tailwind = {
              ...ee3.nodes[0].raws.tailwind,
              parentLayer: ie3.layer
            };
            var X3;
            let Te3 = [
              {
                ...ie3,
                sort: j3.offsets.applyVariantOffset(ie3.sort, G3, Object.assign(H3, j3.variantOptions.get(T3))),
                collectedFormats: ((X3 = ie3.collectedFormats) !== null && X3 !== void 0 ? X3 : []).concat(se3)
              },
              ee3.nodes[0]
            ];
            _e3.push(Te3);
          }
        }
        return _e3;
      }
      return [];
    }
    function q2(T3, U2, j3 = {}) {
      return !(0, f.default)(T3) && !Array.isArray(T3) ? [
        [
          T3
        ],
        j3
      ] : Array.isArray(T3) ? q2(T3[0], U2, T3[1]) : (U2.has(T3) || U2.set(T3, (0, l2.default)(T3)), [
        U2.get(T3),
        j3
      ]);
    }
    const M2 = /^[a-z_-]/;
    function W3(T3) {
      return M2.test(T3);
    }
    function S3(T3) {
      if (!T3.includes("://"))
        return false;
      try {
        const U2 = new URL(T3);
        return U2.scheme !== "" && U2.host !== "";
      } catch {
        return false;
      }
    }
    function P3(T3) {
      let U2 = true;
      return T3.walkDecls((j3) => {
        if (!C(j3.prop, j3.value))
          return U2 = false, false;
      }), U2;
    }
    function C(T3, U2) {
      if (S3(`${T3}:${U2}`))
        return false;
      try {
        return h7.default.parse(`a{${T3}:${U2}}`).toResult(), true;
      } catch {
        return false;
      }
    }
    function R3(T3, U2) {
      var j3;
      let [, H3, V4] = (j3 = T3.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && j3 !== void 0 ? j3 : [];
      if (V4 === void 0 || !W3(H3) || !(0, m.default)(V4))
        return null;
      let K3 = (0, o2.normalize)(V4, {
        property: H3
      });
      return C(H3, K3) ? [
        [
          {
            sort: U2.offsets.arbitraryProperty(T3),
            layer: "utilities",
            options: {
              respectImportant: true
            }
          },
          () => ({
            [(0, i.asClass)(T3)]: {
              [H3]: K3
            }
          })
        ]
      ] : null;
    }
    function* $2(T3, U2) {
      U2.candidateRuleMap.has(T3) && (yield [
        U2.candidateRuleMap.get(T3),
        "DEFAULT"
      ]), yield* function* (Q3) {
        Q3 !== null && (yield [
          Q3,
          "DEFAULT"
        ]);
      }(R3(T3, U2));
      let j3 = T3, H3 = false;
      const V4 = U2.tailwindConfig.prefix, K3 = V4.length, X3 = j3.startsWith(V4) || j3.startsWith(`-${V4}`);
      j3[K3] === "-" && X3 && (H3 = true, j3 = V4 + j3.slice(K3 + 1)), H3 && U2.candidateRuleMap.has(j3) && (yield [
        U2.candidateRuleMap.get(j3),
        "-DEFAULT"
      ]);
      for (let [Q3, ne3] of A(j3))
        U2.candidateRuleMap.has(Q3) && (yield [
          U2.candidateRuleMap.get(Q3),
          H3 ? `-${ne3}` : ne3
        ]);
    }
    function B3(T3, U2) {
      return T3 === e2.NOT_ON_DEMAND ? [
        e2.NOT_ON_DEMAND
      ] : (0, n2.splitAtTopLevelOnly)(T3, U2);
    }
    function* z3(T3, U2) {
      for (const V4 of T3) {
        var j3, H3;
        V4[1].raws.tailwind = {
          ...V4[1].raws.tailwind,
          classCandidate: U2,
          preserveSource: (H3 = (j3 = V4[0].options) === null || j3 === void 0 ? void 0 : j3.preserveSource) !== null && H3 !== void 0 ? H3 : false
        }, yield V4;
      }
    }
    function* L3(T3, U2) {
      let j3 = U2.tailwindConfig.separator, [H3, ...V4] = B3(T3, j3).reverse(), K3 = false;
      H3.startsWith("!") && (K3 = true, H3 = H3.slice(1));
      for (let be3 of $2(H3, U2)) {
        let ie3 = [], ke3 = /* @__PURE__ */ new Map(), [Y3, G3] = be3, te2 = Y3.length === 1;
        for (let [Z3, ee3] of Y3) {
          let se3 = [];
          if (typeof ee3 == "function")
            for (let ue of [].concat(ee3(G3, {
              isOnlyPlugin: te2
            }))) {
              let [xe3, ce3] = q2(ue, U2.postCssNodeCache);
              for (let Te3 of xe3)
                se3.push([
                  {
                    ...Z3,
                    options: {
                      ...Z3.options,
                      ...ce3
                    }
                  },
                  Te3
                ]);
            }
          else if (G3 === "DEFAULT" || G3 === "-DEFAULT") {
            let ue = ee3, [xe3, ce3] = q2(ue, U2.postCssNodeCache);
            for (let Te3 of xe3)
              se3.push([
                {
                  ...Z3,
                  options: {
                    ...Z3.options,
                    ...ce3
                  }
                },
                Te3
              ]);
          }
          if (se3.length > 0) {
            var X3, Q3, ne3;
            let ue = Array.from((0, c2.getMatchingTypes)((Q3 = (X3 = Z3.options) === null || X3 === void 0 ? void 0 : X3.types) !== null && Q3 !== void 0 ? Q3 : [], G3, (ne3 = Z3.options) !== null && ne3 !== void 0 ? ne3 : {}, U2.tailwindConfig)).map(([xe3, ce3]) => ce3);
            ue.length > 0 && ke3.set(se3, ue), ie3.push(se3);
          }
        }
        if (J3(G3)) {
          if (ie3.length > 1) {
            let se3 = function(xe3) {
              return xe3.length === 1 ? xe3[0] : xe3.find((ce3) => {
                let Te3 = ke3.get(ce3);
                return ce3.some(([{ options: ve3 }, Ae3]) => P3(Ae3) ? ve3.types.some(({ type: ae3, preferOnConflict: re3 }) => Te3.includes(ae3) && re3) : false);
              });
            }, [Z3, ee3] = ie3.reduce((xe3, ce3) => (ce3.some(([{ options: ve3 }]) => ve3.types.some(({ type: Ae3 }) => Ae3 === "any")) ? xe3[0].push(ce3) : xe3[1].push(ce3), xe3), [
              [],
              []
            ]);
            var de3;
            let ue = (de3 = se3(ee3)) !== null && de3 !== void 0 ? de3 : se3(Z3);
            if (ue)
              ie3 = [
                ue
              ];
            else {
              var _e3;
              let xe3 = ie3.map((Te3) => /* @__PURE__ */ new Set([
                ...(_e3 = ke3.get(Te3)) !== null && _e3 !== void 0 ? _e3 : []
              ]));
              for (let Te3 of xe3)
                for (let ve3 of Te3) {
                  let Ae3 = false;
                  for (let ae3 of xe3)
                    Te3 !== ae3 && ae3.has(ve3) && (ae3.delete(ve3), Ae3 = true);
                  Ae3 && Te3.delete(ve3);
                }
              let ce3 = [];
              for (let [Te3, ve3] of xe3.entries())
                for (let Ae3 of ve3) {
                  let ae3 = ie3[Te3].map(([, re3]) => re3).flat().map((re3) => re3.toString().split(`
`).slice(1, -1).map((fe3) => fe3.trim()).map((fe3) => `      ${fe3}`).join(`
`)).join(`

`);
                  ce3.push(`  Use \`${T3.replace("[", `[${Ae3}:`)}\` for \`${ae3.trim()}\``);
                  break;
                }
              t8.default.warn([
                `The class \`${T3}\` is ambiguous and matches multiple utilities.`,
                ...ce3,
                `If this is content and not a class, replace it with \`${T3.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          ie3 = ie3.map((Z3) => Z3.filter((ee3) => P3(ee3[1])));
        }
        ie3 = ie3.flat(), ie3 = Array.from(z3(ie3, H3)), ie3 = E2(ie3, U2), K3 && (ie3 = b3(ie3, H3));
        for (let Z3 of V4)
          ie3 = k3(Z3, ie3, U2);
        for (let Z3 of ie3)
          Z3[1].raws.tailwind = {
            ...Z3[1].raws.tailwind,
            candidate: T3
          }, Z3 = F(Z3, {
            context: U2,
            candidate: T3
          }), Z3 !== null && (yield Z3);
      }
    }
    function F(T3, { context: U2, candidate: j3 }) {
      if (!T3[0].collectedFormats)
        return T3;
      let H3 = true, V4;
      try {
        V4 = (0, r2.formatVariantSelector)(T3[0].collectedFormats, {
          context: U2,
          candidate: j3
        });
      } catch {
        return null;
      }
      let K3 = h7.default.root({
        nodes: [
          T3[1].clone()
        ]
      });
      return K3.walkRules((X3) => {
        if (!D(X3))
          try {
            let Q3 = (0, r2.finalizeSelector)(X3.selector, V4, {
              candidate: j3,
              context: U2
            });
            if (Q3 === null) {
              X3.remove();
              return;
            }
            X3.selector = Q3;
          } catch {
            return H3 = false, false;
          }
      }), !H3 || K3.nodes.length === 0 ? null : (T3[1] = K3.nodes[0], T3);
    }
    function D(T3) {
      return T3.parent && T3.parent.type === "atrule" && T3.parent.name === "keyframes";
    }
    function I3(T3) {
      if (T3 === true)
        return (U2) => {
          D(U2) || U2.walkDecls((j3) => {
            j3.parent.type === "rule" && !D(j3.parent) && (j3.important = true);
          });
        };
      if (typeof T3 == "string")
        return (U2) => {
          D(U2) || (U2.selectors = U2.selectors.map((j3) => (0, _3.applyImportantSelector)(j3, T3)));
        };
    }
    function N3(T3, U2, j3 = false) {
      let H3 = [], V4 = I3(U2.tailwindConfig.important);
      for (let X3 of T3) {
        if (U2.notClassCache.has(X3))
          continue;
        if (U2.candidateRuleCache.has(X3)) {
          H3 = H3.concat(Array.from(U2.candidateRuleCache.get(X3)));
          continue;
        }
        let Q3 = Array.from(L3(X3, U2));
        if (Q3.length === 0) {
          U2.notClassCache.add(X3);
          continue;
        }
        U2.classCache.set(X3, Q3);
        var K3;
        let ne3 = (K3 = U2.candidateRuleCache.get(X3)) !== null && K3 !== void 0 ? K3 : /* @__PURE__ */ new Set();
        U2.candidateRuleCache.set(X3, ne3);
        for (const de3 of Q3) {
          let [{ sort: _e3, options: be3 }, ie3] = de3;
          if (be3.respectImportant && V4) {
            let Y3 = h7.default.root({
              nodes: [
                ie3.clone()
              ]
            });
            Y3.walkRules(V4), ie3 = Y3.nodes[0];
          }
          let ke3 = [
            _e3,
            j3 ? ie3.clone() : ie3
          ];
          ne3.add(ke3), U2.ruleCache.add(ke3), H3.push(ke3);
        }
      }
      return H3;
    }
    function J3(T3) {
      return T3.startsWith("[") && T3.endsWith("]");
    }
  }(qn3)), qn3;
}
var Bo2;
function Nf() {
  return Bo2 || (Bo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return O3;
      }
    });
    const a = c2(Be2()), h7 = c2(Ke3()), p = wr3(), l2 = c2(ft3()), f = su3(), s2 = Ji2();
    function c2(A) {
      return A && A.__esModule ? A : {
        default: A
      };
    }
    function t8(A) {
      let E2 = /* @__PURE__ */ new Map();
      a.default.root({
        nodes: [
          A.clone()
        ]
      }).walkRules((M2) => {
        (0, h7.default)((W3) => {
          W3.walkClasses((S3) => {
            let P3 = S3.parent.toString(), C = E2.get(P3);
            C || E2.set(P3, C = /* @__PURE__ */ new Set()), C.add(S3.value);
          });
        }).processSync(M2.selector);
      });
      let k3 = Array.from(E2.values(), (M2) => Array.from(M2)), q2 = k3.flat();
      return Object.assign(q2, {
        groups: k3
      });
    }
    let e2 = (0, h7.default)();
    function r2(A) {
      return e2.astSync(A);
    }
    function i(A, E2) {
      let b3 = /* @__PURE__ */ new Set();
      for (let k3 of A)
        b3.add(k3.split(E2).pop());
      return Array.from(b3);
    }
    function o2(A, E2) {
      let b3 = A.tailwindConfig.prefix;
      return typeof b3 == "function" ? b3(E2) : b3 + E2;
    }
    function* v3(A) {
      for (yield A; A.parent; )
        yield A.parent, A = A.parent;
    }
    function m(A, E2 = {}) {
      let b3 = A.nodes;
      A.nodes = [];
      let k3 = A.clone(E2);
      return A.nodes = b3, k3;
    }
    function n2(A) {
      for (let E2 of v3(A))
        if (A !== E2) {
          if (E2.type === "root")
            break;
          A = m(E2, {
            nodes: [
              A
            ]
          });
        }
      return A;
    }
    function d2(A, E2) {
      let b3 = /* @__PURE__ */ new Map();
      return A.walkRules((k3) => {
        for (let S3 of v3(k3)) {
          var q2;
          if (((q2 = S3.raws.tailwind) === null || q2 === void 0 ? void 0 : q2.layer) !== void 0)
            return;
        }
        let M2 = n2(k3), W3 = E2.offsets.create("user");
        for (let S3 of t8(k3)) {
          let P3 = b3.get(S3) || [];
          b3.set(S3, P3), P3.push([
            {
              layer: "user",
              sort: W3,
              important: false
            },
            M2
          ]);
        }
      }), b3;
    }
    function _3(A, E2) {
      for (let b3 of A) {
        if (E2.notClassCache.has(b3) || E2.applyClassCache.has(b3))
          continue;
        if (E2.classCache.has(b3)) {
          E2.applyClassCache.set(b3, E2.classCache.get(b3).map(([q2, M2]) => [
            q2,
            M2.clone()
          ]));
          continue;
        }
        let k3 = Array.from((0, p.resolveMatches)(b3, E2));
        if (k3.length === 0) {
          E2.notClassCache.add(b3);
          continue;
        }
        E2.applyClassCache.set(b3, k3);
      }
      return E2.applyClassCache;
    }
    function w3(A) {
      let E2 = null;
      return {
        get: (b3) => (E2 = E2 || A(), E2.get(b3)),
        has: (b3) => (E2 = E2 || A(), E2.has(b3))
      };
    }
    function y2(A) {
      return {
        get: (E2) => A.flatMap((b3) => b3.get(E2) || []),
        has: (E2) => A.some((b3) => b3.has(E2))
      };
    }
    function x(A) {
      let E2 = A.split(/[\s\t\n]+/g);
      return E2[E2.length - 1] === "!important" ? [
        E2.slice(0, -1),
        true
      ] : [
        E2,
        false
      ];
    }
    function g2(A, E2, b3) {
      let k3 = /* @__PURE__ */ new Set(), q2 = [];
      if (A.walkAtRules("apply", (P3) => {
        let [C] = x(P3.params);
        for (let R3 of C)
          k3.add(R3);
        q2.push(P3);
      }), q2.length === 0)
        return;
      let M2 = y2([
        b3,
        _3(k3, E2)
      ]);
      function W3(P3, C, R3) {
        let $2 = r2(P3), B3 = r2(C), L3 = r2(`.${(0, l2.default)(R3)}`).nodes[0].nodes[0];
        return $2.each((F) => {
          let D = /* @__PURE__ */ new Set();
          B3.each((I3) => {
            let N3 = false;
            I3 = I3.clone(), I3.walkClasses((J3) => {
              J3.value === L3.value && (N3 || (J3.replaceWith(...F.nodes.map((T3) => T3.clone())), D.add(I3), N3 = true));
            });
          });
          for (let I3 of D) {
            let N3 = [
              []
            ];
            for (let J3 of I3.nodes)
              J3.type === "combinator" ? (N3.push(J3), N3.push([])) : N3[N3.length - 1].push(J3);
            I3.nodes = [];
            for (let J3 of N3)
              Array.isArray(J3) && J3.sort((T3, U2) => T3.type === "tag" && U2.type === "class" ? -1 : T3.type === "class" && U2.type === "tag" ? 1 : T3.type === "class" && U2.type === "pseudo" && U2.value.startsWith("::") ? -1 : T3.type === "pseudo" && T3.value.startsWith("::") && U2.type === "class" ? 1 : 0), I3.nodes = I3.nodes.concat(J3);
          }
          F.replaceWith(...D);
        }), $2.toString();
      }
      let S3 = /* @__PURE__ */ new Map();
      for (let P3 of q2) {
        let [C] = S3.get(P3.parent) || [
          [],
          P3.source
        ];
        S3.set(P3.parent, [
          C,
          P3.source
        ]);
        let [R3, $2] = x(P3.params);
        if (P3.parent.type === "atrule") {
          if (P3.parent.name === "screen") {
            let B3 = P3.parent.params;
            throw P3.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${R3.map((z3) => `${B3}:${z3}`).join(" ")} instead.`);
          }
          throw P3.error(`@apply is not supported within nested at-rules like @${P3.parent.name}. You can fix this by un-nesting @${P3.parent.name}.`);
        }
        for (let B3 of R3) {
          if ([
            o2(E2, "group"),
            o2(E2, "peer")
          ].includes(B3))
            throw P3.error(`@apply should not be used with the '${B3}' utility`);
          if (!M2.has(B3))
            throw P3.error(`The \`${B3}\` class does not exist. If \`${B3}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
          let z3 = M2.get(B3);
          for (let [, L3] of z3)
            L3.type !== "atrule" && L3.walkRules(() => {
              throw P3.error([
                `The \`${B3}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
                "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
                "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
              ].join(`
`));
            });
          C.push([
            B3,
            $2,
            z3
          ]);
        }
      }
      for (let [P3, [C, R3]] of S3) {
        let $2 = [];
        for (let [z3, L3, F] of C) {
          let D = [
            z3,
            ...i([
              z3
            ], E2.tailwindConfig.separator)
          ];
          for (let [I3, N3] of F) {
            let J3 = t8(P3), T3 = t8(N3);
            if (T3 = T3.groups.filter((V4) => V4.some((K3) => D.includes(K3))).flat(), T3 = T3.concat(i(T3, E2.tailwindConfig.separator)), J3.some((V4) => T3.includes(V4)))
              throw N3.error(`You cannot \`@apply\` the \`${z3}\` utility here because it creates a circular dependency.`);
            let j3 = a.default.root({
              nodes: [
                N3.clone()
              ]
            });
            j3.walk((V4) => {
              V4.source = R3;
            }), (N3.type !== "atrule" || N3.type === "atrule" && N3.name !== "keyframes") && j3.walkRules((V4) => {
              if (!t8(V4).some((de3) => de3 === z3)) {
                V4.remove();
                return;
              }
              let K3 = typeof E2.tailwindConfig.important == "string" ? E2.tailwindConfig.important : null, Q3 = P3.raws.tailwind !== void 0 && K3 && P3.selector.indexOf(K3) === 0 ? P3.selector.slice(K3.length) : P3.selector;
              Q3 === "" && (Q3 = P3.selector), V4.selector = W3(Q3, V4.selector, z3), K3 && Q3 !== P3.selector && (V4.selector = (0, f.applyImportantSelector)(V4.selector, K3)), V4.walkDecls((de3) => {
                de3.important = I3.important || L3;
              });
              let ne3 = (0, h7.default)().astSync(V4.selector);
              ne3.each((de3) => (0, s2.movePseudos)(de3)), V4.selector = ne3.toString();
            }), j3.nodes[0] && $2.push([
              I3.sort,
              j3.nodes[0]
            ]);
          }
        }
        let B3 = E2.offsets.sort($2).map((z3) => z3[1]);
        P3.after(B3);
      }
      for (let P3 of q2)
        P3.parent.nodes.length > 1 ? P3.remove() : P3.parent.remove();
      g2(A, E2, b3);
    }
    function O3(A) {
      return (E2) => {
        let b3 = w3(() => d2(E2, A));
        g2(E2, A, b3);
      };
    }
  }(Rn3)), Rn3;
}
var Ff = Nf();
var $f = He3(Ff);
var ui2 = {};
var fi2;
var Go3;
function Uf() {
  if (Go3) return fi2;
  Go3 = 1;
  class u {
    constructor(h7 = {}) {
      if (!(h7.maxSize && h7.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof h7.maxAge == "number" && h7.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = h7.maxSize, this.maxAge = h7.maxAge || 1 / 0, this.onEviction = h7.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
    }
    _emitEvictions(h7) {
      if (typeof this.onEviction == "function")
        for (const [p, l2] of h7)
          this.onEviction(p, l2.value);
    }
    _deleteIfExpired(h7, p) {
      return typeof p.expiry == "number" && p.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(h7, p.value), this.delete(h7)) : false;
    }
    _getOrDeleteIfExpired(h7, p) {
      if (this._deleteIfExpired(h7, p) === false)
        return p.value;
    }
    _getItemValue(h7, p) {
      return p.expiry ? this._getOrDeleteIfExpired(h7, p) : p.value;
    }
    _peek(h7, p) {
      const l2 = p.get(h7);
      return this._getItemValue(h7, l2);
    }
    _set(h7, p) {
      this.cache.set(h7, p), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
    }
    _moveToRecent(h7, p) {
      this.oldCache.delete(h7), this._set(h7, p);
    }
    *_entriesAscending() {
      for (const h7 of this.oldCache) {
        const [p, l2] = h7;
        this.cache.has(p) || this._deleteIfExpired(p, l2) === false && (yield h7);
      }
      for (const h7 of this.cache) {
        const [p, l2] = h7;
        this._deleteIfExpired(p, l2) === false && (yield h7);
      }
    }
    get(h7) {
      if (this.cache.has(h7)) {
        const p = this.cache.get(h7);
        return this._getItemValue(h7, p);
      }
      if (this.oldCache.has(h7)) {
        const p = this.oldCache.get(h7);
        if (this._deleteIfExpired(h7, p) === false)
          return this._moveToRecent(h7, p), p.value;
      }
    }
    set(h7, p, { maxAge: l2 = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
      this.cache.has(h7) ? this.cache.set(h7, {
        value: p,
        maxAge: l2
      }) : this._set(h7, { value: p, expiry: l2 });
    }
    has(h7) {
      return this.cache.has(h7) ? !this._deleteIfExpired(h7, this.cache.get(h7)) : this.oldCache.has(h7) ? !this._deleteIfExpired(h7, this.oldCache.get(h7)) : false;
    }
    peek(h7) {
      if (this.cache.has(h7))
        return this._peek(h7, this.cache);
      if (this.oldCache.has(h7))
        return this._peek(h7, this.oldCache);
    }
    delete(h7) {
      const p = this.cache.delete(h7);
      return p && this._size--, this.oldCache.delete(h7) || p;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(h7) {
      if (!(h7 && h7 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      const p = [...this._entriesAscending()], l2 = p.length - h7;
      l2 < 0 ? (this.cache = new Map(p), this.oldCache = /* @__PURE__ */ new Map(), this._size = p.length) : (l2 > 0 && this._emitEvictions(p.slice(0, l2)), this.oldCache = new Map(p.slice(l2)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = h7;
    }
    *keys() {
      for (const [h7] of this)
        yield h7;
    }
    *values() {
      for (const [, h7] of this)
        yield h7;
    }
    *[Symbol.iterator]() {
      for (const h7 of this.cache) {
        const [p, l2] = h7;
        this._deleteIfExpired(p, l2) === false && (yield [p, l2.value]);
      }
      for (const h7 of this.oldCache) {
        const [p, l2] = h7;
        this.cache.has(p) || this._deleteIfExpired(p, l2) === false && (yield [p, l2.value]);
      }
    }
    *entriesDescending() {
      let h7 = [...this.cache];
      for (let p = h7.length - 1; p >= 0; --p) {
        const l2 = h7[p], [f, s2] = l2;
        this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
      h7 = [...this.oldCache];
      for (let p = h7.length - 1; p >= 0; --p) {
        const l2 = h7[p], [f, s2] = l2;
        this.cache.has(f) || this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
    }
    *entriesAscending() {
      for (const [h7, p] of this._entriesAscending())
        yield [h7, p.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let h7 = 0;
      for (const p of this.oldCache.keys())
        this.cache.has(p) || h7++;
      return Math.min(this._size + h7, this.maxSize);
    }
  }
  return fi2 = u, fi2;
}
var ci2 = {};
var Yo3;
function zf() {
  return Yo3 || (Yo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(p, l2 = void 0, f = void 0) {
      return p.map((s2) => {
        let c2 = s2.clone();
        return f !== void 0 && (c2.raws.tailwind = {
          ...c2.raws.tailwind,
          ...f
        }), l2 !== void 0 && h7(c2, (t8) => {
          var e2;
          if (((e2 = t8.raws.tailwind) === null || e2 === void 0 ? void 0 : e2.preserveSource) === true && t8.source)
            return false;
          t8.source = l2;
        }), c2;
      });
    }
    function h7(p, l2) {
      if (l2(p) !== false) {
        var f;
        (f = p.each) === null || f === void 0 || f.call(p, (s2) => h7(s2, l2));
      }
    }
  }(ci2)), ci2;
}
var di2 = {};
var pi2 = {};
var Qo3;
function Wf() {
  return Qo3 || (Qo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3) Object.defineProperty(o2, m, {
        enumerable: true,
        get: v3[m]
      });
    }
    a(u, {
      pattern: function() {
        return f;
      },
      withoutCapturing: function() {
        return s2;
      },
      any: function() {
        return c2;
      },
      optional: function() {
        return t8;
      },
      zeroOrMore: function() {
        return e2;
      },
      nestedBrackets: function() {
        return r2;
      },
      escape: function() {
        return i;
      }
    });
    const h7 = /[\\^$.*+?()[\]{}|]/g, p = RegExp(h7.source);
    function l2(o2) {
      return o2 = Array.isArray(o2) ? o2 : [
        o2
      ], o2 = o2.map((v3) => v3 instanceof RegExp ? v3.source : v3), o2.join("");
    }
    function f(o2) {
      return new RegExp(l2(o2), "g");
    }
    function s2(o2) {
      return new RegExp(`(?:${l2(o2)})`, "g");
    }
    function c2(o2) {
      return `(?:${o2.map(l2).join("|")})`;
    }
    function t8(o2) {
      return `(?:${l2(o2)})?`;
    }
    function e2(o2) {
      return `(?:${l2(o2)})*`;
    }
    function r2(o2, v3, m = 1) {
      return s2([
        i(o2),
        /[^\s]*/,
        m === 1 ? `[^${i(o2)}${i(v3)}s]*` : c2([
          `[^${i(o2)}${i(v3)}s]*`,
          r2(o2, v3, m - 1)
        ]),
        /[^\s]*/,
        i(v3)
      ]);
    }
    function i(o2) {
      return o2 && p.test(o2) ? o2.replace(h7, "\\$&") : o2 || "";
    }
  }(pi2)), pi2;
}
var Ho3;
function Vf() {
  return Ho3 || (Ho3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaultExtractor", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = l2(Wf()), h7 = st3();
    function p(r2) {
      if (typeof WeakMap != "function") return null;
      var i = /* @__PURE__ */ new WeakMap(), o2 = /* @__PURE__ */ new WeakMap();
      return (p = function(v3) {
        return v3 ? o2 : i;
      })(r2);
    }
    function l2(r2, i) {
      if (r2 && r2.__esModule)
        return r2;
      if (r2 === null || typeof r2 != "object" && typeof r2 != "function")
        return {
          default: r2
        };
      var o2 = p(i);
      if (o2 && o2.has(r2))
        return o2.get(r2);
      var v3 = {}, m = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var n2 in r2)
        if (n2 !== "default" && Object.prototype.hasOwnProperty.call(r2, n2)) {
          var d2 = m ? Object.getOwnPropertyDescriptor(r2, n2) : null;
          d2 && (d2.get || d2.set) ? Object.defineProperty(v3, n2, d2) : v3[n2] = r2[n2];
        }
      return v3.default = r2, o2 && o2.set(r2, v3), v3;
    }
    function f(r2) {
      let i = Array.from(s2(r2));
      return (o2) => {
        let v3 = [];
        for (let n2 of i) {
          var m;
          for (let d2 of (m = o2.match(n2)) !== null && m !== void 0 ? m : [])
            v3.push(e2(d2));
        }
        for (let n2 of v3.slice()) {
          let d2 = (0, h7.splitAtTopLevelOnly)(n2, ".");
          for (let _3 = 0; _3 < d2.length; _3++) {
            let w3 = d2[_3];
            if (_3 >= d2.length - 1) {
              v3.push(w3);
              continue;
            }
            let y2 = Number(d2[_3 + 1]);
            isNaN(y2) ? v3.push(w3) : _3++;
          }
        }
        return v3;
      };
    }
    function* s2(r2) {
      let i = r2.tailwindConfig.separator, o2 = r2.tailwindConfig.prefix !== "" ? a.optional(a.pattern([
        /-?/,
        a.escape(r2.tailwindConfig.prefix)
      ])) : "", v3 = a.any([
        // Arbitrary properties (without square brackets)
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        // Arbitrary properties with balanced square brackets
        // This is a targeted fix to continue to allow theme()
        // with square brackets to work in arbitrary properties
        // while fixing a problem with the regex matching too much
        /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
        // Utilities
        a.pattern([
          // Utility Name / Group Name
          a.any([
            /-?(?:\w+)/,
            // This is here to make sure @container supports everything that other utilities do
            /@(?:\w+)/
          ]),
          // Normal/Arbitrary values
          a.optional(a.any([
            a.pattern([
              // Arbitrary values
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
              ]),
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            a.pattern([
              // Arbitrary values
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
              ]),
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            // Normal values w/o quotes — may include an opacity modifier
            /[-\/][^\s'"`\\$={><]*/
          ]))
        ])
      ]), m = [
        // Without quotes
        a.any([
          // This is here to provide special support for the `@` variant
          a.pattern([
            /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
            i
          ]),
          // With variant modifier (e.g.: group-[..]/modifier)
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/,
            i
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
            i
          ]),
          a.pattern([
            /[^\s"'`\[\\]+/,
            i
          ])
        ]),
        // With quotes allowed
        a.any([
          // With variant modifier (e.g.: group-[..]/modifier)
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/,
            i
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
            i
          ]),
          a.pattern([
            /[^\s`\[\\]+/,
            i
          ])
        ])
      ];
      for (const n2 of m)
        yield a.pattern([
          // Variants
          "((?=((",
          n2,
          ")+))\\2)?",
          // Important (optional)
          /!?/,
          o2,
          v3
        ]);
      yield /[^<>"'`\s.(){}[\]#=%$][^<>"'`\s(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
    }
    let c2 = /([\[\]'"`])([^\[\]'"`])?/g, t8 = /[^"'`\s<>\]]+/;
    function e2(r2) {
      if (!r2.includes("-["))
        return r2;
      let i = 0, o2 = [], v3 = r2.matchAll(c2);
      v3 = Array.from(v3).flatMap((m) => {
        const [, ...n2] = m;
        return n2.map((d2, _3) => Object.assign([], m, {
          index: m.index + _3,
          0: d2
        }));
      });
      for (let m of v3) {
        let n2 = m[0], d2 = o2[o2.length - 1];
        if (n2 === d2 ? o2.pop() : (n2 === "'" || n2 === '"' || n2 === "`") && o2.push(n2), !d2) {
          if (n2 === "[") {
            i++;
            continue;
          } else if (n2 === "]") {
            i--;
            continue;
          }
          if (i < 0)
            return r2.substring(0, m.index - 1);
          if (i === 0 && !t8.test(n2))
            return r2.substring(0, m.index);
        }
      }
      return r2;
    }
  }(di2)), di2;
}
var Jo3;
function jf() {
  return Jo3 || (Jo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return y2;
      }
    });
    const a = t8(Ne3), h7 = t8(Uf()), p = r2(yr3()), l2 = wr3(), f = t8(tt3()), s2 = t8(zf()), c2 = Vf();
    function t8(x) {
      return x && x.__esModule ? x : {
        default: x
      };
    }
    function e2(x) {
      if (typeof WeakMap != "function") return null;
      var g2 = /* @__PURE__ */ new WeakMap(), O3 = /* @__PURE__ */ new WeakMap();
      return (e2 = function(A) {
        return A ? O3 : g2;
      })(x);
    }
    function r2(x, g2) {
      if (x && x.__esModule)
        return x;
      if (x === null || typeof x != "object" && typeof x != "function")
        return {
          default: x
        };
      var O3 = e2(g2);
      if (O3 && O3.has(x))
        return O3.get(x);
      var A = {}, E2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b3 in x)
        if (b3 !== "default" && Object.prototype.hasOwnProperty.call(x, b3)) {
          var k3 = E2 ? Object.getOwnPropertyDescriptor(x, b3) : null;
          k3 && (k3.get || k3.set) ? Object.defineProperty(A, b3, k3) : A[b3] = x[b3];
        }
      return A.default = x, O3 && O3.set(x, A), A;
    }
    let i = p.env;
    const o2 = {
      DEFAULT: c2.defaultExtractor
    }, v3 = {
      DEFAULT: (x) => x,
      svelte: (x) => x.replace(/(?:^|\s)class:/g, " ")
    };
    function m(x, g2) {
      let O3 = x.tailwindConfig.content.extract;
      return O3[g2] || O3.DEFAULT || o2[g2] || o2.DEFAULT(x);
    }
    function n2(x, g2) {
      let O3 = x.content.transform;
      return O3[g2] || O3.DEFAULT || v3[g2] || v3.DEFAULT;
    }
    let d2 = /* @__PURE__ */ new WeakMap();
    function _3(x, g2, O3, A) {
      d2.has(g2) || d2.set(g2, new h7.default({
        maxSize: 25e3
      }));
      for (let E2 of x.split(`
`))
        if (E2 = E2.trim(), !A.has(E2))
          if (A.add(E2), d2.get(g2).has(E2))
            for (let b3 of d2.get(g2).get(E2))
              O3.add(b3);
          else {
            let b3 = g2(E2).filter((q2) => q2 !== "!*"), k3 = new Set(b3);
            for (let q2 of k3)
              O3.add(q2);
            d2.get(g2).set(E2, k3);
          }
    }
    function w3(x, g2) {
      let O3 = g2.offsets.sort(x), A = {
        base: /* @__PURE__ */ new Set(),
        defaults: /* @__PURE__ */ new Set(),
        components: /* @__PURE__ */ new Set(),
        utilities: /* @__PURE__ */ new Set(),
        variants: /* @__PURE__ */ new Set()
      };
      for (let [E2, b3] of O3)
        A[E2.layer].add(b3);
      return A;
    }
    function y2(x) {
      return async (g2) => {
        let O3 = {
          base: null,
          components: null,
          utilities: null,
          variants: null
        };
        if (g2.walkAtRules((F) => {
          F.name === "tailwind" && Object.keys(O3).includes(F.params) && (O3[F.params] = F);
        }), Object.values(O3).every((F) => F === null))
          return g2;
        var A;
        let E2 = /* @__PURE__ */ new Set([
          ...(A = x.candidates) !== null && A !== void 0 ? A : [],
          p.NOT_ON_DEMAND
        ]), b3 = /* @__PURE__ */ new Set();
        i.DEBUG && console.time("Reading changed files");
        let k3 = [];
        for (let F of x.changedContent) {
          let D = n2(x.tailwindConfig, F.extension), I3 = m(x, F.extension);
          k3.push([
            F,
            {
              transformer: D,
              extractor: I3
            }
          ]);
        }
        const q2 = 500;
        for (let F = 0; F < k3.length; F += q2) {
          let D = k3.slice(F, F + q2);
          await Promise.all(D.map(async ([{ file: I3, content: N3 }, { transformer: J3, extractor: T3 }]) => {
            N3 = I3 ? await a.default.promises.readFile(I3, "utf8") : N3, _3(J3(N3), T3, E2, b3);
          }));
        }
        i.DEBUG && console.timeEnd("Reading changed files");
        let M2 = x.classCache.size;
        i.DEBUG && console.time("Generate rules"), i.DEBUG && console.time("Sorting candidates");
        let W3 = new Set([
          ...E2
        ].sort((F, D) => F === D ? 0 : F < D ? -1 : 1));
        i.DEBUG && console.timeEnd("Sorting candidates"), (0, l2.generateRules)(W3, x), i.DEBUG && console.timeEnd("Generate rules"), i.DEBUG && console.time("Build stylesheet"), (x.stylesheetCache === null || x.classCache.size !== M2) && (x.stylesheetCache = w3([
          ...x.ruleCache
        ], x)), i.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: S3, base: P3, components: C, utilities: R3, variants: $2 } = x.stylesheetCache;
        O3.base && (O3.base.before((0, s2.default)([
          ...P3,
          ...S3
        ], O3.base.source, {
          layer: "base"
        })), O3.base.remove()), O3.components && (O3.components.before((0, s2.default)([
          ...C
        ], O3.components.source, {
          layer: "components"
        })), O3.components.remove()), O3.utilities && (O3.utilities.before((0, s2.default)([
          ...R3
        ], O3.utilities.source, {
          layer: "utilities"
        })), O3.utilities.remove());
        const B3 = Array.from($2).filter((F) => {
          var D;
          const I3 = (D = F.raws.tailwind) === null || D === void 0 ? void 0 : D.parentLayer;
          return I3 === "components" ? O3.components !== null : I3 === "utilities" ? O3.utilities !== null : true;
        });
        O3.variants ? (O3.variants.before((0, s2.default)(B3, O3.variants.source, {
          layer: "variants"
        })), O3.variants.remove()) : B3.length > 0 && g2.append((0, s2.default)(B3, g2.source, {
          layer: "variants"
        }));
        var z3;
        g2.source.end = (z3 = g2.source.end) !== null && z3 !== void 0 ? z3 : g2.source.start;
        const L3 = B3.some((F) => {
          var D;
          return ((D = F.raws.tailwind) === null || D === void 0 ? void 0 : D.parentLayer) === "utilities";
        });
        O3.utilities && R3.size === 0 && !L3 && f.default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]), i.DEBUG && (console.log("Potential classes: ", E2.size), console.log("Active contexts: ", p.contextSourcesMap.size)), x.changedContent = [], g2.walkAtRules("layer", (F) => {
          Object.keys(O3).includes(F.params) && F.remove();
        });
      };
    }
  }(ui2)), ui2;
}
var Bf = jf();
var Gf = He3(Bf);
var Yf = wr3();
var hi2 = {};
var Ko3;
function Qf() {
  return Ko3 || (Ko3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h7;
      }
    });
    function a(p) {
      if (!p.walkAtRules) return;
      let l2 = /* @__PURE__ */ new Set();
      if (p.walkAtRules("apply", (f) => {
        l2.add(f.parent);
      }), l2.size !== 0)
        for (let f of l2) {
          let s2 = [], c2 = [];
          for (let t8 of f.nodes)
            t8.type === "atrule" && t8.name === "apply" ? (c2.length > 0 && (s2.push(c2), c2 = []), s2.push([
              t8
            ])) : c2.push(t8);
          if (c2.length > 0 && s2.push(c2), s2.length !== 1) {
            for (let t8 of [
              ...s2
            ].reverse()) {
              let e2 = f.clone({
                nodes: []
              });
              e2.append(t8), f.after(e2);
            }
            f.remove();
          }
        }
    }
    function h7() {
      return (p) => {
        a(p);
      };
    }
  }(hi2)), hi2;
}
var Hf = Qf();
var Xo3 = He3(Hf);
var vi2 = {};
var Zo3;
function Jf() {
  return Zo3 || (Zo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3) Object.defineProperty(o2, m, {
        enumerable: true,
        get: v3[m]
      });
    }
    a(u, {
      elementSelectorParser: function() {
        return t8;
      },
      default: function() {
        return i;
      }
    });
    const h7 = f(Be2()), p = f(Ke3()), l2 = it3();
    function f(o2) {
      return o2 && o2.__esModule ? o2 : {
        default: o2
      };
    }
    let s2 = {
      id(o2) {
        return p.default.attribute({
          attribute: "id",
          operator: "=",
          value: o2.value,
          quoteMark: '"'
        });
      }
    };
    function c2(o2) {
      let v3 = o2.filter((y2) => y2.type !== "pseudo" || y2.nodes.length > 0 ? true : y2.value.startsWith("::") || [
        ":before",
        ":after",
        ":first-line",
        ":first-letter"
      ].includes(y2.value)).reverse(), m = /* @__PURE__ */ new Set([
        "tag",
        "class",
        "id",
        "attribute"
      ]), n2 = v3.findIndex((y2) => m.has(y2.type));
      if (n2 === -1) return v3.reverse().join("").trim();
      let d2 = v3[n2], _3 = s2[d2.type] ? s2[d2.type](d2) : d2;
      v3 = v3.slice(0, n2);
      let w3 = v3.findIndex((y2) => y2.type === "combinator" && y2.value === ">");
      return w3 !== -1 && (v3.splice(0, w3), v3.unshift(p.default.universal())), [
        _3,
        ...v3.reverse()
      ].join("").trim();
    }
    let t8 = (0, p.default)((o2) => o2.map((v3) => {
      let m = v3.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
      return c2(m);
    })), e2 = /* @__PURE__ */ new Map();
    function r2(o2) {
      return e2.has(o2) || e2.set(o2, t8.transformSync(o2)), e2.get(o2);
    }
    function i({ tailwindConfig: o2 }) {
      return (v3) => {
        let m = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set();
        if (v3.walkAtRules("defaults", (w3) => {
          if (w3.nodes && w3.nodes.length > 0) {
            n2.add(w3);
            return;
          }
          let y2 = w3.params;
          m.has(y2) || m.set(y2, /* @__PURE__ */ new Set()), m.get(y2).add(w3.parent), w3.remove();
        }), (0, l2.flagEnabled)(o2, "optimizeUniversalDefaults"))
          for (let w3 of n2) {
            let y2 = /* @__PURE__ */ new Map();
            var d2;
            let x = (d2 = m.get(w3.params)) !== null && d2 !== void 0 ? d2 : [];
            for (let g2 of x)
              for (let O3 of r2(g2.selector)) {
                let A = O3.includes(":-") || O3.includes("::-") || O3.includes(":has") ? O3 : "__DEFAULT__";
                var _3;
                let E2 = (_3 = y2.get(A)) !== null && _3 !== void 0 ? _3 : /* @__PURE__ */ new Set();
                y2.set(A, E2), E2.add(O3);
              }
            if ((0, l2.flagEnabled)(o2, "optimizeUniversalDefaults")) {
              if (y2.size === 0) {
                w3.remove();
                continue;
              }
              for (let [, g2] of y2) {
                let O3 = h7.default.rule({
                  source: w3.source
                });
                O3.selectors = [
                  ...g2
                ], O3.append(w3.nodes.map((A) => A.clone())), w3.before(O3);
              }
            }
            w3.remove();
          }
        else if (n2.size) {
          let w3 = h7.default.rule({
            selectors: [
              "*",
              "::before",
              "::after"
            ]
          });
          for (let x of n2)
            w3.append(x.nodes), w3.parent || x.before(w3), w3.source || (w3.source = x.source), x.remove();
          let y2 = w3.clone({
            selectors: [
              "::backdrop"
            ]
          });
          w3.after(y2);
        }
      };
    }
  }(vi2)), vi2;
}
var Kf = Jf();
var Xf = He3(Kf);
var gi2 = {};
var el;
function Zf() {
  return el || (el = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = Ui2(), h7 = p(zi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2({ tailwindConfig: { theme: f } }) {
      return function(s2) {
        s2.walkAtRules("screen", (c2) => {
          let t8 = c2.params, r2 = (0, a.normalizeScreens)(f.screens).find(({ name: i }) => i === t8);
          if (!r2)
            throw c2.error(`No \`${t8}\` screen found.`);
          c2.name = "media", c2.params = (0, h7.default)(r2);
        });
      };
    }
  }(gi2)), gi2;
}
var ec = Zf();
var tc = He3(ec);
var rc = (u, a) => u instanceof Ra2 && a instanceof Ra2 ? u.selector === a.selector || a.selector.includes("*") || a.selector.includes(":root") : u === a;
var nc = (u) => (u.walkRules((a) => {
  const h7 = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Set();
  a.walkDecls((l2) => {
    if (/var\(--[^\s)]+\)/.test(l2.value)) {
      const f = [
        ...l2.value.matchAll(/var\(--[^\s)]+\)/gm)
      ].map((s2) => s2.toString());
      u.walkDecls((s2) => {
        var c2;
        if (/--[^\s]+/.test(s2.prop)) {
          const t8 = `var(${s2.prop})`;
          if (f != null && f.includes(t8) && rc(l2.parent, s2.parent)) {
            if (((c2 = s2.parent) == null ? void 0 : c2.parent) instanceof wl && s2.parent !== l2.parent) {
              const e2 = s2.parent.parent, r2 = xu2();
              r2.prop = l2.prop, r2.value = l2.value.replaceAll(
                t8,
                s2.value
              ), r2.important = l2.important;
              const i = h7.get(e2);
              i ? i.add(r2) : h7.set(
                s2.parent.parent,
                /* @__PURE__ */ new Set([r2])
              );
              return;
            }
            p.add({
              declaration: l2,
              replacing: t8,
              replacement: s2.value
            });
          }
        }
      });
    }
  });
  for (const {
    declaration: l2,
    replacing: f,
    replacement: s2
  } of p)
    l2.value = l2.value.replaceAll(f, s2);
  for (const [l2, f] of h7.entries()) {
    const s2 = Su2();
    s2.selector = a.selector, s2.append(...f), l2.append(s2);
  }
}), u.walkDecls((a) => {
  if (/--[^\s]+/.test(a.prop)) {
    const h7 = a.parent;
    a.remove(), h7 && Li2(h7);
  }
}), u);
var ic = Ki2();
var mi2 = {};
var yi2 = {};
var wi2 = {};
var tl;
function ac() {
  return tl || (tl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = [
      "preflight",
      "container",
      "accessibility",
      "pointerEvents",
      "visibility",
      "position",
      "inset",
      "isolation",
      "zIndex",
      "order",
      "gridColumn",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRow",
      "gridRowStart",
      "gridRowEnd",
      "float",
      "clear",
      "margin",
      "boxSizing",
      "lineClamp",
      "display",
      "aspectRatio",
      "size",
      "height",
      "maxHeight",
      "minHeight",
      "width",
      "minWidth",
      "maxWidth",
      "flex",
      "flexShrink",
      "flexGrow",
      "flexBasis",
      "tableLayout",
      "captionSide",
      "borderCollapse",
      "borderSpacing",
      "transformOrigin",
      "translate",
      "rotate",
      "skew",
      "scale",
      "transform",
      "animation",
      "cursor",
      "touchAction",
      "userSelect",
      "resize",
      "scrollSnapType",
      "scrollSnapAlign",
      "scrollSnapStop",
      "scrollMargin",
      "scrollPadding",
      "listStylePosition",
      "listStyleType",
      "listStyleImage",
      "appearance",
      "columns",
      "breakBefore",
      "breakInside",
      "breakAfter",
      "gridAutoColumns",
      "gridAutoFlow",
      "gridAutoRows",
      "gridTemplateColumns",
      "gridTemplateRows",
      "flexDirection",
      "flexWrap",
      "placeContent",
      "placeItems",
      "alignContent",
      "alignItems",
      "justifyContent",
      "justifyItems",
      "gap",
      "space",
      "divideWidth",
      "divideStyle",
      "divideColor",
      "divideOpacity",
      "placeSelf",
      "alignSelf",
      "justifySelf",
      "overflow",
      "overscrollBehavior",
      "scrollBehavior",
      "textOverflow",
      "hyphens",
      "whitespace",
      "textWrap",
      "wordBreak",
      "borderRadius",
      "borderWidth",
      "borderStyle",
      "borderColor",
      "borderOpacity",
      "backgroundColor",
      "backgroundOpacity",
      "backgroundImage",
      "gradientColorStops",
      "boxDecorationBreak",
      "backgroundSize",
      "backgroundAttachment",
      "backgroundClip",
      "backgroundPosition",
      "backgroundRepeat",
      "backgroundOrigin",
      "fill",
      "stroke",
      "strokeWidth",
      "objectFit",
      "objectPosition",
      "padding",
      "textAlign",
      "textIndent",
      "verticalAlign",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "textTransform",
      "fontStyle",
      "fontVariantNumeric",
      "lineHeight",
      "letterSpacing",
      "textColor",
      "textOpacity",
      "textDecoration",
      "textDecorationColor",
      "textDecorationStyle",
      "textDecorationThickness",
      "textUnderlineOffset",
      "fontSmoothing",
      "placeholderColor",
      "placeholderOpacity",
      "caretColor",
      "accentColor",
      "opacity",
      "backgroundBlendMode",
      "mixBlendMode",
      "boxShadow",
      "boxShadowColor",
      "outlineStyle",
      "outlineWidth",
      "outlineOffset",
      "outlineColor",
      "ringWidth",
      "ringColor",
      "ringOpacity",
      "ringOffsetWidth",
      "ringOffsetColor",
      "blur",
      "brightness",
      "contrast",
      "dropShadow",
      "grayscale",
      "hueRotate",
      "invert",
      "saturate",
      "sepia",
      "filter",
      "backdropBlur",
      "backdropBrightness",
      "backdropContrast",
      "backdropGrayscale",
      "backdropHueRotate",
      "backdropInvert",
      "backdropOpacity",
      "backdropSaturate",
      "backdropSepia",
      "backdropFilter",
      "transitionProperty",
      "transitionDelay",
      "transitionDuration",
      "transitionTimingFunction",
      "willChange",
      "contain",
      "content",
      "forcedColorAdjust"
    ];
  }(wi2)), wi2;
}
var bi2 = {};
var rl;
function sc() {
  return rl || (rl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7, p) {
      return h7 === void 0 ? p : Array.isArray(h7) ? h7 : [
        ...new Set(p.filter((f) => h7 !== false && h7[f] !== false).concat(Object.keys(h7).filter((f) => h7[f] !== false)))
      ];
    }
  }(bi2)), bi2;
}
var _i2 = {};
var nl2;
function oc() {
  return nl2 || (nl2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = h7(tt3());
    function h7(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function p({ version: f, from: s2, to: c2 }) {
      a.default.warn(`${s2}-color-renamed`, [
        `As of Tailwind CSS ${f}, \`${s2}\` has been renamed to \`${c2}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    const l2 = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a",
        950: "#020617"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827",
        950: "#030712"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b",
        950: "#09090b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717",
        950: "#0a0a0a"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917",
        950: "#0c0a09"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d",
        950: "#450a0a"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12",
        950: "#431407"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f",
        950: "#451a03"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12",
        950: "#422006"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314",
        950: "#1a2e05"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d",
        950: "#052e16"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b",
        950: "#022c22"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a",
        950: "#042f2e"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63",
        950: "#083344"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e",
        950: "#082f49"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a",
        950: "#172554"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81",
        950: "#1e1b4b"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95",
        950: "#2e1065"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87",
        950: "#3b0764"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75",
        950: "#4a044e"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843",
        950: "#500724"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337",
        950: "#4c0519"
      },
      get lightBlue() {
        return p({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        }), this.sky;
      },
      get warmGray() {
        return p({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        }), this.stone;
      },
      get trueGray() {
        return p({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        }), this.neutral;
      },
      get coolGray() {
        return p({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        }), this.gray;
      },
      get blueGray() {
        return p({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        }), this.slate;
      }
    };
  }(_i2)), _i2;
}
var Si2 = {};
var il;
function lc() {
  return il || (il = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaults", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7, ...p) {
      for (let s2 of p) {
        for (let c2 in s2) {
          var l2;
          !(h7 == null || (l2 = h7.hasOwnProperty) === null || l2 === void 0) && l2.call(h7, c2) || (h7[c2] = s2[c2]);
        }
        for (let c2 of Object.getOwnPropertySymbols(s2)) {
          var f;
          !(h7 == null || (f = h7.hasOwnProperty) === null || f === void 0) && f.call(h7, c2) || (h7[c2] = s2[c2]);
        }
      }
      return h7;
    }
  }(Si2)), Si2;
}
var xi2 = {};
var al;
function uc() {
  return al || (al = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "normalizeConfig", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = it3(), h7 = l2(tt3());
    function p(s2) {
      if (typeof WeakMap != "function") return null;
      var c2 = /* @__PURE__ */ new WeakMap(), t8 = /* @__PURE__ */ new WeakMap();
      return (p = function(e2) {
        return e2 ? t8 : c2;
      })(s2);
    }
    function l2(s2, c2) {
      if (s2 && s2.__esModule)
        return s2;
      if (s2 === null || typeof s2 != "object" && typeof s2 != "function")
        return {
          default: s2
        };
      var t8 = p(c2);
      if (t8 && t8.has(s2))
        return t8.get(s2);
      var e2 = {}, r2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i in s2)
        if (i !== "default" && Object.prototype.hasOwnProperty.call(s2, i)) {
          var o2 = r2 ? Object.getOwnPropertyDescriptor(s2, i) : null;
          o2 && (o2.get || o2.set) ? Object.defineProperty(e2, i, o2) : e2[i] = s2[i];
        }
      return e2.default = s2, t8 && t8.set(s2, e2), e2;
    }
    function f(s2) {
      if ((() => {
        if (s2.purge || !s2.content || !Array.isArray(s2.content) && !(typeof s2.content == "object" && s2.content !== null))
          return false;
        if (Array.isArray(s2.content))
          return s2.content.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? void 0 : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? void 0 : e2.extension) != "string"));
        if (typeof s2.content == "object" && s2.content !== null) {
          if (Object.keys(s2.content).some((e2) => ![
            "files",
            "relative",
            "extract",
            "transform"
          ].includes(e2)))
            return false;
          if (Array.isArray(s2.content.files)) {
            if (!s2.content.files.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? void 0 : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? void 0 : e2.extension) != "string")))
              return false;
            if (typeof s2.content.extract == "object") {
              for (let e2 of Object.values(s2.content.extract))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.extract === void 0 || typeof s2.content.extract == "function"))
              return false;
            if (typeof s2.content.transform == "object") {
              for (let e2 of Object.values(s2.content.transform))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.transform === void 0 || typeof s2.content.transform == "function"))
              return false;
            if (typeof s2.content.relative != "boolean" && typeof s2.content.relative < "u")
              return false;
          }
          return true;
        }
        return false;
      })() || h7.default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]), s2.safelist = (() => {
        var e2;
        let { content: r2, purge: i, safelist: o2 } = s2;
        return Array.isArray(o2) ? o2 : Array.isArray(r2 == null ? void 0 : r2.safelist) ? r2.safelist : Array.isArray(i == null ? void 0 : i.safelist) ? i.safelist : Array.isArray(i == null || (e2 = i.options) === null || e2 === void 0 ? void 0 : e2.safelist) ? i.options.safelist : [];
      })(), s2.blocklist = (() => {
        let { blocklist: e2 } = s2;
        if (Array.isArray(e2)) {
          if (e2.every((r2) => typeof r2 == "string"))
            return e2;
          h7.default.warn("blocklist-invalid", [
            "The `blocklist` option must be an array of strings.",
            "https://tailwindcss.com/docs/content-configuration#discarding-classes"
          ]);
        }
        return [];
      })(), typeof s2.prefix == "function")
        h7.default.warn("prefix-function", [
          "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
          "Update `prefix` in your configuration to be a string to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]), s2.prefix = "";
      else {
        var t8;
        s2.prefix = (t8 = s2.prefix) !== null && t8 !== void 0 ? t8 : "";
      }
      s2.content = {
        relative: (() => {
          let { content: e2 } = s2;
          return e2 != null && e2.relative ? e2.relative : (0, a.flagEnabled)(s2, "relativeContentPathsByDefault");
        })(),
        files: (() => {
          let { content: e2, purge: r2 } = s2;
          return Array.isArray(r2) ? r2 : Array.isArray(r2 == null ? void 0 : r2.content) ? r2.content : Array.isArray(e2) ? e2 : Array.isArray(e2 == null ? void 0 : e2.content) ? e2.content : Array.isArray(e2 == null ? void 0 : e2.files) ? e2.files : [];
        })(),
        extract: (() => {
          let e2 = (() => {
            var o2, v3, m, n2, d2, _3, w3, y2, x, g2;
            return !((o2 = s2.purge) === null || o2 === void 0) && o2.extract ? s2.purge.extract : !((v3 = s2.content) === null || v3 === void 0) && v3.extract ? s2.content.extract : !((m = s2.purge) === null || m === void 0 || (n2 = m.extract) === null || n2 === void 0) && n2.DEFAULT ? s2.purge.extract.DEFAULT : !((d2 = s2.content) === null || d2 === void 0 || (_3 = d2.extract) === null || _3 === void 0) && _3.DEFAULT ? s2.content.extract.DEFAULT : !((w3 = s2.purge) === null || w3 === void 0 || (y2 = w3.options) === null || y2 === void 0) && y2.extractors ? s2.purge.options.extractors : !((x = s2.content) === null || x === void 0 || (g2 = x.options) === null || g2 === void 0) && g2.extractors ? s2.content.options.extractors : {};
          })(), r2 = {}, i = (() => {
            var o2, v3, m, n2;
            if (!((o2 = s2.purge) === null || o2 === void 0 || (v3 = o2.options) === null || v3 === void 0) && v3.defaultExtractor)
              return s2.purge.options.defaultExtractor;
            if (!((m = s2.content) === null || m === void 0 || (n2 = m.options) === null || n2 === void 0) && n2.defaultExtractor)
              return s2.content.options.defaultExtractor;
          })();
          if (i !== void 0 && (r2.DEFAULT = i), typeof e2 == "function")
            r2.DEFAULT = e2;
          else if (Array.isArray(e2))
            for (let { extensions: o2, extractor: v3 } of e2 ?? [])
              for (let m of o2)
                r2[m] = v3;
          else typeof e2 == "object" && e2 !== null && Object.assign(r2, e2);
          return r2;
        })(),
        transform: (() => {
          let e2 = (() => {
            var i, o2, v3, m, n2, d2;
            return !((i = s2.purge) === null || i === void 0) && i.transform ? s2.purge.transform : !((o2 = s2.content) === null || o2 === void 0) && o2.transform ? s2.content.transform : !((v3 = s2.purge) === null || v3 === void 0 || (m = v3.transform) === null || m === void 0) && m.DEFAULT ? s2.purge.transform.DEFAULT : !((n2 = s2.content) === null || n2 === void 0 || (d2 = n2.transform) === null || d2 === void 0) && d2.DEFAULT ? s2.content.transform.DEFAULT : {};
          })(), r2 = {};
          return typeof e2 == "function" ? r2.DEFAULT = e2 : typeof e2 == "object" && e2 !== null && Object.assign(r2, e2), r2;
        })()
      };
      for (let e2 of s2.content.files)
        if (typeof e2 == "string" && /{([^,]*?)}/g.test(e2)) {
          h7.default.warn("invalid-glob-braces", [
            `The glob pattern ${(0, h7.dim)(e2)} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${(0, h7.dim)(e2.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          ]);
          break;
        }
      return s2;
    }
  }(xi2)), xi2;
}
var Oi2 = {};
var sl;
function fc() {
  return sl || (sl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "cloneDeep", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h7) {
      return Array.isArray(h7) ? h7.map((p) => a(p)) : typeof h7 == "object" && h7 !== null ? Object.fromEntries(Object.entries(h7).map(([p, l2]) => [
        p,
        a(l2)
      ])) : h7;
    }
  }(Oi2)), Oi2;
}
var ol;
function cc() {
  return ol || (ol = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return q2;
      }
    });
    const a = v3(ji2()), h7 = v3(ac()), p = v3(sc()), l2 = v3(oc()), f = lc(), s2 = Wi2(), c2 = uc(), t8 = v3(ut3()), e2 = fc(), r2 = gr3(), i = hr3(), o2 = v3(iu3());
    function v3(M2) {
      return M2 && M2.__esModule ? M2 : {
        default: M2
      };
    }
    function m(M2) {
      return typeof M2 == "function";
    }
    function n2(M2, ...W3) {
      let S3 = W3.pop();
      for (let P3 of W3)
        for (let C in P3) {
          let R3 = S3(M2[C], P3[C]);
          R3 === void 0 ? (0, t8.default)(M2[C]) && (0, t8.default)(P3[C]) ? M2[C] = n2({}, M2[C], P3[C], S3) : M2[C] = P3[C] : M2[C] = R3;
        }
      return M2;
    }
    const d2 = {
      colors: l2.default,
      negative(M2) {
        return Object.keys(M2).filter((W3) => M2[W3] !== "0").reduce((W3, S3) => {
          let P3 = (0, a.default)(M2[S3]);
          return P3 !== void 0 && (W3[`-${S3}`] = P3), W3;
        }, {});
      },
      breakpoints(M2) {
        return Object.keys(M2).filter((W3) => typeof M2[W3] == "string").reduce((W3, S3) => ({
          ...W3,
          [`screen-${S3}`]: M2[S3]
        }), {});
      }
    };
    function _3(M2, ...W3) {
      return m(M2) ? M2(...W3) : M2;
    }
    function w3(M2) {
      return M2.reduce((W3, { extend: S3 }) => n2(W3, S3, (P3, C) => P3 === void 0 ? [
        C
      ] : Array.isArray(P3) ? [
        C,
        ...P3
      ] : [
        C,
        P3
      ]), {});
    }
    function y2(M2) {
      return {
        ...M2.reduce((W3, S3) => (0, f.defaults)(W3, S3), {}),
        // In order to resolve n config objects, we combine all of their `extend` properties
        // into arrays instead of objects so they aren't overridden.
        extend: w3(M2)
      };
    }
    function x(M2, W3) {
      if (Array.isArray(M2) && (0, t8.default)(M2[0]))
        return M2.concat(W3);
      if (Array.isArray(W3) && (0, t8.default)(W3[0]) && (0, t8.default)(M2))
        return [
          M2,
          ...W3
        ];
      if (Array.isArray(W3))
        return W3;
    }
    function g2({ extend: M2, ...W3 }) {
      return n2(W3, M2, (S3, P3) => !m(S3) && !P3.some(m) ? n2({}, S3, ...P3, x) : (C, R3) => n2({}, ...[
        S3,
        ...P3
      ].map(($2) => _3($2, C, R3)), x));
    }
    function* O3(M2) {
      let W3 = (0, s2.toPath)(M2);
      if (W3.length === 0 || (yield W3, Array.isArray(M2)))
        return;
      let S3 = /^(.*?)\s*\/\s*([^/]+)$/, P3 = M2.match(S3);
      if (P3 !== null) {
        let [, C, R3] = P3, $2 = (0, s2.toPath)(C);
        $2.alpha = R3, yield $2;
      }
    }
    function A(M2) {
      const W3 = (S3, P3) => {
        for (const C of O3(S3)) {
          let R3 = 0, $2 = M2;
          for (; $2 != null && R3 < C.length; )
            $2 = $2[C[R3++]], $2 = m($2) && (C.alpha === void 0 || R3 <= C.length - 1) ? $2(W3, d2) : $2;
          if ($2 !== void 0) {
            if (C.alpha !== void 0) {
              let B3 = (0, r2.parseColorFormat)($2);
              return (0, i.withAlphaValue)(B3, C.alpha, (0, o2.default)(B3));
            }
            return (0, t8.default)($2) ? (0, e2.cloneDeep)($2) : $2;
          }
        }
        return P3;
      };
      return Object.assign(W3, {
        theme: W3,
        ...d2
      }), Object.keys(M2).reduce((S3, P3) => (S3[P3] = m(M2[P3]) ? M2[P3](W3, d2) : M2[P3], S3), {});
    }
    function E2(M2) {
      let W3 = [];
      return M2.forEach((S3) => {
        W3 = [
          ...W3,
          S3
        ];
        var P3;
        const C = (P3 = S3 == null ? void 0 : S3.plugins) !== null && P3 !== void 0 ? P3 : [];
        C.length !== 0 && C.forEach((R3) => {
          R3.__isOptionsFunction && (R3 = R3());
          var $2;
          W3 = [
            ...W3,
            ...E2([
              ($2 = R3 == null ? void 0 : R3.config) !== null && $2 !== void 0 ? $2 : {}
            ])
          ];
        });
      }), W3;
    }
    function b3(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => m(P3) ? P3({
        corePlugins: S3
      }) : (0, p.default)(P3, S3), h7.default);
    }
    function k3(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => [
        ...S3,
        ...P3
      ], []);
    }
    function q2(M2) {
      let W3 = [
        ...E2(M2),
        {
          prefix: "",
          important: false,
          separator: ":"
        }
      ];
      var S3, P3;
      return (0, c2.normalizeConfig)((0, f.defaults)({
        theme: A(g2(y2(W3.map((C) => (S3 = C == null ? void 0 : C.theme) !== null && S3 !== void 0 ? S3 : {})))),
        corePlugins: b3(W3.map((C) => C.corePlugins)),
        plugins: k3(M2.map((C) => (P3 = C == null ? void 0 : C.plugins) !== null && P3 !== void 0 ? P3 : []))
      }, ...W3));
    }
  }(yi2)), yi2;
}
var ki2 = {};
var Pi2;
var ll;
function dc() {
  return ll || (ll = 1, Pi2 = {
    content: [],
    presets: [],
    darkMode: "media",
    // or 'class'
    theme: {
      accentColor: ({ theme: u }) => ({
        ...u("colors"),
        auto: "auto"
      }),
      animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
      },
      aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
      },
      aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9"
      },
      backdropBlur: ({ theme: u }) => u("blur"),
      backdropBrightness: ({ theme: u }) => u("brightness"),
      backdropContrast: ({ theme: u }) => u("contrast"),
      backdropGrayscale: ({ theme: u }) => u("grayscale"),
      backdropHueRotate: ({ theme: u }) => u("hueRotate"),
      backdropInvert: ({ theme: u }) => u("invert"),
      backdropOpacity: ({ theme: u }) => u("opacity"),
      backdropSaturate: ({ theme: u }) => u("saturate"),
      backdropSepia: ({ theme: u }) => u("sepia"),
      backgroundColor: ({ theme: u }) => u("colors"),
      backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
      },
      backgroundOpacity: ({ theme: u }) => u("opacity"),
      backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
      },
      blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
      },
      borderColor: ({ theme: u }) => ({
        ...u("colors"),
        DEFAULT: u("colors.gray.200", "currentColor")
      }),
      borderOpacity: ({ theme: u }) => u("opacity"),
      borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
      },
      borderSpacing: ({ theme: u }) => ({
        ...u("spacing")
      }),
      borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
      },
      boxShadowColor: ({ theme: u }) => u("colors"),
      brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      caretColor: ({ theme: u }) => u("colors"),
      colors: ({ colors: u }) => ({
        inherit: u.inherit,
        current: u.current,
        transparent: u.transparent,
        black: u.black,
        white: u.white,
        slate: u.slate,
        gray: u.gray,
        zinc: u.zinc,
        neutral: u.neutral,
        stone: u.stone,
        red: u.red,
        orange: u.orange,
        amber: u.amber,
        yellow: u.yellow,
        lime: u.lime,
        green: u.green,
        emerald: u.emerald,
        teal: u.teal,
        cyan: u.cyan,
        sky: u.sky,
        blue: u.blue,
        indigo: u.indigo,
        violet: u.violet,
        purple: u.purple,
        fuchsia: u.fuchsia,
        pink: u.pink,
        rose: u.rose
      }),
      columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem"
      },
      container: {},
      content: {
        none: "none"
      },
      contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
      },
      divideColor: ({ theme: u }) => u("borderColor"),
      divideOpacity: ({ theme: u }) => u("borderOpacity"),
      divideWidth: ({ theme: u }) => u("borderWidth"),
      dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
        md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
        lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
        xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
      },
      fill: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
      },
      flexBasis: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%"
      }),
      flexGrow: {
        0: "0",
        DEFAULT: "1"
      },
      flexShrink: {
        0: "0",
        DEFAULT: "1"
      },
      fontFamily: {
        sans: [
          "ui-sans-serif",
          "system-ui",
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"'
        ],
        serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace"
        ]
      },
      fontSize: {
        xs: ["0.75rem", { lineHeight: "1rem" }],
        sm: ["0.875rem", { lineHeight: "1.25rem" }],
        base: ["1rem", { lineHeight: "1.5rem" }],
        lg: ["1.125rem", { lineHeight: "1.75rem" }],
        xl: ["1.25rem", { lineHeight: "1.75rem" }],
        "2xl": ["1.5rem", { lineHeight: "2rem" }],
        "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
        "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
        "5xl": ["3rem", { lineHeight: "1" }],
        "6xl": ["3.75rem", { lineHeight: "1" }],
        "7xl": ["4.5rem", { lineHeight: "1" }],
        "8xl": ["6rem", { lineHeight: "1" }],
        "9xl": ["8rem", { lineHeight: "1" }]
      },
      fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
      },
      gap: ({ theme: u }) => u("spacing"),
      gradientColorStops: ({ theme: u }) => u("colors"),
      gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%"
      },
      grayscale: {
        0: "0",
        DEFAULT: "100%"
      },
      gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      height: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg"
      },
      inset: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      invert: {
        0: "0",
        DEFAULT: "100%"
      },
      keyframes: {
        spin: {
          to: {
            transform: "rotate(360deg)"
          }
        },
        ping: {
          "75%, 100%": {
            transform: "scale(2)",
            opacity: "0"
          }
        },
        pulse: {
          "50%": {
            opacity: ".5"
          }
        },
        bounce: {
          "0%, 100%": {
            transform: "translateY(-25%)",
            animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
          },
          "50%": {
            transform: "none",
            animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
          }
        }
      },
      letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
      },
      lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
      },
      listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
      },
      listStyleImage: {
        none: "none"
      },
      margin: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing")
      }),
      lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6"
      },
      maxHeight: ({ theme: u }) => ({
        ...u("spacing"),
        none: "none",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      maxWidth: ({ theme: u, breakpoints: a }) => ({
        ...u("spacing"),
        none: "none",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content",
        prose: "65ch",
        ...a(u("screens"))
      }),
      minHeight: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      minWidth: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1"
      },
      order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12"
      },
      outlineColor: ({ theme: u }) => u("colors"),
      outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      padding: ({ theme: u }) => u("spacing"),
      placeholderColor: ({ theme: u }) => u("colors"),
      placeholderOpacity: ({ theme: u }) => u("opacity"),
      ringColor: ({ theme: u }) => ({
        DEFAULT: u("colors.blue.500", "#3b82f6"),
        ...u("colors")
      }),
      ringOffsetColor: ({ theme: u }) => u("colors"),
      ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      ringOpacity: ({ theme: u }) => ({
        DEFAULT: "0.5",
        ...u("opacity")
      }),
      ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg"
      },
      saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2"
      },
      scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5"
      },
      screens: {
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px"
      },
      scrollMargin: ({ theme: u }) => ({
        ...u("spacing")
      }),
      scrollPadding: ({ theme: u }) => u("spacing"),
      sepia: {
        0: "0",
        DEFAULT: "100%"
      },
      skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg"
      },
      space: ({ theme: u }) => ({
        ...u("spacing")
      }),
      spacing: {
        px: "1px",
        0: "0px",
        0.5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
      },
      stroke: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      strokeWidth: {
        0: "0",
        1: "1",
        2: "2"
      },
      supports: {},
      data: {},
      textColor: ({ theme: u }) => u("colors"),
      textDecorationColor: ({ theme: u }) => u("colors"),
      textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      textIndent: ({ theme: u }) => ({
        ...u("spacing")
      }),
      textOpacity: ({ theme: u }) => u("opacity"),
      textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
      },
      transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
      },
      transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
      },
      translate: ({ theme: u }) => ({
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      size: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      width: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        screen: "100vw",
        svw: "100svw",
        lvw: "100lvw",
        dvw: "100dvw",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
      },
      zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50"
      }
    },
    plugins: []
  }), Pi2;
}
var ul;
function pc() {
  return ul || (ul = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(dc()), h7 = it3();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      var s2;
      const c2 = ((s2 = f == null ? void 0 : f.presets) !== null && s2 !== void 0 ? s2 : [
        a.default
      ]).slice().reverse().flatMap((r2) => l2(r2 instanceof Function ? r2() : r2)), t8 = {
        // Add experimental configs here...
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: ({ theme: r2 }) => ({
              DEFAULT: "#3b82f67f",
              ...r2("colors")
            })
          }
        },
        disableColorOpacityUtilitiesByDefault: {
          corePlugins: {
            backgroundOpacity: false,
            borderOpacity: false,
            divideOpacity: false,
            placeholderOpacity: false,
            ringOpacity: false,
            textOpacity: false
          }
        }
      }, e2 = Object.keys(t8).filter((r2) => (0, h7.flagEnabled)(f, r2)).map((r2) => t8[r2]);
      return [
        f,
        ...e2,
        ...c2
      ];
    }
  }(ki2)), ki2;
}
var fl;
function hc() {
  return fl || (fl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = p(cc()), h7 = p(pc());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(...f) {
      let [, ...s2] = (0, h7.default)(f[0]);
      return (0, a.default)([
        ...f,
        ...s2
      ]);
    }
  }(mi2)), mi2;
}
var Ei;
var cl;
function vc() {
  if (cl) return Ei;
  cl = 1;
  let u = hc();
  return Ei = (u.__esModule ? u : { default: u }).default, Ei;
}
var gc = vc();
var mc = He3(gc);
var yc = (u) => ic.createContext(
  mc({
    ...u,
    content: [],
    corePlugins: {
      preflight: false
    }
  })
);
var wc = _u2(
  `
  @tailwind base;
  @tailwind components;
`
).root();
function bc(u) {
  "safelist" in u && (console.warn(
    "The `safelist` option is not supported in the `Tailwind` component, it will not change any behavior."
  ), delete u.safelist);
  const a = yc(u);
  return {
    generateRootForClasses: (h7) => {
      a.candidateRuleCache = /* @__PURE__ */ new Map();
      const p = Yf.generateRules(
        new Set(h7),
        a
      ), l2 = wc.clone().append(...p.map(([, f]) => f));
      return Xo3()(l2), Gf(a)(l2), Xo3()(l2), $f(a)(l2), ff(a)(l2), tc(a)(l2), Xf(a)(l2), Hu2()(l2), Xu2()(l2), nc(l2), l2;
    }
  };
}
var xc = {
  theme: {
    fontSize: {
      xs: ["12px", { lineHeight: "16px" }],
      sm: ["14px", { lineHeight: "20px" }],
      base: ["16px", { lineHeight: "24px" }],
      lg: ["18px", { lineHeight: "28px" }],
      xl: ["20px", { lineHeight: "28px" }],
      "2xl": ["24px", { lineHeight: "32px" }],
      "3xl": ["30px", { lineHeight: "36px" }],
      "4xl": ["36px", { lineHeight: "36px" }],
      "5xl": ["48px", { lineHeight: "1" }],
      "6xl": ["60px", { lineHeight: "1" }],
      "7xl": ["72px", { lineHeight: "1" }],
      "8xl": ["96px", { lineHeight: "1" }],
      "9xl": ["144px", { lineHeight: "1" }]
    },
    spacing: {
      px: "1px",
      0: "0",
      0.5: "2px",
      1: "4px",
      1.5: "6px",
      2: "8px",
      2.5: "10px",
      3: "12px",
      3.5: "14px",
      4: "16px",
      5: "20px",
      6: "24px",
      7: "28px",
      8: "32px",
      9: "36px",
      10: "40px",
      11: "44px",
      12: "48px",
      14: "56px",
      16: "64px",
      20: "80px",
      24: "96px",
      28: "112px",
      32: "128px",
      36: "144px",
      40: "160px",
      44: "176px",
      48: "192px",
      52: "208px",
      56: "224px",
      60: "240px",
      64: "256px",
      72: "288px",
      80: "320px",
      96: "384px"
    }
  }
};
var Oc = ({ children: u, config: a }) => {
  const h7 = bc(a ?? {}), p = new Ou2();
  let l2 = [], f = false, s2 = sr3(u, (c2) => {
    if (Or3.isValidElement(c2)) {
      const {
        elementWithInlinedStyles: t8,
        nonInlinableClasses: e2,
        nonInlineStyleNodes: r2
      } = Gu2(c2, h7);
      return l2 = l2.concat(e2), p.append(r2), e2.length > 0 && !f && (f = true), t8;
    }
    return c2;
  });
  if (Pu2(p), f) {
    let c2 = false;
    if (s2 = sr3(s2, (t8) => {
      if (c2)
        return t8;
      if (Or3.isValidElement(t8) && t8.type === "head") {
        c2 = true;
        const e2 = (0, import_jsx_runtime19.jsx)("style", { children: ku2(p.toString().trim()) });
        return Or3.cloneElement(
          t8,
          t8.props,
          t8.props.children,
          e2
        );
      }
      return t8;
    }), !c2)
      throw new Error(
        `You are trying to use the following Tailwind classes that cannot be inlined: ${l2.join(
          " "
        )}.
For the media queries to work properly on rendering, they need to be added into a <style> tag inside of a <head> tag,
the Tailwind component tried finding a <head> element but just wasn't able to find it.

Make sure that you have a <head> element at some point inside of the <Tailwind> component at any depth. 
This can also be our <Head> component.

If you do already have a <head> element at some depth, 
please file a bug https://github.com/resend/react-email/issues/new?assignees=&labels=Type%3A+Bug&projects=&template=1.bug_report.yml.`
      );
  }
  return s2;
};

// node_modules/@react-email/text/dist/index.mjs
var React18 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var __defProp18 = Object.defineProperty;
var __defProps18 = Object.defineProperties;
var __getOwnPropDescs18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols18 = Object.getOwnPropertySymbols;
var __hasOwnProp18 = Object.prototype.hasOwnProperty;
var __propIsEnum18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues18 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp18.call(b3, prop))
      __defNormalProp18(a, prop, b3[prop]);
  if (__getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(b3)) {
      if (__propIsEnum18.call(b3, prop))
        __defNormalProp18(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps18 = (a, b3) => __defProps18(a, __getOwnPropDescs18(b3));
var __objRest17 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp18.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum18.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function parseMarginValue(value) {
  if (typeof value === "number")
    return {
      marginTop: value,
      marginBottom: value,
      marginLeft: value,
      marginRight: value
    };
  if (typeof value === "string") {
    const values = value.toString().trim().split(/\s+/);
    if (values.length === 1) {
      return {
        marginTop: values[0],
        marginBottom: values[0],
        marginLeft: values[0],
        marginRight: values[0]
      };
    }
    if (values.length === 2) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[0],
        marginLeft: values[1]
      };
    }
    if (values.length === 3) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[2],
        marginLeft: values[1]
      };
    }
    if (values.length === 4) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[2],
        marginLeft: values[3]
      };
    }
  }
  return {
    marginTop: void 0,
    marginBottom: void 0,
    marginLeft: void 0,
    marginRight: void 0
  };
}
function computeMargins(properties) {
  let result = {
    marginTop: void 0,
    marginRight: void 0,
    marginBottom: void 0,
    marginLeft: void 0
  };
  for (const [key, value] of Object.entries(properties)) {
    if (key === "margin") {
      result = parseMarginValue(value);
    } else if (key === "marginTop") {
      result.marginTop = value;
    } else if (key === "marginRight") {
      result.marginRight = value;
    } else if (key === "marginBottom") {
      result.marginBottom = value;
    } else if (key === "marginLeft") {
      result.marginLeft = value;
    }
  }
  return result;
}
var Text3 = React18.forwardRef(
  (_a5, ref) => {
    var _b = _a5, { style } = _b, props = __objRest17(_b, ["style"]);
    const defaultMargins = {};
    if ((style == null ? void 0 : style.marginTop) === void 0) {
      defaultMargins.marginTop = "16px";
    }
    if ((style == null ? void 0 : style.marginBottom) === void 0) {
      defaultMargins.marginBottom = "16px";
    }
    const margins = computeMargins(__spreadValues18(__spreadValues18({}, defaultMargins), style));
    return (0, import_jsx_runtime20.jsx)(
      "p",
      __spreadProps18(__spreadValues18({}, props), {
        ref,
        style: __spreadValues18(__spreadValues18({
          fontSize: "14px",
          lineHeight: "24px"
        }, style), margins)
      })
    );
  }
);
Text3.displayName = "Text";
export {
  Body,
  Button,
  CodeBlock,
  CodeInline,
  Column,
  Container,
  Font,
  Head,
  Heading,
  Hr,
  Html,
  Img,
  Link,
  Markdown,
  Preview,
  Row,
  Section,
  Oc as Tailwind,
  Text3 as Text,
  a11yDark,
  atomDark,
  baseAteliersulphurpoolLight,
  cb,
  coldarkCold,
  coldarkDark,
  coyWithoutShadows,
  darcula,
  dracula,
  duotoneDark,
  duotoneEarth,
  duotoneForest,
  duotoneLight,
  duotoneSea,
  duotoneSpace,
  ghcolors,
  gruvboxDark,
  gruvboxLight,
  holiTheme,
  hopscotch,
  laserwave,
  lucario,
  materialDark,
  materialLight,
  materialOceanic,
  nightOwl,
  nord,
  oneDark,
  oneLight,
  xc as pixelBasedPreset,
  plainTextSelectors,
  pojoaque,
  pretty,
  render2 as render,
  renderAsync,
  renderWhiteSpace,
  shadesOfPurple,
  solarizedDarkAtom,
  synthwave84,
  vesper,
  vs,
  vscDarkPlus,
  xonokai,
  zTouch
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

@react-email/tailwind/dist/index.mjs:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
//# sourceMappingURL=@react-email_components.js.map
